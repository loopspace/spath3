% \iffalse meta-comment
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
spath --- Functions for manipulating PGF soft paths
E-mail: stacey@math.ntnu.no
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package defines some functions used to manipulate PGFs soft paths.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
spath --- Functions for manipulating PGF soft paths
E-mail: stacey@math.ntnu.no
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2011 by Andrew Stacey <stacey@math.ntnu.no>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Andrew Stacey.

This work consists of the file  spath.dtx
and the derived files           spath.ins,
                                spath.pdf, and
                                spath.sty.

\endpostamble
\usedir{tex/latex/spath}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/spath}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/demopkg}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*package>
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{spath}[2011/06/03 v1.0 Functions for manipulating PGF soft paths]
%</package>
%<*driver>
\documentclass{ltxdoc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
%\usepackage{morefloats}
\usepackage{tikz}
\usepackage{\jobname}
\usepackage[numbered]{hypdoc}
\definecolor{lstbgcolor}{rgb}{0.9,0.9,0.9} 
 
\usepackage{listings}
\lstloadlanguages{[LaTeX]TeX}
\lstset{breakatwhitespace=true,breaklines=true,language=TeX}
 
\usepackage{fancyvrb}

\newenvironment{example}
  {\VerbatimEnvironment
   \begin{VerbatimOut}[gobble=2]{example.out}}
  {\end{VerbatimOut}
   \begin{center}
%   \setlength{\parindent}{0pt}
   \fbox{\begin{minipage}{.9\linewidth}
     \lstset{breakatwhitespace=true,breaklines=true,language=TeX,basicstyle=\small}
     \lstinputlisting[]{example.out}
   \end{minipage}}

   \fbox{\begin{minipage}{.9\linewidth}
     \input{example.out}
   \end{minipage}}
\end{center}
}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{1.0}{2011/05/03}{Converted to DTX file}
%
% \DoNotIndex{\newcommand,\newenvironment}
%
% \providecommand*{\url}{\texttt}
% \GetFileInfo{spath.dtx}
% \title{The \textsf{spath} package}
% \author{Andrew Stacey \\ \url{stacey@math.ntnu.no}}
% \date{\fileversion~from \filedate}
%
%
% \maketitle
%
% 
% \section{Introduction}
%
% \StopEventually{}
%
% \section{Implementation}
%
% \iffalse
%<*package>
% \fi
%
% Set up tokens for comparison
%    \begin{macrocode}
\usepgfmodule{oo}

\long\def\ge@addto@macro#1#2{%
  \begingroup
  \toks@\expandafter\expandafter\expandafter{\expandafter#1#2}%
  \xdef#1{\the\toks@}%
  \endgroup}

\long\def\ge@addbefore@macro#1#2{%
  \begingroup
  \toks@\expandafter\expandafter\expandafter{\expandafter#2#1}%
  \xdef#1{\the\toks@}%
  \endgroup}

\long\def\g@addbefore@macro#1#2{%
  \def\@temp{#2}%
  \ge@addbefore@macro{#1}{\@temp}}

\pgfooclass{spath}{

  \attribute path;
  \attribute length;
  \attribute real length;
  \attribute number of components;
  \attribute initial point;
  \attribute final point;
  \attribute reverse path;
  \attribute first action;
  \attribute last action;
  \attribute prepared;
  \attribute taper line width;

% Store the given path
  \method spath(#1) {%
    \let\spath@temp=#1\relax
    \ifx\spath@temp\relax
    \else
     \pgfoolet{path}{#1}%
    \fi
  }

% Generic attribute handling

  \method value(#1) {%
    \pgfoovalueof{#1}%
  }

  \method set(#1,#2) {%
    \pgfooset{#1}{#2}%
  }

  \method let(#1,#2) {%
    \pgfoolet{#1}{#2}%
  }

  \method get(#1,#2) {%
    \pgfooget{#1}{#2}%
  }

  \method show(#1) {%
    \pgfooget{#1}{\@temp}%
    \show\@temp
  }

  \method clone(#1) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
    \else
     \pgfoonew \spath@newpath =new spath()%
     \foreach \attribute in {
      path,
      length,
      real length,
      number of components,
      initial point,
      final point,
      reverse path,
      first action,
      last action,
      prepared,
      taper line width%
     } {
      \pgfooget{\attribute}{\spath@temp}%
      \spath@newpath.let(\attribute,\spath@temp)%
    }
    \let#1=\spath@newpath%
    \fi
  }

% Translate the path by #2 in x and #3 in y, if #1 is given then it
% should be a macro and it will be an object with the translated path,
% otherwise the current object is modified

  \method translate path(#1,#2,#3) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
    \let\spath@tmppath=\pgfutil@empty
    \begingroup
     \spath@trx=#2\relax
     \spath@try=#3\relax
     \spath@translate@init
     \pgfoovalueof{path}%
     \pgfoolet{path}{\spath@tmppath}%
     \let\spath@tmppath=\pgfutil@empty
     \pgfooget{reverse path}{\spath@tmppatha}%
     \ifx\spath@tmppatha\pgfutil@empty
     \else
      \spath@tmppatha
      \pgfoolet{reverse path}{\spath@tmppath}%
     \fi
     \pgfooget{initial point}{\spath@temp}%
     \ifx\spath@temp\pgfutil@empty
     \else
      \spath@temp
      \advance\pgf@x by \spath@trx\relax
      \advance\pgf@y by \spath@try\relax
      \edef\spath@temp{\noexpand\pgfpoint{\the\pgf@x}{\the\pgf@y}}%
      \pgfoolet{initial point}{\spath@temp}%
     \fi
     \pgfooget{final point}{\spath@temp}%
     \ifx\spath@temp\pgfutil@empty
     \else
      \spath@temp
      \advance\pgf@x by \spath@trx\relax
      \advance\pgf@y by \spath@try\relax
      \edef\spath@temp{\noexpand\pgfpoint{\the\pgf@x}{\the\pgf@y}}%
      \pgfoolet{final point}{\spath@temp}%
     \fi
    \endgroup
    \let\spath@tmppath=\pgfutil@empty
   \else
    \pgfoothis.clone(\spath@newpath)%
    \begingroup
    \spath@newpath.translate path(,#2,#3)%
    \endgroup
    \let#1=\spath@newpath
   \fi
  }

% Get the length of the path (number of pieces)

  \method length() {%
    \pgfooget{length}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \setcounter{spath@length}{0}%
    \begingroup
    \spath@length@init
    \pgfoovalueof{path}%
    \endgroup
     \edef\spath@temp{\the\value{spath@length}}%
     \pgfoolet{length}{\spath@temp}%
    \fi
    \spath@temp
  }

% Get the real length of the path (number of components that draw)

  \method real length() {%
    \pgfooget{real length}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \setcounter{spath@length}{0}%
    \begingroup
    \spath@reallength@init
    \pgfoovalueof{path}%
    \endgroup
     \edef\spath@temp{\the\value{spath@length}}%
     \pgfoolet{real length}{\spath@temp}%
    \fi
    \spath@temp
  }

% Get the number of components of the path

  \method number of components() {%
    \pgfooget{number of components}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \setcounter{spath@length}{0}%
    \begingroup
    \spath@components@init
    \pgfoovalueof{path}%
    \endgroup
     \edef\spath@temp{\the\value{spath@length}}%
     \pgfoolet{real length}{\spath@temp}%
    \fi
    \spath@temp
  }

% Get the initial point of the path

  \method initial point() {%
    \pgfooget{initial point}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \begingroup
    \spath@start@init
    \pgfoovalueof{path}%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@sx}{\spath@sy}}%
    \pgfoolet{initial point}{\spath@temp}%
    \endgroup
    \pgfooget{initial point}{\spath@temp}%
    \fi
    \spath@temp
  }

% Get the final point of the path

  \method final point() {%
    \pgfooget{final point}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \begingroup
    \spath@end@init
    \pgfoovalueof{path}%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@ex}{\spath@ey}}%
    \pgfoolet{final point}{\spath@temp}%
    \endgroup
    \pgfooget{final point}{\spath@temp}%
    \fi
    \spath@temp
  }

% Compute the reversed path

  \method compute reverse() {%
    \pgfooget{reverse path}{\spath@tmppath}%
    \ifx\spath@tmppath\pgfutil@empty
     \begingroup
     \spath@reverse@init
     \pgfoovalueof{path}%
     \g@addbefore@macro\spath@tmppath\pgfsyssoftpath@movetotoken
     \endgroup
     \pgfoolet{reverse path}{\spath@tmppath}%
    \fi
    \let\spath@tmppath\pgfutil@empty
  }

% Reverse the path

  \method reverse() {%
    \pgfoothis.prepare()%
    \pgfooget{path}{\spath@tmppath}%
    \pgfooget{reverse path}{\spath@tmppatha}%
    \pgfoolet{reverse path}{\spath@tmppath}%
    \pgfoolet{path}{\spath@tmppatha}%
    \pgfooget{initial point}{\spath@temp}%
    \pgfooget{final point}{\spath@tempa}%
    \pgfoolet{final point}{\spath@temp}%
    \pgfoolet{initial point}{\spath@tempa}%
    \pgfooget{first action}{\spath@temp}%
    \pgfooget{last action}{\spath@tempa}%
    \pgfoolet{last action}{\spath@temp}%
    \pgfoolet{first action}{\spath@tempa}%
  }

% Prepare the path, filling out all the attributes

  \method prepare() {%
    \pgfooget{prepared}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \let\spath@tmppath=\pgfutil@empty
    \begingroup
    \setcounter{spath@reallength}{0}%
    \setcounter{spath@components}{0}%
    \setcounter{spath@length}{0}%
    \spath@prepare@init
    \let\spath@first=\pgfutil@empty
    \pgfoovalueof{path}%
    \g@addbefore@macro\spath@tmppath\pgfsyssoftpath@movetotoken
    \pgfoolet{reverse path}{\spath@tmppath}%
    \edef\spath@temp{\the\value{spath@components}}%
    \pgfoolet{number of components}{\spath@temp}%
    \edef\spath@temp{\the\value{spath@length}}%
    \pgfoolet{length}{\spath@temp}%
    \edef\spath@temp{\the\value{spath@reallength}}%
    \pgfoolet{real length}{\spath@temp}%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@sx}{\spath@sy}}%
    \pgfoolet{initial point}{\spath@temp}%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@ex}{\spath@ey}}%
    \pgfoolet{final point}{\spath@temp}%
    \pgfoolet{first action}{\spath@first}%
    \pgfoolet{last action}{\spath@last}%
    \pgfoolet{prepared}{1}%
    \endgroup
    \fi
  }

% Ensure that the path has at least 3 components

  \method at least three() {%
    \pgfoothis.prepare()%
    \pgfooget{real length}{\spath@temp}%
    \pgfooget{path}{\spath@tmppath}%
    \ifnum\spath@temp=1\relax
     \pgfooget{first action}{\spath@temp}%
     \ifx\spath@temp\spath@lineto
      \expandafter\spath@split@single@lineto\spath@tmppath\relax
      \pgfoolet{path}{\spath@tmppath}%
      \pgfooset{length}{4}%
      \pgfooget{reverse path}{\spath@tmppath}%
      \ifx\spath@tmppath\pgfutil@empty
      \else
       \expandafter\spath@split@single@lineto\spath@tmppath\relax
       \pgfoolet{reverse path}{\spath@tmppath}%
      \fi
     \else
      \expandafter\spath@split@single@curveto\spath@tmppath\relax
      \pgfoolet{path}{\spath@tmppath}%
      \pgfooset{length}{10}%
      \pgfooget{reverse path}{\spath@tmppath}%
      \ifx\spath@tmppath\pgfutil@empty
      \else
       \expandafter\spath@split@single@curveto\spath@tmppath\relax
       \pgfoolet{reverse path}{\spath@tmppath}%
      \fi
     \fi
     \pgfooset{real length}{3}%
    \else
     \ifnum\spath@temp=2\relax
      \pgfooget{first action}{\spath@temp}%
      \def\spath@tempa{0}%
      \ifx\spath@temp\spath@lineto
       \expandafter\spath@split@first@lineto\spath@tmppath\relax
       \def\spath@tempa{3}%
      \else
       \expandafter\spath@split@first@curveto\spath@tmppath\relax
       \def\spath@tempa{7}%
      \fi
      \pgfooget{last action}{\spath@temp}%
      \ifx\spath@temp\spath@lineto
       \expandafter\spath@split@second@lineto\spath@split@path@end\relax
       \pgfmathsetmacro{\spath@tempa}{\spath@tempa + 2}
      \else
       \expandafter\spath@split@second@curveto\spath@split@path@end\relax
       \pgfmathsetmacro{\spath@tempa}{\spath@tempa + 6}
      \fi
      \let\spath@tmppath=\spath@split@path@start
      \ge@addto@macro\spath@tmppath\spath@split@path@end
      \pgfoolet{path}{\spath@tmppath}%
      \pgfoolet{length}{\spath@tempa}%
      \pgfooget{reverse path}{\spath@tmppath}%
      \ifx\spath@tmppath\pgfutil@empty
      \else
       \pgfooget{last action}{\spath@temp}%
       \ifx\spath@temp\spath@lineto
        \expandafter\spath@split@first@lineto\spath@tmppath\relax
       \else
        \expandafter\spath@split@first@curveto\spath@tmppath\relax
       \fi
       \pgfooget{first action}{\spath@temp}%
       \ifx\spath@temp\spath@lineto
        \expandafter\spath@split@second@lineto\spath@split@path@end\relax
       \else
        \expandafter\spath@split@second@curveto\spath@split@path@end\relax
       \fi
       \let\spath@tmppath=\spath@split@path@start
       \ge@addto@macro\spath@tmppath\spath@split@path@end
       \pgfoolet{reverse path}{\spath@tmppath}%
      \fi
      \pgfooset{real length}{4}%
     \fi
    \fi
  }

  \method taper start(#1,#2) {%
    \pgfoothis.prepare()%
    \pgfooget{first action}{\spath@temp}%
    \pgfooget{path}{\spath@tmppath}%
    \pgfooget{taper line width}{\taper@line@width}%
    \ifx\taper@line@width\pgfutil@empty
     \pgfmathsetmacro{\taper@line@width}{.5*\pgflinewidth}%
    \fi
    \ifx\spath@temp\spath@lineto
     \expandafter\spath@taper@lineto@out\spath@tmppath\relax
    \else
     \expandafter\spath@taper@curveto@out\spath@tmppath\relax
    \fi
    \pgfoonew #1 =new spath(\spath@tapered@path)%
    \pgfoonew #2 =new spath(\spath@taper@middle@path)%
  }

  \method taper end(#1,#2) {%
    \pgfoothis.prepare()%
    \pgfooget{last action}{\spath@temp}%
    \pgfooget{reverse path}{\spath@tmppath}%
    \pgfooget{taper line width}{\taper@line@width}%
    \ifx\taper@line@width\pgfutil@empty
     \pgfmathsetmacro{\taper@line@width}{.5*\pgflinewidth}%
    \fi
    \ifx\spath@temp\spath@lineto
     \expandafter\spath@taper@lineto@out\spath@tmppath\relax
    \else
     \expandafter\spath@taper@curveto@out\spath@tmppath\relax
    \fi
    \pgfoonew #1 =new spath(\spath@tapered@path)%
    \pgfoonew #2 =new spath(\spath@taper@middle@path)%
  }

% These could do with splitting everything, not just the path

  \method split path by length(#1,#2,#3) {%
    \pgfoothis.prepare()%
    \def\spath@test{\the\value{spath@length}}%
    \pgfooget{length}{\spath@length}%
    \pgfoothis.split(#1,#2,#3)%
  }

  \method split path by real length(#1,#2,#3) {%
    \pgfoothis.prepare()%
    \def\spath@test{\the\value{spath@reallength}}%
    \pgfooget{real length}{\spath@length}%
    \pgfoothis.split(#1,#2,#3)%
  }

  \method split path by component(#1,#2,#3) {%
    \pgfoothis.prepare()%
    \def\spath@test{\the\value{spath@components}}%
    \pgfooget{number of components}{\spath@length}%
    \pgfoothis.split(#1,#2,#3)%
  }

  \method split(#1,#2,#3) {%
    \pgfmathsetmacro{\spath@splitat}{#3 < 0 ? \spath@length - #3: #3}%
    \pgfooget{path}{\spath@tmppath}%
    \let\spath@tmppatha=\pgfutil@empty
    \setcounter{spath@length}{0}%
    \setcounter{spath@reallength}{0}%
    \setcounter{spath@components}{-1}%
    \expandafter\spath@gobble\spath@tmppath\relax
    \pgfoonew #1 =new spath(\spath@tmppatha)%
    \pgfoonew #2 =new spath(\spath@tmppath)%
    #1.let(last action,\spath@last)%
    #2.let(first action,\spath@first)%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@ex}{\spath@ey}}%
    #1.let(final point,\spath@temp)%
    \edef\spath@temp{\noexpand\pgfpoint{\spath@sx}{\spath@sy}}%
    #2.let(initial point,\spath@temp)%
    \pgfooget{first action}{\spath@temp}%
    #1.let(first action,\spath@temp)%
    \pgfooget{last action}{\spath@temp}%
    #2.let(last action,\spath@temp)%
    \pgfooget{initial point}{\spath@temp}%
    #1.let(initial point,\spath@temp)%
    \pgfooget{final point}{\spath@temp}%
    #2.let(final point,\spath@temp)%
    #1.let(length,\spath@splitat)%
    \edef\spath@temp{\the\value{spath@reallength}}
    #1.let(real length,\spath@temp)%
    \pgfmathsetmacro{\spath@temp}{\pgfoovalueof{real length} - \spath@temp}
    #2.let(real length,\spath@temp)%
    \edef\spath@temp{\the\value{spath@components}}
    #1.let(number of components,\spath@temp)%
    \pgfmathsetmacro{\spath@temp}{\pgfoovalueof{number of components} - \spath@temp}
    #2.let(number of components,\spath@temp)%
    \pgfooget{taper line width}{\spath@temp}%
    #1.let(taper line width,\spath@temp)%
    #2.let(taper line width,\spath@temp)%
    \pgfmathsetmacro{\spath@splitat}{\spath@length - \spath@splitat}%
    #2.let(length,\spath@splitat)%
    \pgfooget{reverse path}{\spath@tmppath}%
    \let\spath@tmppatha=\pgfutil@empty
    \setcounter{spath@length}{-1}%
    \setcounter{spath@reallength}{0}%
    \setcounter{spath@components}{-1}%
    \expandafter\spath@gobble\spath@tmppath\relax
    #1.let(reverse path,\spath@tmppath)%
    #2.let(reverse path,\spath@tmppatha)%
    #1.let(prepared,1)%
    #2.let(prepared,1)%
  }

  \method use path(#1) {%
    \pgfooget{path}{\spath@tmppath}%
    \pgfsyssoftpath@setcurrentpath{\spath@tmppath}%
    \pgfsyssoftpath@flushcurrentpath
    \pgfusepath{#1}%
  }

  \method use reverse path(#1) {%
    \pgfooget{reverse path}{\spath@tmppath}%
    \pgfsyssoftpath@setcurrentpath{\spath@tmppath}%
    \pgfsyssoftpath@flushcurrentpath
    \pgfusepath{#1}%
  }

  \method use path with tikz(#1) {%
    \begingroup
    \let\spath@save@cmd=\tikz@scan@next@command
    \let\tikz@scan@next@command=\relax
    \tikz@@command@path
    \let\tikz@scan@next@command=\spath@save@cmd
    \tikzset{#1}%
    \pgfooget{path}{\spath@tmp}%
    \pgfsyssoftpath@setcurrentpath{\spath@tmp}%
    \tikz@finish
    \endgroup
  }

  \method use reverse path with tikz(#1) {%
    \begingroup
    \let\spath@save@cmd=\tikz@scan@next@command
    \let\tikz@scan@next@command=\relax
    \tikz@@command@path
    \let\tikz@scan@next@command=\spath@save@cmd
    \tikzset{#1}%
    \pgfooget{reverse path}{\spath@tmp}%
    \pgfsyssoftpath@setcurrentpath{\spath@tmp}%
    \tikz@finish
    \endgroup
  }

  \method concatenate(#1,#2) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
     \let\spath@other=#2\relax
     \ifx\spath@other\relax
     \else
      \spath@other.get(path,\spath@tmppath)%
      \pgfooget{path}{\spath@tmppatha}%
      \ge@addto@macro\spath@tmppatha\spath@tmppath
      \pgfoolet{path}{\spath@tmppatha}%
      \spath@other.get(reverse path,\spath@tmppath)%
      \pgfooget{reverse path}{\spath@tmppatha}%
      \ge@addto@macro\spath@tmppath\spath@tmppatha
      \pgfoolet{reverse path}{\spath@tmppath}%
      \spath@other.get(final point,\spath@temp)%
      \pgfoolet{final point}{\spath@temp}%
      \spath@other.get(last action,\spath@temp)%
      \pgfoolet{last action}{\spath@temp}%
      \foreach \attribute in {
        length,
        real length,
        number of components%
      } {
        \spath@other.get(\attribute,\spath@temp)%
        \pgfooget{\attribute}{\spath@tempa}%
        \ifx\spath@temp\pgfutil@empty
        \else
        \ifx\spath@tempa\pgfutil@empty
        \else
         \pgfmathsetmacro{\spath@tempa}{\spath@temp + \spath@tempa}%
         \pgfoolet{\attribute}{\spath@tempa}%
        \fi
        \fi
      }%
    \fi
   \else
    \pgfoothis.clone(\spath@newpath)%
    \begingroup
    \spath@newpath.concatenate(,#2)%
    \endgroup
    \let#1=\spath@newpath
   \fi
  }

% Welding is like concatenation except that the paths are brought
% together and the intervening moveto is removed

  \method weld(#1,#2) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
     \let\spath@other=#2\relax
     \ifx\spath@other\relax
     \else
      \pgfoothis.final point()%
      \pgf@xa=\pgf@x
      \pgf@ya=\pgf@y
      \spath@other.initial point()%
      \advance\pgf@xa by -\pgf@x
      \advance\pgf@ya by -\pgf@y
      \spath@other.translate path(\spath@tempo,\the\pgf@xa,\the\pgf@ya)%
%
      \spath@tempo.get(path,\spath@tmppath)%
      \expandafter\spath@trimfirst\spath@tmppath\relax
      \pgfooget{path}{\spath@tmppatha}%
      \ge@addto@macro\spath@tmppatha\spath@tmppath
      \pgfoolet{path}{\spath@tmppatha}%
%
      \spath@tempo.get(reverse path,\spath@tmppatha)%
      \pgfooget{reverse path}{\spath@tmppath}%
      \ifx\spath@tmppatha\pgfutil@empty
      \else
      \ifx\spath@tmppath\pgfutil@empty
      \else
      \expandafter\spath@trimfirst\spath@tmppath\relax
      \ge@addto@macro\spath@tmppatha\spath@tmppath
      \pgfoolet{reverse path}{\spath@tmppatha}%
      \fi
      \fi
%
      \spath@tempo.get(final point,\spath@temp)%
      \pgfoolet{final point}{\spath@temp}%
      \spath@tempo.get(last action,\spath@temp)%
      \pgfoolet{last action}{\spath@temp}%
      \foreach \attribute in {
        length,
        real length,
        number of components%
      } {
        \spath@tempo.get(\attribute,\spath@temp)%
        \pgfooget{\attribute}{\spath@tempa}%
        \ifx\spath@temp\pgfutil@empty
        \else
         \ifx\spath@tempa\pgfutil@empty
         \else
          \pgfmathsetmacro{\spath@tempa}{\spath@temp + \spath@tempa}%
          \pgfoolet{\attribute}{\spath@tempa}%
         \fi
        \fi
      }%
     \fi
    \else
     \pgfoothis.clone(\spath@newpath)%
     \begingroup
      \spath@newpath.weld(,#2)%
     \endgroup
     \let#1=\spath@newpath
    \fi
  }

  \method weld reverse(#1,#2) {%
    \let\spath@newpath=#1\relax
    \ifx\spath@newpath\relax
     \let\spath@other=#2\relax
     \ifx\spath@other\relax
     \else
      \pgfoothis.final point()%
      \pgf@xa=\pgf@x
      \pgf@ya=\pgf@y
      \spath@other.final point()%
      \advance\pgf@xa by -\pgf@x
      \advance\pgf@ya by -\pgf@y
      \spath@other.translate path(\spath@tempo,\the\pgf@xa,\the\pgf@ya)%
%
      \spath@tempo.get(reverse path,\spath@tmppath)%
      \expandafter\spath@trimfirst\spath@tmppath\relax
      \pgfooget{path}{\spath@tmppatha}%
      \ge@addto@macro\spath@tmppatha\spath@tmppath
      \pgfoolet{path}{\spath@tmppatha}%
%
      \spath@tempo.get(path,\spath@tmppatha)%
      \pgfooget{reverse path}{\spath@tmppath}%
      \ifx\spath@tmppatha\pgfutil@empty
      \else
      \ifx\spath@tmppath\pgfutil@empty
      \else
      \expandafter\spath@trimfirst\spath@tmppath\relax
      \ge@addto@macro\spath@tmppatha\spath@tmppath
      \pgfoolet{reverse path}{\spath@tmppatha}%
      \fi
      \fi
%
      \spath@tempo.get(initial point,\spath@temp)%
      \pgfoolet{final point}{\spath@temp}%
      \spath@tempo.get(first action,\spath@temp)%
      \pgfoolet{last action}{\spath@temp}%
      \foreach \attribute in {
        length,
        real length,
        number of components%
      } {
        \spath@tempo.get(\attribute,\spath@temp)%
        \pgfooget{\attribute}{\spath@tempa}%
        \ifx\spath@temp\pgfutil@empty
        \else
         \ifx\spath@tempa\pgfutil@empty
         \else
          \pgfmathsetmacro{\spath@tempa}{\spath@temp + \spath@tempa}%
          \pgfoolet{\attribute}{\spath@tempa}%
         \fi
        \fi
      }%
     \fi
    \else
     \pgfoothis.clone(\spath@newpath)%
     \begingroup
      \spath@newpath.weld reverse(,#2)%
     \endgroup
     \let#1=\spath@newpath
    \fi
  }

}

\pgfooclass{spath component}{
  \attribute path;
  \attribute next component;
  \attribute previous component;

  \method spath component(#1) {%
    \def\spath@temp{#1}%
    \ifx\spath@temp\pgfutil@empty
    \else
    \pgfoolet{previous component}{#1}%
    \fi
  }

% Generic attribute handling

  \method value(#1) {%
    \pgfoovalueof{#1}%
  }

  \method set(#1,#2) {%
    \pgfooset{#1}{#2}%
  }

  \method let(#1,#2) {%
    \pgfoolet{#1}{#2}%
  }

  \method get(#1,#2) {%
    \pgfooget{#1}{#2}%
  }

  \method show(#1) {%
    \pgfooget{#1}{\@temp}%
    \show\@temp
  }

  \method set path(#1) {%
    \pgfoonew \spath@tempa =new spath(#1)%
    \pgfoolet{path}{\spath@tempa}%
  }

  \method apply to paths(#1,#2) {%
    \pgfooget{path}{\spath@tmppath}%
    \spath@tmppath.#1(#2)%
    \pgfooget{next component}{\spath@temp}%
    \ifx\spath@temp\pgfutil@empty
    \else
     \spath@temp.apply to paths(#1,#2)%
    \fi
  }
}

\def\spathsplit#1#2{%
  \pgfoonew #1 =new spath component({})%
  \let\spath@this@component=#1\relax
  \expandafter\spath@split@#2\relax
}

\def\spath@split@\pgfsyssoftpath@movetotoken#1\relax{%
  \spath@split@@#1\pgfsyssoftpath@movetotoken\relax
}

\def\spath@split@@#1\pgfsyssoftpath@movetotoken#2\relax{%
  \def\spath@tmppath{\pgfsyssoftpath@movetotoken#1}%
  \spath@this@component.set path(\spath@tmppath)%
  \def\spath@tmppath{#2}%
  \ifx\spath@tmppath\pgfutil@empty
  \else
   \pgfoonew \spath@next@component =new spath component(\spath@this@component)%
   \spath@this@component.let(next component,\spath@next@component)%
   \let\spath@this@component=\spath@next@component
   \spath@split@@#2\relax
  \fi
}

% These are all our helper macros

\def\spath@define@translate#1\relax{%
  \expandafter\gdef\csname spath@tr@#1\endcsname##1##2{%
    \pgf@xa=##1\relax
    \pgf@ya=##2\relax
    \advance\pgf@xa by \spath@trx
    \advance\pgf@ya by \spath@try
    \edef\spath@tmp{\expandafter\noexpand\csname pgfsyssoftpath@#1token\endcsname{\the\pgf@xa}{\the\pgf@ya}}
    \ge@addto@macro\spath@tmppath\spath@tmp
  }
}

\def\spath@define@length#1\relax{%
  \expandafter\gdef\csname spath@len@#1\endcsname##1##2{%
    \stepcounter{spath@length}
  }
}

\def\spath@define@components#1\relax{%
  \expandafter\gdef\csname spath@comp@#1\endcsname##1##2{%
  }
}

\def\spath@define@reallength#1\relax{%
  \expandafter\gdef\csname spath@rlen@#1\endcsname##1##2{%
  }
}

\def\spath@define@reverse#1\relax{%
  \expandafter\gdef\csname spath@rev@#1\endcsname##1##2{%
    \edef\spath@tmp{{##1}{##2}\expandafter\noexpand\csname pgfsyssoftpath@#1token\endcsname}
    \ge@addbefore@macro\spath@tmppath\spath@tmp
  }
}

\def\spath@define@start#1\relax{%
  \expandafter\gdef\csname spath@start@#1\endcsname##1##2{%
    \edef\spath@sx{##1}
    \edef\spath@sy{##2}
    \spath@start@reinit
  }
}

\def\spath@define@end#1\relax{%
  \expandafter\gdef\csname spath@end@#1\endcsname##1##2{%
    \edef\spath@ex{##1}
    \edef\spath@ey{##2}
  }
}

\def\spath@define@array#1\relax{%
  \expandafter\gdef\csname spath@array@#1\endcsname##1##2{%
    \edef\spath@tmp{\expandafter\noexpand\csname       pgfsyssoftpath@#1token\endcsname{##1}{##2}}
    \ge@addto@macro\spath@tmppath\spath@tmp
  }
}

\let\spath@translate@init=\pgfutil@empty
\let\spath@length@init=\pgfutil@empty
\let\spath@components@init=\pgfutil@empty
\let\spath@reallength@init=\pgfutil@empty
\let\spath@reverse@init=\pgfutil@empty
\let\spath@start@init=\pgfutil@empty
\let\spath@start@reinit=\pgfutil@empty
\let\spath@end@init=\pgfutil@empty
\let\spath@array@init=\pgfutil@empty
\let\spath@prepare@init=\pgfutil@empty

\def\spath@closepath{closepath}

\foreach \spath@cpt in {
  moveto,
  lineto,
  curvetosupporta,
  curvetosupportb,
  curveto,
  rectcorner,
  rectsize,
  closepath%
} {
  \ifx\spath@cpt\spath@closepath
  \let\spath@cptfull\spath@cpt
  \else
  \edef\spath@cptfull{\spath@cpt token}
  \fi
% Save token names for comparision
\expandafter\xdef\csname spath@\spath@cpt\endcsname{\expandafter\string\csname pgfsyssoftpath@\spath@cptfull\endcsname}

% Translation
\expandafter\spath@define@translate\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cptfull\endcsname=\expandafter\noexpand\csname spath@tr@\spath@cpt \endcsname}

\ge@addto@macro\spath@translate@init\spath@tmp

% Counting total length
\expandafter\spath@define@length\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cptfull\endcsname=\expandafter\noexpand\csname spath@len@\spath@cpt \endcsname}

\ge@addto@macro\spath@length@init\spath@tmp

% Counting components
\expandafter\spath@define@components\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cptfull\endcsname=\expandafter\noexpand\csname spath@comp@\spath@cpt \endcsname}

\ge@addto@macro\spath@components@init\spath@tmp

% Counting real length
\expandafter\spath@define@reallength\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cptfull\endcsname=\expandafter\noexpand\csname spath@rlen@\spath@cpt \endcsname}

\ge@addto@macro\spath@reallength@init\spath@tmp

% Reversal
\expandafter\spath@define@reverse\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cptfull\endcsname=\expandafter\noexpand\csname spath@rev@\spath@cpt \endcsname}

\ge@addto@macro\spath@reverse@init\spath@tmp

% Initial coordinates
\expandafter\spath@define@start\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cptfull\endcsname=\expandafter\noexpand\csname spath@start@\spath@cpt \endcsname}

\ge@addto@macro\spath@start@init\spath@tmp

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cptfull\endcsname=\noexpand\@gobbletwo}

\ge@addto@macro\spath@start@reinit\spath@tmp

% Final coordinates
\expandafter\spath@define@end\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cptfull\endcsname=\expandafter\noexpand\csname spath@end@\spath@cpt \endcsname}

\ge@addto@macro\spath@end@init\spath@tmp

% Split in to array
\expandafter\spath@define@array\spath@cpt\relax

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cptfull\endcsname=\expandafter\noexpand\csname spath@array@\spath@cpt \endcsname}

\ge@addto@macro\spath@array@init\spath@tmp

% Prepare a path: reverse the components, figure out endpoints
% Actions are too complicated to specify a template so just create
% initialisation code

\edef\spath@tmp{\noexpand\let\expandafter\noexpand\csname pgfsyssoftpath@\spath@cptfull\endcsname=\expandafter\noexpand\csname spath@prepare@\spath@cpt \endcsname}

\ge@addto@macro\spath@prepare@init\spath@tmp
}

% Correction for counting components: count movetos
\def\spath@comp@moveto#1#2{%
  \stepcounter{spath@length}%
}

% Correction for counting real length: count linetos and curvetos
\def\spath@rlen@lineto#1#2{%
  \stepcounter{spath@length}%
}
\def\spath@rlen@curveto#1#2{%
  \stepcounter{spath@length}%
}

% Correction for reversing initial moveto
\def\spath@rev@moveto#1#2{
  \ifx\spath@tmppath\pgfutil@empty
  \edef\spath@tmp{{#1}{#2}}%
  \else
  \edef\spath@tmp{{#1}{#2}\noexpand\pgfsyssoftpath@movetotoken}%
  \fi
  \ge@addbefore@macro\spath@tmppath\spath@tmp
}

% Correction for reversing curvetos
\def\spath@rev@curvetosupporta#1#2{%
  \edef\spath@tmp{{#1}{#2}\noexpand\pgfsyssoftpath@curvetotoken}%
  \ge@addbefore@macro\spath@tmppath\spath@tmp
}
\def\spath@rev@curvetosupportb#1#2{%
  \edef\spath@tmp{{#1}{#2}\noexpand\pgfsyssoftpath@curvetosupportbtoken}%
  \ge@addbefore@macro\spath@tmppath\spath@tmp
}
\def\spath@rev@curveto#1#2{%
  \edef\spath@tmp{{#1}{#2}\noexpand\pgfsyssoftpath@curvetosupportatoken}%
  \ge@addbefore@macro\spath@tmppath\spath@tmp
}

% Correction for reversing closepaths
\def\spath@rev@closepath#1#2{%
  \edef\spath@tmp{\noexpand\pgfsyssoftpath@closepath{#1}{#2}}%
  \ge@addto@macro\spath@tmppath\spath@tmp
}

% Correction for splitting in to an array
\def\spath@array@moveto#1#2{%
  \ifx\spath@tmppath\pgfutil@empty
  \else
   \expandafter\global\expandafter\let\csname spath@array@\spath@path@name @\the\value{spath@array}\endcsname=\spath@tmppath
   \def\spath@tmppath{\pgfsyssoftpath@movetotoken{#1}{#2}}%
  \fi
  \stepcounter{spath@array}%
}

\def\spath@prepare@moveto#1#2{%
  \ifx\spath@tmppath\pgfutil@empty
  \g@addbefore@macro\spath@tmppath{{#1}{#2}}%
  \edef\spath@sx{#1}%
  \edef\spath@sy{#2}%
  \else
  \g@addbefore@macro\spath@tmppath{{#1}{#2}\pgfsyssoftpath@movetotoken}%
  \fi
  \edef\spath@ex{#1}%
  \edef\spath@ey{#2}%
  \stepcounter{spath@length}%
  \stepcounter{spath@components}%
  \let\spath@last\spath@moveto
}

\def\spath@prepare@lineto#1#2{%
  \g@addbefore@macro\spath@tmppath{{#1}{#2}\pgfsyssoftpath@linetotoken}%
  \edef\spath@ex{#1}%
  \edef\spath@ey{#2}%
  \stepcounter{spath@length}%
  \stepcounter{spath@reallength}%
  \let\spath@last\spath@lineto
  \ifx\spath@first\pgfutil@empty
  \let\spath@first\spath@lineto
  \fi
}

\def\spath@prepare@curveto#1#2{%
  \g@addbefore@macro\spath@tmppath{{#1}{#2}\pgfsyssoftpath@curvetosupportatoken}%
  \edef\spath@ex{#1}%
  \edef\spath@ey{#2}%
  \stepcounter{spath@length}%
  \stepcounter{spath@reallength}%
  \let\spath@last\spath@curveto
  \ifx\spath@first\pgfutil@empty
  \let\spath@first\spath@curveto
  \fi
}

\def\spath@prepare@curvetosupporta#1#2{%
  \g@addbefore@macro\spath@tmppath{{#1}{#2}\pgfsyssoftpath@curvetotoken}%
  \stepcounter{spath@length}%
}

\def\spath@prepare@curvetosupportb#1#2{%
  \g@addbefore@macro\spath@tmppath{{#1}{#2}\pgfsyssoftpath@curvetosupportbtoken}%
  \stepcounter{spath@length}%
}

% Also need to handle the closepath variants

\def\spath@trimfirst#1#2#3#4\relax{%
  \edef\spath@this@action{\string#1}%
  \ifx\spath@this@action\spath@moveto
   \def\spath@tmppath{#4}%
  \else
   \def\spath@tmppath{#1{#2}{#3}#4}%
  \fi
}

\def\spath@gobble#1#2#3{%
  \stepcounter{spath@length}%
  \edef\spath@this@action{\string#1}%
  \ifx\spath@this@action\spath@lineto
   \stepcounter{spath@reallength}%
  \fi
  \ifx\spath@this@action\spath@curveto
   \stepcounter{spath@reallength}%
  \fi
  \ifx\spath@this@action\spath@moveto
   \stepcounter{spath@components}%
  \fi
  \g@addto@macro\spath@tmppatha{#1{#2}{#3}}%
  \ifnum\spath@test=\spath@splitat\relax
   \def\spath@tmppath{\pgfsyssoftpath@movetotoken{#2}{#3}}%
   \def\spath@last{\string#1}%
   \edef\spath@ex{#2}%
   \edef\spath@ey{#3}%
   \let\spath@next=\spath@lastgobble
  \else
   \let\spath@next=\spath@gobble
  \fi
  \spath@next
}
\def\spath@lastgobble#1#2#3#4\relax{%
  \g@addto@macro\spath@tmppath{#1{#2}{#3}#4}%
   \def\spath@first{\string#1}%
   \edef\spath@sx{#2}%
   \edef\spath@sy{#3}%
}

\def\spath@gobblecpt#1#2#3{%
  \edef\spath@this@action{\string#1}%
  \show\spath@this@action
  \ifx\spath@this@action\spath@lineto
   \stepcounter{spath@length}%
  \fi
  \ifx\spath@this@action\spath@curveto
   \stepcounter{spath@length}%
  \fi
  \g@addto@macro\spath@tmppatha{#1{#2}{#3}}%
  \ifnum\the\value{spath@length}=\spath@splitat\relax
   \def\spath@tmppath{\pgfsyssoftpath@movetotoken{#2}{#3}}%
   \let\spath@next=\spath@lastgobble
  \else
   \let\spath@next=\spath@gobblecpt
  \fi
  \spath@next
}

\newdimen\spath@trx
\newdimen\spath@try
\newcounter{spath@length}
\newcounter{spath@reallength}
\newcounter{spath@components}
\newcounter{spath@array}
%    \end{macrocode}
%
% \begin{macro}{\spath@taper@lineto@out}
%    \begin{macrocode}
\def\spath@taper@lineto@out#1#2#3#4#5#6#7\relax{%
% #1 is \pgfsyssoftpath@movetotoken
% #2 is x-coord of starting point
% #3 is y-coord of starting point
% #4 is \pgfsyssoftpath@linetotoken
% #5 is x-coord of ending point
% #6 is y-coord of ending point
% #7 shouldn't have anything in
  \pgfmathsetmacro{\spath@sx}{.7 * #2 + .3 * #5}
  \pgfmathsetmacro{\spath@sy}{.7 * #3 + .3 * #6}
  \pgfmathsetmacro{\spath@ex}{.3 * #2 + .7 * #5}
  \pgfmathsetmacro{\spath@ey}{.3 * #3 + .7 * #6}
  \edef\spath@tmp{\noexpand\spath@taper@path{#2}{#3}{\spath@sx pt}{\spath@sy pt}{\spath@ex pt}{\spath@ey pt}{#5}{#6}}
  \spath@tmp
  \def\spath@taper@middle@path{\pgfsyssoftpath@movetotoken{#5}{#6}#7}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\spath@taper@curveto@out}
%    \begin{macrocode}
\def\spath@taper@curveto@out\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@curvetosupportatoken#3#4\pgfsyssoftpath@curvetosupportbtoken#5#6\pgfsyssoftpath@curvetotoken#7#8#9\relax{%
  \spath@taper@path{#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}
  \def\spath@taper@middle@path{\pgfsyssoftpath@movetotoken{#7}{#8}#9}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\spath@taper@path}
%    \begin{macrocode}
\def\spath@taper@path#1#2#3#4#5#6#7#8{
% #1 is x-coord of starting point
% #2 is y-coord of starting point
% #3 is x-coord of first control point
% #4 is y-coord of first control point
% #5 is x-coord of second control point
% #6 is y-coord of second control point
% #7 is x-coord of ending point
% #8 is y-coord of ending point
%
  \edef\spath@sx{#1}
  \edef\spath@sy{#2}
  \edef\spath@cx{#3}
  \edef\spath@cy{#4}
  \edef\spath@dx{#5}
  \edef\spath@dy{#6}
  \edef\spath@ex{#7}
  \edef\spath@ey{#8}
  
%    \end{macrocode}
% Orthogonal vector at end
%    \begin{macrocode}
  \pgfmathsetmacro{\spath@ox}{-\spath@ey + \spath@dy}
  \pgfmathsetmacro{\spath@oy}{\spath@ex - \spath@dx}
  
%    \end{macrocode}
% Orthogonal vector at start
%    \begin{macrocode}
  \pgfmathsetmacro{\spath@sox}{\spath@sy - \spath@cy}
  \pgfmathsetmacro{\spath@soy}{-\spath@sx + \spath@cx}
  
%    \end{macrocode}
% Adjust length to half the line width
%    \begin{macrocode}
  \pgfmathsetmacro{\spath@oox}{.5*\spath@ox * \pgflinewidth / veclen(\spath@ox,\spath@oy)}
  \pgfmathsetmacro{\spath@ooy}{.5*\spath@oy * \pgflinewidth / veclen(\spath@ox,\spath@oy)}
  
%    \end{macrocode}
% Adjust length to half the thinner line width
%    \begin{macrocode}
  \pgfmathsetmacro{\spath@soox}{.5*\spath@sox * \taper@line@width / veclen(\spath@sox,\spath@soy)}
  \pgfmathsetmacro{\spath@sooy}{.5*\spath@soy * \taper@line@width / veclen(\spath@sox,\spath@soy)}
%    \end{macrocode}
% Shift the start point, the control points, and the end points
%    \begin{macrocode}
  \pgfmathsetmacro{\spath@sx}{\spath@sx + \spath@soox}
  \pgfmathsetmacro{\spath@sy}{\spath@sy + \spath@sooy}
  \pgfmathsetmacro{\spath@cx}{\spath@cx + \spath@soox}
  \pgfmathsetmacro{\spath@cy}{\spath@cy + \spath@sooy}
  \pgfmathsetmacro{\spath@dx}{\spath@dx + \spath@oox}
  \pgfmathsetmacro{\spath@dy}{\spath@dy + \spath@ooy}
  \pgfmathsetmacro{\spath@ex}{\spath@ex + \spath@oox}
  \pgfmathsetmacro{\spath@ey}{\spath@ey + \spath@ooy}
%    \end{macrocode}
% Add the first pieces
%    \begin{macrocode}
  \let\spath@tapered@path=\pgfutil@empty
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@movetotoken{\spath@sx pt}{\spath@sy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx pt}{\spath@cy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetotoken{\spath@ex pt}{\spath@ey pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
%    \end{macrocode}
% Make the end roughly round
%    \begin{macrocode}
  \pgfmathsetmacro{\spath@fx}{\spath@ex + 1.32*\spath@ooy}
  \pgfmathsetmacro{\spath@fy}{\spath@ey - 1.32*\spath@oox}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@fx pt}{\spath@fy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
%    \end{macrocode}
% Shift the end points and the control points again
%    \begin{macrocode}
  \pgfmathsetmacro{\spath@fx}{\spath@fx - 2*\spath@oox}
  \pgfmathsetmacro{\spath@fy}{\spath@fy - 2*\spath@ooy}
  \pgfmathsetmacro{\spath@dx}{\spath@dx - 2*\spath@oox}
  \pgfmathsetmacro{\spath@dy}{\spath@dy - 2*\spath@ooy}
  \pgfmathsetmacro{\spath@ex}{\spath@ex - 2*\spath@oox}
  \pgfmathsetmacro{\spath@ey}{\spath@ey - 2*\spath@ooy}
  \pgfmathsetmacro{\spath@cx}{\spath@cx - 2*\spath@soox}
  \pgfmathsetmacro{\spath@cy}{\spath@cy - 2*\spath@sooy}
  \pgfmathsetmacro{\spath@sx}{\spath@sx - 2*\spath@soox}
  \pgfmathsetmacro{\spath@sy}{\spath@sy - 2*\spath@sooy}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@fx pt}{\spath@fy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetotoken{\spath@ex pt}{\spath@ey pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@dx pt}{\spath@dy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@cx pt}{\spath@cy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetotoken{\spath@sx pt}{\spath@sy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
%    \end{macrocode}
% Make the end roughly round
%    \begin{macrocode}
  \pgfmathsetmacro{\spath@fx}{\spath@sx - 1.32*\spath@sooy}
  \pgfmathsetmacro{\spath@fy}{\spath@sy + 1.32*\spath@soox}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@fx pt}{\spath@fy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \pgfmathsetmacro{\spath@fx}{\spath@fx + 2*\spath@soox}
  \pgfmathsetmacro{\spath@fy}{\spath@fy + 2*\spath@sooy}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@fx pt}{\spath@fy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
  \pgfmathsetmacro{\spath@sx}{\spath@sx + 2*\spath@soox}
  \pgfmathsetmacro{\spath@sy}{\spath@sy + 2*\spath@sooy}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetotoken{\spath@sx pt}{\spath@sy pt}}
  \ge@addto@macro\spath@tapered@path\spath@to@add
%    \end{macrocode}
% Close the path, ought to make it rounded
%    \begin{macrocode}
%  \g@addto@macro{\spath@tapered@path}{\pgfsyssoftpath@closepath}
}
%    \end{macrocode}
% \end{macro}
%
% The following have been modified to fit the new routines
%
% \begin{macro}{\spath@single@split}
%    \begin{macrocode}
\def\spath@single@split{.3}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath@split@single@lineto}
%    \begin{macrocode}
\def\spath@split@single@lineto\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@linetotoken#3#4#5\relax{%
  \pgfmathsetmacro{\spath@sx}{(1-\spath@single@split)*#1 + \spath@single@split * #3}
  \pgfmathsetmacro{\spath@sy}{(1-\spath@single@split)*#2 + \spath@single@split * #4}
  \pgfmathsetmacro{\spath@ex}{(1-\spath@single@split)*#3 + \spath@single@split * #1}
  \pgfmathsetmacro{\spath@ey}{(1-\spath@single@split)*#4 + \spath@single@split * #2}
  \edef\spath@tmppath{\noexpand\pgfsyssoftpath@movetotoken{#1}{#2}\noexpand\pgfsyssoftpath@linetotoken{\spath@sx     pt}{\spath@sy pt}\noexpand\pgfsyssoftpath@linetotoken{\spath@ex pt}{\spath@ey pt}\noexpand\pgfsyssoftpath@linetotoken{#3}{#4}}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\spath@split@single@curveto}
%    \begin{macrocode}
\def\spath@split@single@curveto\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@curvetosupportatoken#3#4\pgfsyssoftpath@curvetosupportbtoken#5#6\pgfsyssoftpath@curvetotoken#7#8#9\relax{%
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@single@split)*#1 + \spath@single@split * #3}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@single@split)*#2 + \spath@single@split * #4}
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@single@split)^2 * #1 + 2*\spath@single@split * (1 - \spath@single@split) * #3 + \spath@single@split^2 * #5}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@single@split)^2 * #2 + 2*\spath@single@split * (1 - \spath@single@split) * #4 + \spath@single@split^2 * #6}
  \pgfmathsetmacro{\spath@ex}{(1 - \spath@single@split)^3 * #1 + 3*\spath@single@split * (1 - \spath@single@split)^2 * #3 + 3*\spath@single@split^2 * (1 - \spath@single@split) * #5 + \spath@single@split^3 * #7}
  \pgfmathsetmacro{\spath@ey}{(1 - \spath@single@split)^3 * #2 + 3*\spath@single@split * (1 - \spath@single@split)^2 * #4 + 3*\spath@single@split^2 * (1 - \spath@single@split) * #6 + \spath@single@split^3 * #8}
  \edef\spath@tmppath{\noexpand\pgfsyssoftpath@movetotoken{#1}{#2}\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{\spath@ex pt}{\spath@ey pt}}
%    \end{macrocode}
% Should be some sort of optimisation to do here
%    \begin{macrocode}
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@single@split)^2*\spath@single@split * #1 + (1 - 3 * \spath@single@split + 5 * \spath@single@split^2 - 3 * \spath@single@split^3) * #3 + (2 * \spath@single@split - 4 * \spath@single@split^2 + 3 * \spath@single@split^3) * #5 + \spath@single@split^2 * (1 - \spath@single@split) * #7}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@single@split)^2*\spath@single@split * #2 + (1 - 3 * \spath@single@split + 5 * \spath@single@split^2 - 3 * \spath@single@split^3) * #4 + (2 * \spath@single@split - 4 * \spath@single@split^2 + 3 * \spath@single@split^3) * #6 + \spath@single@split^2 * (1 - \spath@single@split) * #8}
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@single@split)^2*\spath@single@split * #7 + (1 - 3 * \spath@single@split + 5 * \spath@single@split^2 - 3 * \spath@single@split^3) * #5 + (2 * \spath@single@split - 4 * \spath@single@split^2 + 3 * \spath@single@split^3) * #3 + \spath@single@split^2 * (1 - \spath@single@split) * #1}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@single@split)^2*\spath@single@split * #8 + (1 - 3 * \spath@single@split + 5 * \spath@single@split^2 - 3 * \spath@single@split^3) * #6 + (2 * \spath@single@split - 4 * \spath@single@split^2 + 3 * \spath@single@split^3) * #4 + \spath@single@split^2 * (1 - \spath@single@split) * #2}
  \pgfmathsetmacro{\spath@ex}{\spath@single@split^3 * #1 + 3 * \spath@single@split^2 * (1 - \spath@single@split) * #3 + 3 * \spath@single@split * (1 - \spath@single@split)^2 * #5 + (1 - \spath@single@split)^3 * #7}
  \pgfmathsetmacro{\spath@ey}{\spath@single@split^3 * #2 + 3 * \spath@single@split^2 * (1 - \spath@single@split) * #4 + 3 * \spath@single@split * (1 - \spath@single@split)^2 * #6 + (1 - \spath@single@split)^3 * #8}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{\spath@ex pt}{\spath@ey pt}}
  \ge@addto@macro\spath@tmppath\spath@to@add
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@single@split)*#7 + \spath@single@split * #5}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@single@split)*#8 + \spath@single@split * #6}
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@single@split)^2 * #7 + 2*\spath@single@split * (1 - \spath@single@split) * #5 + \spath@single@split^2 * #3}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@single@split)^2 * #8 + 2*\spath@single@split * (1 - \spath@single@split) * #6 + \spath@single@split^2 * #4}
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{#7}{#8}}
  \ge@addto@macro\spath@tmppath\spath@to@add
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\spath@double@split}
%    \begin{macrocode}
\def\spath@double@split{.5}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\spath@split@first@lineto}
%    \begin{macrocode}
\def\spath@split@first@lineto\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@linetotoken#3#4#5\relax{%
  \pgfmathsetmacro{\spath@sx}{(1-\spath@single@split)*#1 + \spath@single@split * #3}
  \pgfmathsetmacro{\spath@sy}{(1-\spath@single@split)*#2 + \spath@single@split * #4}
  \edef\spath@split@path@start{\noexpand\pgfsyssoftpath@movetotoken{#1}{#2}\noexpand\pgfsyssoftpath@linetotoken{\spath@sx     pt}{\spath@sy pt}\noexpand\pgfsyssoftpath@linetotoken{#3}{#4}}
  \edef\spath@split@path@end{\noexpand\pgfsyssoftpath@movetotoken{#3}{#4}}
  \g@addto@macro\spath@split@path@end{#5}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\spath@split@second@lineto}
%    \begin{macrocode}
\def\spath@split@second@lineto\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@linetotoken#3#4#5\relax{%
  \pgfmathsetmacro{\spath@sx}{(1-\spath@single@split)*#3 + \spath@single@split * #1}
  \pgfmathsetmacro{\spath@sy}{(1-\spath@single@split)*#4 + \spath@single@split * #2}
  \edef\spath@split@path@end{\noexpand\pgfsyssoftpath@linetotoken{\spath@sx pt}{\spath@sy pt}\noexpand\pgfsyssoftpath@linetotoken{#3}{#4}}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\spath@split@first@curveto}
%    \begin{macrocode}
\def\spath@split@first@curveto\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@curvetosupportatoken#3#4\pgfsyssoftpath@curvetosupportbtoken#5#6\pgfsyssoftpath@curvetotoken#7#8#9\relax{%
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@double@split)*#1 + \spath@double@split * #3}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@double@split)*#2 + \spath@double@split * #4}
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@double@split)^2 * #1 + 2*\spath@double@split * (1 - \spath@double@split) * #3 + \spath@double@split^2 * #5}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@double@split)^2 * #2 + 2*\spath@double@split * (1 - \spath@double@split) * #4 + \spath@double@split^2 * #6}
  \pgfmathsetmacro{\spath@ex}{(1 - \spath@double@split)^3 * #1 + 3*\spath@double@split * (1 - \spath@double@split)^2 * #3 + 3*\spath@double@split^2 * (1 - \spath@double@split) * #5 + \spath@double@split^3 * #7}
  \pgfmathsetmacro{\spath@ey}{(1 - \spath@double@split)^3 * #2 + 3*\spath@double@split * (1 - \spath@double@split)^2 * #4 + 3*\spath@double@split^2 * (1 - \spath@double@split) * #6 + \spath@double@split^3 * #8}
  \edef\spath@split@path@start{\noexpand\pgfsyssoftpath@movetotoken{#1}{#2}\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{\spath@ex pt}{\spath@ey pt}}
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@double@split)*#5 + \spath@double@split * #7}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@double@split)*#6 + \spath@double@split * #8}
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@double@split)^2 * #3 + 2*\spath@double@split * (1 - \spath@double@split) * #5 + \spath@double@split^2 * #7}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@double@split)^2 * #4 + 2*\spath@double@split * (1 - \spath@double@split) * #6 + \spath@double@split^2 * #8}
  
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{#7}{#8}}
  \ge@addto@macro\spath@split@path@start\spath@to@add
  \edef\spath@split@path@end{\noexpand\pgfsyssoftpath@movetotoken{#7}{#8}}
  \g@addto@macro\spath@split@path@end{#9}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\spath@split@second@curveto}
%    \begin{macrocode}
\def\spath@split@second@curveto\pgfsyssoftpath@movetotoken#1#2\pgfsyssoftpath@curvetosupportatoken#3#4\pgfsyssoftpath@curvetosupportbtoken#5#6\pgfsyssoftpath@curvetotoken#7#8#9\relax{%
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@double@split)*#1 + \spath@double@split * #3}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@double@split)*#2 + \spath@double@split * #4}
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@double@split)^2 * #1 + 2*\spath@double@split * (1 - \spath@double@split) * #3 + \spath@double@split^2 * #5}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@double@split)^2 * #2 + 2*\spath@double@split * (1 - \spath@double@split) * #4 + \spath@double@split^2 * #6}
  \pgfmathsetmacro{\spath@ex}{(1 - \spath@double@split)^3 * #1 + 3*\spath@double@split * (1 - \spath@double@split)^2 * #3 + 3*\spath@double@split^2 * (1 - \spath@double@split) * #5 + \spath@double@split^3 * #7}
  \pgfmathsetmacro{\spath@ey}{(1 - \spath@double@split)^3 * #2 + 3*\spath@double@split * (1 - \spath@double@split)^2 * #4 + 3*\spath@double@split^2 * (1 - \spath@double@split) * #6 + \spath@double@split^3 * #8}
  \edef\spath@split@path@end{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{\spath@ex pt}{\spath@ey pt}}
  \pgfmathsetmacro{\spath@dx}{(1 - \spath@double@split)*#5 + \spath@double@split * #7}
  \pgfmathsetmacro{\spath@dy}{(1 - \spath@double@split)*#6 + \spath@double@split * #8}
  \pgfmathsetmacro{\spath@cx}{(1 - \spath@double@split)^2 * #3 + 2*\spath@double@split * (1 - \spath@double@split) * #5 + \spath@double@split^2 * #7}
  \pgfmathsetmacro{\spath@cy}{(1 - \spath@double@split)^2 * #4 + 2*\spath@double@split * (1 - \spath@double@split) * #6 + \spath@double@split^2 * #8}
  
  \edef\spath@to@add{\noexpand\pgfsyssoftpath@curvetosupportatoken{\spath@cx     pt}{\spath@cy pt}\noexpand\pgfsyssoftpath@curvetosupportbtoken{\spath@dx pt}{\spath@dy pt}\noexpand\pgfsyssoftpath@curvetotoken{#7}{#8}}
  \ge@addto@macro\spath@split@path@end\spath@to@add
}
%    \end{macrocode}
% \end{macro}
% \iffalse
%</package>
% \fi
%
% \Finale

\endinput
