% \iffalse meta-comment
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
spath3 --- LaTeX3 functions for manipulating PGF soft paths
E-mail: stacey@math.ntnu.no
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package defines some functions used to manipulate PGFs soft paths.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
spath3 --- Functions for manipulating PGF soft paths
E-mail: stacey@math.ntnu.no
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2011 by Andrew Stacey <stacey@math.ntnu.no>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Andrew Stacey.

This work consists of the file  spath3.dtx
and the derived files           spath3.ins,
                                spath3.pdf, and
                                spath3.sty.

\endpostamble
\usedir{tex/latex/spath3}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{spath3}}
}
\generate{
  \file{tikzlibrarycalligraphy.code.tex}{\from{\jobname.dtx}{calligraphy}}
}
\generate{
  \file{tikzlibraryknots.code.tex}{\from{\jobname.dtx}{knots}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/spath3}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/demopkg}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
\documentclass[full]{l3doc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
%\usepackage{morefloats}
\usepackage{tikz}
\usepackage{trace}
\usepackage{spath3}
%\traceoff
%\usepackage[numbered]{hypdoc}
\definecolor{lstbgcolor}{rgb}{0.9,0.9,0.9} 
 
\usepackage{listings}
\lstloadlanguages{[LaTeX]TeX}
\lstset{breakatwhitespace=true,breaklines=true,language=TeX}
 
\usepackage{fancyvrb}

\newenvironment{example}
  {\VerbatimEnvironment
   \begin{VerbatimOut}[gobble=2]{example.out}}
  {\end{VerbatimOut}
   \begin{center}
%   \setlength{\parindent}{0pt}
   \fbox{\begin{minipage}{.9\linewidth}
     \lstset{breakatwhitespace=true,breaklines=true,language=TeX,basicstyle=\small}
     \lstinputlisting[]{example.out}
   \end{minipage}}

   \fbox{\begin{minipage}{.9\linewidth}
     \input{example.out}
   \end{minipage}}
\end{center}
}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{1.0}{2011/05/03}{Converted to DTX file}
%
% \DoNotIndex{\newcommand,\newenvironment}
%
% \providecommand*{\url}{\texttt}
% \GetFileInfo{spath3.sty}
% \title{The \textsf{spath3} package}
% \author{Andrew Stacey \\ \url{stacey@math.ntnu.no}}
% \date{\fileversion~from \filedate}
%
%
% \maketitle
%
% 
% \section{Introduction}
%
% The \Verb+spath3+ package is intended as a library for manipulating PGF's \emph{soft paths}.
% In between defining a path and using it, PGF stores a path as a \emph{soft path} were all the defining structure has been resolved into the basic operations but these have not yet been written to the output file.
% They can therefore still be manipulated by \TeX, and as they have a very rigid form (and limited vocabulary), they are relatively easy to modify.
% This package provides some methods for working with these paths.
% It is not really intended for use by end users but as a foundation on which other packages can be built.
% As an example, the \Verb+calligraphy+ package is included which simulates a calligraphic pen stroking a path.
%
% The format of a soft path is a sequence of triples of the form \Verb+\macro {dimension}{dimension}+.
% The macro is one of a short list, the dimensions are coordinates in points.
% There are certain further restrictions, particularly that every path must begin with a \Verb+move to+, and B\'ezier curves consist of three triples.
%
% \StopEventually{}
%
% \section{Implementation}
%
% \iffalse
%<*spath3>
% \fi
% \subsection{Initialisation}
%
% Load the \LaTeX3 foundation and register us as a \LaTeX3\ package.
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{expl3}
\RequirePackage{pgf}
\ProvidesExplPackage {spath3} {2013/04/09} {1.0} {Functions for manipulating PGF soft paths}
\RequirePackage{xparse}
%    \end{macrocode}
%
% We need a slew of temporary variables.
%    \begin{macrocode}
\tl_new:N \l__spath_tmpa_tl
\tl_new:N \l__spath_tmpb_tl
\tl_new:N \l__spath_tmpc_tl
\dim_new:N \l__spath_tmpa_dim
\dim_new:N \l__spath_tmpb_dim
\int_new:N \l__spath_tmpa_int
%    \end{macrocode}
%
% We need to be able to compare against the macros that can occur in  a soft path so these token lists contain them.
%    \begin{macrocode}
\tl_new:N \g__spath_moveto_tl
\tl_new:N \g__spath_lineto_tl
\tl_new:N \g__spath_curveto_tl
\tl_new:N \g__spath_curvetoa_tl
\tl_new:N \g__spath_curvetob_tl
\tl_set:Nn \g__spath_moveto_tl {\pgfsyssoftpath@movetotoken}
\tl_set:Nn \g__spath_lineto_tl {\pgfsyssoftpath@linetotoken}
\tl_set:Nn \g__spath_curveto_tl {\pgfsyssoftpath@curvetotoken}
\tl_set:Nn \g__spath_curvetoa_tl {\pgfsyssoftpath@curvetosupportatoken}
\tl_set:Nn \g__spath_curvetob_tl {\pgfsyssoftpath@curvetosupportbtoken}
%    \end{macrocode}
%
% \subsection{Basic Structure and Methods}
%
% A soft path is a \Verb+prop+.
% These are lists of the attributes that we define.
% The first consists of all attributes, the second of those that are ``moveable'' in the sense that they change if we transform the path, the third are the ones that contain actual paths.
%
% Note that if using these attributes outside an \Verb+expl3+ context, the spaces should be omitted.
%    \begin{macrocode}
\tl_new:N \g__spath_attributes
\tl_new:N \g__spath_moveable_attributes
\tl_new:N \g__spath_path_attributes
\tl_set:Nn \g__spath_attributes {
  {path}
  {reverse path}
  {length}
  {real length}
  {number of components}
  {initial point}
  {final point}
  {initial action}
  {final action}
  {min bb}
  {max bb}
}
\tl_set:Nn \g__spath_moveable_attributes {
  {initial point}
  {final point}
  {min bb}
  {max bb}
}
\tl_set:Nn \g__spath_path_attributes {
  {path}
  {reverse path}
}
%    \end{macrocode}
%
% An \Verb+spath+ object is actually a \Verb+prop+.
% The following functions are wrappers around the underlying \Verb+prop+ functions.
% We prefix the names to avoid clashing with other \Verb+prop+s that might be lying around, this is why all the \Verb+spath+ methods take argument \Verb+:n+ and not \Verb+:N+.
% Given that \Verb+spath+ objects might be created inside a group but used outside it, we work globally throughout.
% \begin{macro}{\spath_new:n}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_new:n #1
{
  \prop_new:c {l__spath_#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_clear:n}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_clear:n #1
{
  \prop_gclear:c {l__spath_#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_clear_new:n}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_clear_new:n #1
{
  \prop_gclear_new:c {l__spath_#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_show:n}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_show:n #1
{
  \prop_show:c {l__spath_#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_put:nnn}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_put:nnn #1#2#3
{
  \prop_gput:cnn {l__spath_#1} {#2} {#3}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_remove:nn}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_remove:nn #1#2
{
  \prop_gremove:cn {l__spath_#1} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\__spath_get:nn}
% This function is an internal one since the real \Verb+get+ function will generate its data if it does not already exist.
%    \begin{macrocode}
\cs_new_nopar:Npn \__spath_get:nn #1#2
{
  \prop_get:cn {l__spath_#1} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\__spath_get:nnN}
%    \begin{macrocode}
\cs_new_nopar:Npn \__spath_get:nnN #1#2#3
{
  \prop_get:cnN {l__spath_#1} {#2} #3
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_if_in:nn}
%    \begin{macrocode}
\prg_new_conditional:Npnn \spath_if_in:nn #1#2 {p, T, F, TF}
{
  \prop_if_in:cnTF {l__spath_#1} {#2}
  { \prg_return_true: }
  { \prg_return_false: }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_spath_get:nnN}
%    \begin{macrocode}
\cs_generate_variant:Nn \__prop_split:NnTF {cnTF}
\prg_new_protected_conditional:Npnn \__spath_get:nnN #1#2#3 {T, F, TF}
{
  \__prop_split:cnTF {l__spath_#1} {#2}
  { \__prop_get_true:Nnnn #3 }
  { \prg_return_false: }
}
\cs_generate_variant:Nn \spath_put:nnn {nnV, nnx, nno}
\cs_generate_variant:Nn \__spath_get:nn {Vn}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_if_exist:n}
%    \begin{macrocode}
\prg_new_conditional:Npnn \spath_if_exist:n #1 {p,T,F,TF}
{
  \prop_if_exist:cTF {l__spath_#1}
  {
    \prg_return_true:
  }
  {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_clone:nn}
% Clones an \Verb+spath+.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_clone:nn #1 #2
{
  \spath_clear_new:n {#2}
  \tl_map_inline:Nn \g__spath_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \__spath_get:nnN {#1} {##1} \l__spath_tmpa_tl
      \spath_put:nnV {#2} {##1} \l__spath_tmpa_tl
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Computing Information}
%
% \begin{macro}{\spath_get:nn}
% The information that we store along with a soft path can be computed from it, but computing it every time is wasteful.
% So this is the real \Verb+\spath_get:nn+ function which checks to see if we have already computed it and then either retrieves it or computes it. 
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_get:nn #1#2
{
  \spath_if_in:nnF {#1} {#2}
  {
    \cs_if_exist_use:cT {spath_generate_#2:n} {{#1}}
  }
  \__spath_get:nn {#1} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_get:nnN}
% As above but leaves the result in a token list rather than in the stream.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_get:nnN #1#2#3
{
  \spath_if_in:nnF {#1} {#2}
  {
    \cs_if_exist_use:cT {spath_generate_#2:n} {{#1}}
  }
  \__spath_get:nnN {#1} {#2} #3
}
\cs_generate_variant:Nn \spath_get:nnN {nnV}
%    \end{macrocode}
% \end{macro}
%
% The next slew of functions generate data from the original path, storing it in the \Verb+prop+ for further retrieval.
% \begin{macro}{\spath_generate_length:n}
% Counts the number of triples in the path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_length:n #1
{
  \__spath_get:nnN {#1} {path} \l__spath_tmpa_tl
  \spath_put:nnx {#1} {length} {\int_eval:n {\tl_count:N \l__spath_tmpa_tl /3 }}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_generate_reallength:n}
% The real length of a path is the number of triples that actually draw something (that is, the number of lines and curves).
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_reallength:n #1
{
  \__spath_get:nnN {#1} {path} \l__spath_tmpa_tl
  \int_set:Nn \l__spath_tmpa_int {0}
  \tl_map_inline:Nn \l__spath_tmpa_tl {
    \tl_if_eq:nnT {##1} {\pgfsyssoftpath@linetotoken}
    {
      \int_incr:N \l__spath_tmpa_int
    }
    \tl_if_eq:nnT {##1} {\pgfsyssoftpath@curvetotoken}
    {
      \int_incr:N \l__spath_tmpa_int
    }
  }
  \spath_put:nnx {#1} {real length} {\int_use:N \l__spath_tmpa_int}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_generate_numberofcomponents:n}
% A component is a continuous segment of the path, separated by moves.
% Successive moves are not collapsed, and zero length moves count.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_numberofcomponents:n #1
{
  \__spath_get:nnN {#1} {path} \l__spath_tmpa_tl
  \int_set:Nn \l__spath_tmpa_int {0}
  \tl_map_inline:Nn \l__spath_tmpa_tl {
    \tl_if_eq:nnT {##1} {\pgfsyssoftpath@movetotoken}
    {
      \int_incr:N \l__spath_tmpa_int
    }
  }
  \spath_put:nnx {#1} {number of components} {\int_use:N \l__spath_tmpa_int}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_generate_initialpoint:n}
% The starting point of the path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_initialpoint:n #1
{
  \__spath_get:nnN {#1} {path} \l__spath_tmpa_tl
  \tl_clear:N \l__spath_tmpb_tl
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \tl_put_right:Nx \l__spath_tmpb_tl {{\tl_head:N \l__spath_tmpa_tl}}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \tl_put_right:Nx \l__spath_tmpb_tl {{\tl_head:N \l__spath_tmpa_tl}}
  \spath_put:nnV {#1} {initial point} \l__spath_tmpb_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_generate_finalpoint:n}
% The final point of the path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_finalpoint:n #1
{
  \tl_clear:N \l__spath_tmpb_tl
  \spath_if_in:nnTF {#1} {reverse path}
  {
    \__spath_get:nnN {#1} {reverse path} \l__spath_tmpa_tl
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
    \tl_put_right:Nx \l__spath_tmpb_tl {{\tl_head:N \l__spath_tmpa_tl}}
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
    \tl_put_right:Nx \l__spath_tmpb_tl {{\tl_head:N \l__spath_tmpa_tl}}
  }
  {
    \__spath_get:nnN {#1} {path} \l__spath_tmpa_tl
    \tl_reverse:N \l__spath_tmpa_tl
    \tl_put_left:Nx \l__spath_tmpb_tl {{\tl_head:N \l__spath_tmpa_tl}}
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
    \tl_put_left:Nx \l__spath_tmpb_tl {{\tl_head:N \l__spath_tmpa_tl}}
  }
  \spath_put:nnV {#1} {final point} \l__spath_tmpb_tl    
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_generate_reversepath:n}
% This computes the reverse of the path.
% TODO: handle closed paths, possibly rectangles.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_reversepath:n #1
{
  \__spath_get:nnN {#1} {path} \l__spath_tmpa_tl
  \tl_clear:N \l__spath_tmpb_tl
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \tl_put_left:Nx \l__spath_tmpb_tl
  {
    {\dim_use:N \l__spath_tmpa_dim}
    {\dim_use:N \l__spath_tmpb_dim}
  }
  \bool_until_do:nn {
    \tl_if_empty_p:N \l__spath_tmpa_tl
  }
  {
    \tl_set:Nx \l__spath_tmpc_tl {\tl_head:N \l__spath_tmpa_tl}
    \tl_set:Nn \l__spath_tmpd_tl {}
    \tl_case:Nnn \l__spath_tmpc_tl
    {
      \g__spath_moveto_tl {\tl_set_eq:NN \l__spath_tmpd_tl \g__spath_moveto_tl }
      \g__spath_lineto_tl {\tl_set_eq:NN \l__spath_tmpd_tl \g__spath_lineto_tl }
      \g__spath_curveto_tl {\tl_set_eq:NN \l__spath_tmpd_tl \g__spath_curvetoa_tl }
      \g__spath_curvetoa_tl {\tl_set_eq:NN \l__spath_tmpd_tl \g__spath_curveto_tl }
      \g__spath_curvetob_tl {\tl_set_eq:NN \l__spath_tmpd_tl \g__spath_curvetob_tl }
    }
    {
      \tl_show:N \l__spath_tmpc_tl
    }
    \tl_put_left:NV \l__spath_tmpb_tl \l__spath_tmpd_tl
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
    \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl}
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
    \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl}
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
    \tl_put_left:Nx \l__spath_tmpb_tl
    {
      {\dim_use:N \l__spath_tmpa_dim}
      {\dim_use:N \l__spath_tmpb_dim}
    }
  }
  \tl_put_left:NV \l__spath_tmpb_tl \g__spath_moveto_tl
  \spath_put:nnV {#1} {reverse path} \l__spath_tmpb_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_generate_initialaction:n}
% This is the first thing that the path does (after the initial move).
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_initialaction:n #1
{
  \__spath_get:nnN {#1} {path} \l__spath_tmpa_tl
  \tl_clear:N \l__spath_tmpb_tl
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \tl_if_empty:NF \l__spath_tmpa_tl {
    \tl_set:Nx \l__spath_tmpb_tl {\tl_head:N \l__spath_tmpa_tl}
  }
  \spath_put:nnV {#1} {initial action} \l__spath_tmpb_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_generate_final action:n}
% This is the last thing that the path does.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_finalaction:n #1
{
  \tl_clear:N \l__spath_tmpb_tl
  \spath_if_in:nnTF {#1} {reverse path}
  {
    \__spath_get:nnN {#1} {reverse path} \l__spath_tmpa_tl
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  }
  {
    \__spath_get:nnN {#1} {path} \l__spath_tmpa_tl
    \tl_reverse:N \l__spath_tmpa_tl
  }
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \tl_if_empty:NF \l__spath_tmpa_tl {
    \tl_set:Nx \l__spath_tmpb_tl {\tl_head:N \l__spath_tmpa_tl}
  }
  \tl_if_eq:NNT \l__spath_tmpa_tl \g__spath_curvetoa_tl
  {
    \tl_set_eq:NN \l__spath_tmpa_tl \g__spath_curveto_tl
  }
  \spath_put:nnV {#1} {final action} \l__spath_tmpb_tl    
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_generate_minbb:n}
% This computes the minimum (bottom left) of the bounding box of the path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_minbb:n #1
{
  \__spath_get:nnN {#1} {path} \l__spath_tmpa_tl
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \bool_until_do:nn {
    \tl_if_empty_p:N \l__spath_tmpa_tl
  }
  {
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
    \dim_set:Nn \l__spath_tmpa_dim {\dim_min:nn {\tl_head:N \l__spath_tmpa_tl} {\l__spath_tmpa_dim}}
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
    \dim_set:Nn \l__spath_tmpb_dim {\dim_min:nn {\tl_head:N \l__spath_tmpa_tl} {\l__spath_tmpb_dim}}
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  }
  \tl_clear:N \l__spath_tmpb_tl
  \tl_put_right:Nx \l__spath_tmpb_tl
  {
    {\dim_use:N \l__spath_tmpa_dim}
    {\dim_use:N \l__spath_tmpb_dim}
  }
  \spath_put:nnV {#1} {min bb} \l__spath_tmpb_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_generate_max bb:n}
% This computes the maximum (top right) of the bounding box of the path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_maxbb:n #1
{
  \__spath_get:nnN {#1} {path} \l__spath_tmpa_tl
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \bool_until_do:nn {
    \tl_if_empty_p:N \l__spath_tmpa_tl
  }
  {
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
    \dim_set:Nn \l__spath_tmpa_dim {\dim_max:nn {\tl_head:N \l__spath_tmpa_tl} {\l__spath_tmpa_dim}}
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
    \dim_set:Nn \l__spath_tmpb_dim {\dim_max:nn {\tl_head:N \l__spath_tmpa_tl} {\l__spath_tmpb_dim}}
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  }
  \tl_clear:N \l__spath_tmpb_tl
  \tl_put_right:Nx \l__spath_tmpb_tl
  {
    {\dim_use:N \l__spath_tmpa_dim}
    {\dim_use:N \l__spath_tmpb_dim}
  }
  \spath_put:nnV {#1} {max bb} \l__spath_tmpb_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_generate_all:n}
% This function generates all of the data in one fell swoop.
% By traversing the path just once it is quicker than doing each one individually.
% However, it does need to store a lot of data as it goes.
% \begin{itemize}
% \item \Verb+\l__spath_rp_tl+ will hold the reversed path
% \item \Verb+\l__spath_l_int+ will hold the length
% \item \Verb+\l__spath_rl_int+ will hold the real length
% \item \Verb+\l__spath_nc_int+ will hold the number of components
% \item \Verb+\l__spath_ip_tl+ will hold the initial point
% \item \Verb+\l__spath_fp_tl+ will hold the final point
% \item \Verb+\l__spath_ia_tl+ will hold the initial action
% \item \Verb+\l__spath_fa_tl+ will hold the final action
% \item \Verb+\l__spath_minx_dim+ will hold the min x bb
% \item \Verb+\l__spath_miny_dim+ will hold the min y bb
% \item \Verb+\l__spath_maxx_dim+ will hold the max x bb
% \item \Verb+\l__spath_maxy_dim+ will hold the max y bb
% \end{itemize}
%    \begin{macrocode}
\tl_new:N \l__spath_rp_tl
\int_new:N \l__spath_l_int
\int_new:N \l__spath_rl_int
\int_new:N \l__spath_nc_int
\tl_new:N \l__spath_ip_tl
\tl_new:N \l__spath_fp_tl
\tl_new:N \l__spath_ia_tl
\tl_new:N \l__spath_fa_tl
\dim_new:N \l__spath_minx_dim
\dim_new:N \l__spath_miny_dim
\dim_new:N \l__spath_maxx_dim
\dim_new:N \l__spath_maxy_dim

\cs_new_nopar:Npn \spath_generate_all:n #1
{
  \__spath_get:nnN {#1} {path} \l__spath_tmpa_tl

  \tl_clear:N \l__spath_rp_tl
  \int_set:Nn \l__spath_l_int {1}
  \int_zero:N \l__spath_rl_int
  \int_set:Nn \l__spath_nc_int {1}
  \tl_clear:N \l__spath_ip_tl
  \tl_clear:N \l__spath_fp_tl
  \tl_clear:N \l__spath_ia_tl
  \tl_clear:N \l__spath_fa_tl
  \dim_zero:N \l__spath_minx_dim
  \dim_zero:N \l__spath_miny_dim
  \dim_zero:N \l__spath_maxx_dim
  \dim_zero:N \l__spath_maxy_dim

  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}

  \tl_clear:N \l__spath_ip_tl
  \tl_put_right:Nx \l__spath_ip_tl
  {
    {\dim_use:N \l__spath_tmpa_dim}
    {\dim_use:N \l__spath_tmpb_dim}
  }

  \dim_set_eq:NN \l__spath_minx_dim \l__spath_tmpa_dim
  \dim_set_eq:NN \l__spath_miny_dim \l__spath_tmpb_dim
  \dim_set_eq:NN \l__spath_maxx_dim \l__spath_tmpa_dim
  \dim_set_eq:NN \l__spath_maxy_dim \l__spath_tmpb_dim

  \tl_put_left:Nx \l__spath_rp_tl
  {
    {\dim_use:N \l__spath_tmpa_dim}
    {\dim_use:N \l__spath_tmpb_dim}
  }

  \tl_set:Nx \l__spath_ia_tl {\tl_head:N \l__spath_tmpa_tl}

  \bool_until_do:nn {
    \tl_if_empty_p:N \l__spath_tmpa_tl
  }
  {
    \tl_set:Nx \l__spath_tmpc_tl {\tl_head:N \l__spath_tmpa_tl}
    \tl_set:Nn \l__spath_tmpd_tl {}
    \tl_set_eq:NN \l__spath_fa_tl \l__spath_tmpc_tl
    \int_incr:N \l__spath_l_int

    \tl_case:Nnn \l__spath_tmpc_tl
    {
      \g__spath_moveto_tl {
        \tl_set_eq:NN \l__spath_tmpd_tl \g__spath_moveto_tl
        \int_incr:N \l__spath_nc_int
      }
      \g__spath_lineto_tl {
        \tl_set_eq:NN \l__spath_tmpd_tl \g__spath_lineto_tl
        \int_incr:N \l__spath_rl_int
      }
      \g__spath_curveto_tl {
        \tl_set_eq:NN \l__spath_tmpd_tl \g__spath_curvetoa_tl
        \int_incr:N \l__spath_rl_int
      }
      \g__spath_curvetoa_tl {
        \tl_set_eq:NN \l__spath_tmpd_tl \g__spath_curveto_tl
      }
      \g__spath_curvetob_tl {
        \tl_set_eq:NN \l__spath_tmpd_tl \g__spath_curvetob_tl
      }
    }
    {
      \tl_show:N \l__spath_tmpc_tl
    }
    \tl_put_left:NV \l__spath_rp_tl \l__spath_tmpd_tl
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}

    \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl}
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
    \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl}
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}

    \dim_set:Nn \l__spath_minx_dim {\dim_min:nn { \l__spath_minx_dim} {\l__spath_tmpa_dim}}
    \dim_set:Nn \l__spath_miny_dim {\dim_min:nn { \l__spath_miny_dim} {\l__spath_tmpb_dim}}
    \dim_set:Nn \l__spath_maxx_dim {\dim_max:nn { \l__spath_maxx_dim} {\l__spath_tmpa_dim}}
    \dim_set:Nn \l__spath_maxy_dim {\dim_max:nn { \l__spath_maxy_dim} {\l__spath_tmpb_dim}}

    \tl_put_left:Nx \l__spath_rp_tl
    {
      {\dim_use:N \l__spath_tmpa_dim}
      {\dim_use:N \l__spath_tmpb_dim}
    }

    \tl_set:Nx \l__spath_fp_tl
    {
      {\dim_use:N \l__spath_tmpa_dim}
      {\dim_use:N \l__spath_tmpb_dim}
    }

  }

  \tl_put_left:NV \l__spath_rp_tl \g__spath_moveto_tl

  \spath_put:nnV {#1} {reverse path} \l__spath_rp_tl
  \spath_put:nnV {#1} {length} \l__spath_l_int
  \spath_put:nnV {#1} {real length} \l__spath_rl_int
  \spath_put:nnV {#1} {number of components} \l__spath_nc_int
  \spath_put:nnV {#1} {initial point} \l__spath_ip_tl
  \spath_put:nnV {#1} {final point} \l__spath_fp_tl
  \spath_put:nnV {#1} {initial action} \l__spath_ia_tl
  \spath_put:nnV {#1} {final action} \l__spath_fa_tl

  \tl_clear:N \l__spath_tmpb_tl
  \tl_put_right:Nx \l__spath_tmpb_tl
  {
    {\dim_use:N \l__spath_minx_dim}
    {\dim_use:N \l__spath_miny_dim}
  }
  \spath_put:nnV {#1} {min bb} \l__spath_tmpb_tl

  \tl_clear:N \l__spath_tmpb_tl
  \tl_put_right:Nx \l__spath_tmpb_tl
  {
    {\dim_use:N \l__spath_maxx_dim}
    {\dim_use:N \l__spath_maxy_dim}
  }
  \spath_put:nnV {#1} {max bb} \l__spath_tmpb_tl

}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Path Manipulation}
%
% \begin{macro}{\spath_translate:nnn}
% Translates a path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_translate:nnn #1#2#3
{
  \tl_map_inline:Nn \g__spath_moveable_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \__spath_get:nnN {#1} {##1} \l__spath_tmpa_tl

      \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl + #2}
      \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
      \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl + #3}
      \tl_clear:N \l__spath_tmpb_tl
      \tl_put_right:Nx \l__spath_tmpb_tl
      {
        {\dim_use:N \l__spath_tmpa_dim}
        {\dim_use:N \l__spath_tmpb_dim}
      }
      \spath_put:nnV {#1} {##1} \l__spath_tmpb_tl
    }
  }
  \tl_map_inline:Nn \g__spath_path_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \__spath_get:nnN {#1} {##1} \l__spath_tmpa_tl
      \tl_clear:N \l__spath_tmpb_tl
      \bool_until_do:nn {
        \tl_if_empty_p:N \l__spath_tmpa_tl
      }
      {
        \tl_put_right:Nx \l__spath_tmpb_tl {\tl_head:N \l__spath_tmpa_tl}
        \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
        
        \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl + #2}
        \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}

        \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl + #3}
        \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}

        \tl_put_right:Nx \l__spath_tmpb_tl
        {
          {\dim_use:N \l__spath_tmpa_dim}
          {\dim_use:N \l__spath_tmpb_dim}
        }
      }
      \spath_put:nnV {#1} {##1} \l__spath_tmpb_tl
    }
  }
}

\cs_generate_variant:Nn \spath_translate:nnn {nxx}
%    \end{macrocode}
%
% This variant allows for passing the coordinates as a single braced group as it strips off the outer braces of the second argument.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_translate:nn #1#2
{
  \spath_translate:nnn {#1} #2
}

\cs_generate_variant:Nn \spath_translate:nn {nV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_scale:nnn}
% Scale a path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_scale:nnn #1#2#3
{
  \tl_map_inline:Nn \g__spath_moveable_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \__spath_get:nnN {#1} {##1} \l__spath_tmpa_tl

      \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl * #2}
      \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
      \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl * #3}
      \tl_clear:N \l__spath_tmpb_tl
      \tl_put_right:Nx \l__spath_tmpb_tl
      {
        {\dim_use:N \l__spath_tmpa_dim}
        {\dim_use:N \l__spath_tmpb_dim}
      }
      \spath_put:nnV {#1} {##1} \l__spath_tmpb_tl
    }
  }
  \tl_map_inline:Nn \g__spath_path_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \__spath_get:nnN {#1} {##1} \l__spath_tmpa_tl
      \tl_clear:N \l__spath_tmpb_tl
      \bool_until_do:nn {
        \tl_if_empty_p:N \l__spath_tmpa_tl
      }
      {
        \tl_put_right:Nx \l__spath_tmpb_tl {\tl_head:N \l__spath_tmpa_tl}
        \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
        
        \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl * #2}
        \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}

        \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl * #3}
        \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}

        \tl_put_right:Nx \l__spath_tmpb_tl
        {
          {\dim_use:N \l__spath_tmpa_dim}
          {\dim_use:N \l__spath_tmpb_dim}
        }
      }
      \spath_put:nnV {#1} {##1} \l__spath_tmpb_tl
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_reverse:n}
% This reverses a path.
% As a lot of the data is invariant under reversing, there isn't a lot to do.
%     \begin{macrocode}
\cs_new_nopar:Npn \spath_reverse:n #1
{
  \spath_if_in:nnF {#1} {reverse path} {
    \cs_use:c {spath_generate_reverse path}
  }
  \spath_swap:nnn {#1} {path} {reverse path}
  \spath_swap:nnn {#1} {initial point} {final point}
  \spath_swap:nnn {#1} {initial action} {final action}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_swap:nnn}
% Swaps two entries, being careful to ensure that their existence (or otherwise) is preserved.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_swap:nnn #1#2#3
{
  \__spath_get:nnNF {#1} {#2} \l__spath_tmpa_tl {\tl_clear:N \l__spath_tmpa_tl}
  \__spath_get:nnNF {#1} {#3} \l__spath_tmpb_tl {\tl_clear:N \l__spath_tmpb_tl}
  \tl_if_empty:NTF \l__spath_tmpb_tl
  {\spath_remove:nnV {#1} {#2}}
  {\spath_put:nnV {#1} {#2} \l__spath_tmpb_tl}
  \tl_if_empty:NTF \l__spath_tmpa_tl
  {\spath_remove:nnV {#1} {#3}}
  {\spath_put:nnV {#1} {#3} \l__spath_tmpa_tl}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_weld:nn}
% This welds one path to another, moving the second so that it's initial point coincides with the first's final point.
% It is called a \emph{weld} because the initial move of the second path is removed.
% The first path is updated, the second is not modified.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_weld:nn #1#2
{
  \spath_clone:nn {#2} {tmp_path}
  \spath_get:nnN {#1} {final point} \l__spath_tmpa_tl

  \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl}

  \spath_get:nnN {#2} {initial point} \l__spath_tmpa_tl

  \dim_sub:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl}
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \dim_sub:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl}

  \spath_translate:nxx {tmp_path} {\dim_use:N \l__spath_tmpa_dim} {\dim_use:N \l__spath_tmpb_dim}

  \__spath_get:nnN {#1} {path} \l__spath_tmpa_tl
  \__spath_get:nnN {tmp_path} {path} \l__spath_tmpb_tl
  \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
  \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
  \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
  \tl_put_right:NV \l__spath_tmpa_tl \l__spath_tmpb_tl

  \spath_put:nnV {#1} {path} \l__spath_tmpa_tl

  \__spath_get:nnNTF {tmp_path} {final point} \l__spath_tmpa_tl
  {
    \spath_put:nnV {#1} {final point} \l__spath_tmpa_tl
  }
  {
    \spath_remove:nn {#1} {final point}
  }

  \__spath_get:nnNTF {tmp_path} {final action} \l__spath_tmpa_tl
  {
    \spath_put:nnV {#1} {final action} \l__spath_tmpa_tl
  }
  {
    \spath_remove:nn {#1} {final action}
  }

  \__spath_get:nnNT {tmp_path} {min bb} \l__spath_tmpa_tl
  {
    \__spath_get:nnNT {#1} {min bb} \l__spath_tmpb_tl
    {
      \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl}
      \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
      \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl}

      \dim_set:Nn \l__spath_tmpa_dim {\dim_min:nn {\l__spath_tmpa_dim} {\tl_head:N           \l__spath_tmpb_tl}}
      \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
      \dim_set:Nn \l__spath_tmpb_dim {\dim_min:nn {\l__spath_tmpb_dim} {\tl_head:N \l__spath_tmpb_tl}}
      
      \tl_clear:N \l__spath_tmpb_tl
      \tl_put_right:Nx \l__spath_tmpb_tl
      {
        {\dim_use:N \l__spath_tmpa_dim}
        {\dim_use:N \l__spath_tmpb_dim}
      }
      \spath_put:nnV {#1} {min bb} \l__spath_tmpb_tl
    }
  }

  \__spath_get:nnNT {tmp_path} {max bb} \l__spath_tmpa_tl
  {
    \__spath_get:nnNT {#1} {max bb} \l__spath_tmpb_tl
    {
      \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl}
      \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
      \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl}

      \dim_set:Nn \l__spath_tmpa_dim {\dim_max:nn {\l__spath_tmpa_dim} {\tl_head:N           \l__spath_tmpb_tl}}
      \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
      \dim_set:Nn \l__spath_tmpb_dim {\dim_max:nn {\l__spath_tmpb_dim} {\tl_head:N \l__spath_tmpb_tl}}
      
      \tl_clear:N \l__spath_tmpb_tl
      \tl_put_right:Nx \l__spath_tmpb_tl
      {
        {\dim_use:N \l__spath_tmpa_dim}
        {\dim_use:N \l__spath_tmpb_dim}
      }
      \spath_put:nnV {#1} {max bb} \l__spath_tmpb_tl
    }
  }
  
  \__spath_get:nnNT {tmp_path} {reverse path} \l__spath_tmpa_tl
  {
    \__spath_get:nnNT {#1} {reverse path} \l__spath_tmpb_tl
    {
      \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
      \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
      \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
      \tl_put_right:NV \l__spath_tmpa_tl \l__spath_tmpb_tl

      \spath_put:nnV {#1} {reverse path} \l__spath_tmpa_tl
    }
  }

  \__spath_get:nnNT {tmp_path} {length} \l__spath_tmpa_tl
  {
    \__spath_get:nnNT {#1} {length} \l__spath_tmpb_tl
    {
      \int_set:Nn \l__spath_tmpa_int {\l__spath_tmpa_tl + \l__spath_tmpb_tl - 1}
      \spath_put:nnV {#1} {length} \l__spath_tmpa_int
    }
  }

  \__spath_get:nnNT {tmp_path} {real length} \l__spath_tmpa_tl
  {
    \__spath_get:nnNT {#1} {real length} \l__spath_tmpb_tl
    {
      \int_set:Nn \l__spath_tmpa_int {\l__spath_tmpa_tl + \l__spath_tmpb_tl}
      \spath_put:nnV {#1} {real length} \l__spath_tmpa_int
    }
  }

  \__spath_get:nnNT {tmp_path} {number of components} \l__spath_tmpa_tl
  {
    \__spath_get:nnNT {#1} {number of components} \l__spath_tmpb_tl
    {
      \int_set:Nn \l__spath_tmpa_int {\l__spath_tmpa_tl + \l__spath_tmpb_tl - 1}
      \spath_put:nnV {#1} {number of components} \l__spath_tmpa_int
    }
  }
  
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_prepend_no_move:nn}
% Prepend the path from the second \Verb+spath+ to the first, removing
% the adjoining move.  
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_prepend_no_move:nn #1#2
{
  \spath_if_exist:nT {#2}
  {
    \__spath_get:nnN {#2} {path} \l__spath_tmpa_tl
    \__spath_get:nnN {#1} {path} \l__spath_tmpb_tl
    \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
    \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
    \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
    \tl_put_right:NV \l__spath_tmpa_tl \l__spath_tmpb_tl
    \spath_put:nnV {#1} {path} \l__spath_tmpa_tl

    \spath_if_in:nnTF {#2} {initial point}
    {
      \__spath_get:nnN {#2} {initial point} \l__spath_tmpa_tl
      \spath_put:nnV {#1} {initial point} \l__spath_tmpa_tl
    }
    {
      \spath_remove:nn {#1} {initial point}
    }

    \spath_if_in:nnTF {#2} {initial action}
    {
      \__spath_get:nnN {#2} {initial action} \l__spath_tmpa_tl
      \spath_put:nnV {#1} {initial action} \l__spath_tmpa_tl
    }
    {
      \spath_remove:nn {#1} {initial action}
    }

    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {length}
      &&
      \spath_if_in_p:nn {#2} {length}
    }
    {
      \__spath_get:nnN {#1} {length} \l__spath_tmpa_tl
      \__spath_get:nnN {#2} {length} \l__spath_tmpb_tl
      \spath_put:nnx {#1} {length} {\int_eval:n {\l__spath_tmpa_tl +
          \l__spath_tmpb_tl - 1}}
    }
    {
      \spath_remove:nn {#1} {length}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {real length}
      &&
      \spath_if_in_p:nn {#2} {real length}
    }
    {
      \__spath_get:nnN {#1} {real length} \l__spath_tmpa_tl
      \__spath_get:nnN {#2} {real length} \l__spath_tmpb_tl
      \spath_put:nnx {#1} {real length} {\int_eval:n {\l__spath_tmpa_tl +
          \l__spath_tmpb_tl }}
    }
    {
      \spath_remove:nn {#1} {real length}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {number of components}
      &&
      \spath_if_in_p:nn {#2} {number of components}
    }
    {
      \__spath_get:nnN {#1} {number of components} \l__spath_tmpa_tl
      \__spath_get:nnN {#2} {number of components} \l__spath_tmpb_tl
      \spath_put:nnx {#1} {number of components} {\int_eval:n {\l__spath_tmpa_tl +
          \l__spath_tmpb_tl - 1}}
    }
    {
      \spath_remove:nn {#1} {number of components}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {min bb}
      &&
      \spath_if_in_p:nn {#2} {min bb}
    }
    {
      \__spath_get:nnN {#1} {min bb} \l__spath_tmpa_tl
      \__spath_get:nnN {#2} {min bb} \l__spath_tmpb_tl
      \dim_set:Nn \l__spath_tmpa_dim {\dim_min:nn {\tl_item:Nn
          \l__spath_tmpa_tl {1}} {\tl_item:Nn
          \l__spath_tmpb_tl {1}}}
      \dim_set:Nn \l__spath_tmpb_dim {\dim_min:nn {\tl_item:Nn
          \l__spath_tmpa_tl {2}} {\tl_item:Nn
          \l__spath_tmpb_tl {2}}}
      \spath_put:nnx {#1} {min bb} {
        {\dim_use:N \l__spath_tmpa_dim}
        {\dim_use:N \l__spath_tmpb_dim}
      }
    }
    {
      \spath_remove:nn {#1} {min bb}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {max bb}
      &&
      \spath_if_in_p:nn {#2} {max bb}
    }
    {
      \__spath_get:nnN {#1} {max bb} \l__spath_tmpa_tl
      \__spath_get:nnN {#2} {max bb} \l__spath_tmpb_tl
      \dim_set:Nn \l__spath_tmpa_dim {\dim_min:nn {\tl_item:Nn
          \l__spath_tmpa_tl {1}} {\tl_item:Nn
          \l__spath_tmpb_tl {1}}}
      \dim_set:Nn \l__spath_tmpb_dim {\dim_min:nn {\tl_item:Nn
          \l__spath_tmpa_tl {2}} {\tl_item:Nn
          \l__spath_tmpb_tl {2}}}
      \spath_put:nnx {#1} {max bb} {
        {\dim_use:N \l__spath_tmpa_dim}
        {\dim_use:N \l__spath_tmpb_dim}
      }
    }
    {
      \spath_remove:nn {#1} {max bb}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {reverse path}
      &&
      \spath_if_in_p:nn {#2} {reverse path}
    }
    {
      \__spath_get:nnN {#1} {reverse path} \l__spath_tmpa_tl
      \__spath_get:nnN {#2} {reverse path} \l__spath_tmpb_tl
      \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
      \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
      \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
      \tl_put_right:NV \l__spath_tmpa_tl \l__spath_tmpb_tl
      \spath_put:nnV {#1} {reverse path} \l__spath_tmpb_tl
    }
    {
      \spath_remove:nn {#1} {reverse path}
    }

  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_append_no_move:nn}
% Append the path from the second \Verb+spath+ to the first, removing
% the adjoining move.  
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_append_no_move:nn #1#2
{
  \spath_if_exist:nT {#2}
  {
    \spath_get:nnN {#1} {path} \l__spath_tmpa_tl
    \spath_get:nnN {#2} {path} \l__spath_tmpb_tl
    \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
    \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
    \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
    \tl_put_right:NV \l__spath_tmpa_tl \l__spath_tmpb_tl
    \spath_put:nnV {#1} {path} \l__spath_tmpa_tl
    \spath_if_in:nnTF {#2} {final point}
    {
      \__spath_get:nnN {#2} {final point} \l__spath_tmpa_tl
      \spath_put:nnV {#1} {final point} \l__spath_tmpa_tl
    }
    {
      \spath_remove:nn {#1} {final point}
    }
    \spath_if_in:nnTF {#2} {final action}
    {
      \__spath_get:nnN {#2} {final action} \l__spath_tmpa_tl
      \spath_put:nnV {#1} {final action} \l__spath_tmpa_tl
    }
    {
      \spath_remove:nn {#1} {final action}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {length}
      &&
      \spath_if_in_p:nn {#2} {length}
    }
    {
      \__spath_get:nnN {#1} {length} \l__spath_tmpa_tl
      \__spath_get:nnN {#2} {length} \l__spath_tmpb_tl
      \spath_put:nnx {#1} {length} {\int_eval:n {\l__spath_tmpa_tl +
          \l__spath_tmpb_tl - 1}}
    }
    {
      \spath_remove:nn {#1} {length}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {real length}
      &&
      \spath_if_in_p:nn {#2} {real length}
    }
    {
      \__spath_get:nnN {#1} {real length} \l__spath_tmpa_tl
      \__spath_get:nnN {#2} {real length} \l__spath_tmpb_tl
      \spath_put:nnx {#1} {real length} {\int_eval:n {\l__spath_tmpa_tl +
          \l__spath_tmpb_tl }}
    }
    {
      \spath_remove:nn {#1} {real length}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {number of components}
      &&
      \spath_if_in_p:nn {#2} {number of components}
    }
    {
      \__spath_get:nnN {#1} {number of components} \l__spath_tmpa_tl
      \__spath_get:nnN {#2} {number of components} \l__spath_tmpb_tl
      \spath_put:nnx {#1} {number of components} {\int_eval:n {\l__spath_tmpa_tl +
          \l__spath_tmpb_tl - 1}}
    }
    {
      \spath_remove:nn {#1} {number of components}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {min bb}
      &&
      \spath_if_in_p:nn {#2} {min bb}
    }
    {
      \__spath_get:nnN {#1} {min bb} \l__spath_tmpa_tl
      \__spath_get:nnN {#2} {min bb} \l__spath_tmpb_tl
      \dim_set:Nn \l__spath_tmpa_dim {\dim_min:nn {\tl_item:Nn
          \l__spath_tmpa_tl {1}} {\tl_item:Nn
          \l__spath_tmpb_tl {1}}}
      \dim_set:Nn \l__spath_tmpb_dim {\dim_min:nn {\tl_item:Nn
          \l__spath_tmpa_tl {2}} {\tl_item:Nn
          \l__spath_tmpb_tl {2}}}
      \spath_put:nnx {#1} {min bb} {
        {\dim_use:N \l__spath_tmpa_dim}
        {\dim_use:N \l__spath_tmpb_dim}
      }
    }
    {
      \spath_remove:nn {#1} {min bb}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {max bb}
      &&
      \spath_if_in_p:nn {#2} {max bb}
    }
    {
      \__spath_get:nnN {#1} {max bb} \l__spath_tmpa_tl
      \__spath_get:nnN {#2} {max bb} \l__spath_tmpb_tl
      \dim_set:Nn \l__spath_tmpa_dim {\dim_min:nn {\tl_item:Nn
          \l__spath_tmpa_tl {1}} {\tl_item:Nn
          \l__spath_tmpb_tl {1}}}
      \dim_set:Nn \l__spath_tmpb_dim {\dim_min:nn {\tl_item:Nn
          \l__spath_tmpa_tl {2}} {\tl_item:Nn
          \l__spath_tmpb_tl {2}}}
      \spath_put:nnx {#1} {max bb} {
        {\dim_use:N \l__spath_tmpa_dim}
        {\dim_use:N \l__spath_tmpb_dim}
      }
    }
    {
      \spath_remove:nn {#1} {max bb}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {reverse path}
      &&
      \spath_if_in_p:nn {#2} {reverse path}
    }
    {
      \__spath_get:nnN {#2} {reverse path} \l__spath_tmpa_tl
      \__spath_get:nnN {#1} {reverse path} \l__spath_tmpb_tl
      \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
      \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
      \tl_set:Nx \l__spath_tmpb_tl {\tl_tail:N \l__spath_tmpb_tl}
      \tl_put_right:NV \l__spath_tmpa_tl \l__spath_tmpb_tl
      \spath_put:nnV {#1} {reverse path} \l__spath_tmpb_tl
    }
    {
      \spath_remove:nn {#1} {reverse path}
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Iteration Functions}
%
% \begin{macro}{\spath_map_component:Nn}
% This iterates through the components of a path, applying the inline function to each.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_map_component:Nn #1#2
{
  \int_gincr:N \g__prg_map_int
  \cs_gset:cpn { __prg_map_ \int_use:N \g__prg_map_int :w } ##1 {#2}
  \tl_set:NV \l__spath_tmpa_tl #1
  \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  \tl_put_right:NV \l__spath_tmpa_tl \g__spath_moveto_tl
  \tl_set_eq:NN \l__spath_tmpb_tl \g__spath_moveto_tl
  \bool_until_do:nn {
    \tl_if_empty_p:N \l__spath_tmpa_tl
  }
  {
    \tl_set:Nx \l__spath_tmpc_tl {\tl_head:N \l__spath_tmpa_tl}
    \tl_if_eq:NNT \l__spath_tmpc_tl \g__spath_moveto_tl
    {
      \exp_args:NnV \use:c { __prg_map_ \int_use:N \g__prg_map_int :w } \l__spath_tmpb_tl
\tl_clear:N \l__spath_tmpb_tl
    }
    \tl_if_single:NTF \l__spath_tmpc_tl
    {
      \tl_put_right:NV \l__spath_tmpb_tl \l__spath_tmpc_tl
    }
    {
      \tl_put_right:Nx \l__spath_tmpb_tl {{\l__spath_tmpc_tl}}
    }
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_map_segment:Nn}
% This iterates through the segments of the path, applying the inline function to each.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_map_segment:Nn #1#2
{
  \int_gincr:N \g__prg_map_int
  \cs_gset:cpn { __prg_map_ \int_use:N \g__prg_map_int :w } ##1 ##2 {#2}
  \tl_set:NV \l__spath_tmpa_tl #1
  \tl_clear:N \l__spath_tmpb_tl
  \dim_zero:N \l__spath_tmpa_dim
  \dim_zero:N \l__spath_tmpb_dim

  \bool_until_do:nn {
    \tl_if_empty_p:N \l__spath_tmpa_tl
  }
  {
    \tl_set:Nx \l__spath_tmpc_tl {\tl_head:N \l__spath_tmpa_tl}
    \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
    \tl_case:Nnn \l__spath_tmpc_tl
    {
      \g__spath_lineto_tl
      {
        \tl_set_eq:NN \l__spath_tmpb_tl \g__spath_moveto_tl
        \tl_put_right:Nx \l__spath_tmpb_tl
        {
          {\dim_use:N \l__spath_tmpa_dim}
          {\dim_use:N \l__spath_tmpb_dim}
        }
        \tl_put_right:NV \l__spath_tmpb_tl \g__spath_lineto_tl

        \tl_put_right:Nx \l__spath_tmpb_tl {{\tl_head:N \l__spath_tmpa_tl}}
        \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl}
        \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}

        \tl_put_right:Nx \l__spath_tmpb_tl {{\tl_head:N \l__spath_tmpa_tl}}
        \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl}
        \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}

      }

      \g__spath_curvetoa_tl
      {
        \tl_set_eq:NN \l__spath_tmpb_tl \g__spath_moveto_tl
        \tl_put_right:Nx \l__spath_tmpb_tl
        {
          {\dim_use:N \l__spath_tmpa_dim}
          {\dim_use:N \l__spath_tmpb_dim}
        }
        \tl_put_right:NV \l__spath_tmpb_tl \g__spath_curvetoa_tl

        \prg_replicate:nn {2} {
          \tl_put_right:Nx \l__spath_tmpb_tl {{\tl_head:N \l__spath_tmpa_tl}}
          \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
          \tl_put_right:Nx \l__spath_tmpb_tl {{\tl_head:N               \l__spath_tmpa_tl}}
          \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
          \tl_put_right:Nx \l__spath_tmpb_tl {\tl_head:N             \l__spath_tmpa_tl}
          \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
        }

        \tl_put_right:Nx \l__spath_tmpb_tl {{\tl_head:N \l__spath_tmpa_tl}}
        \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl}
        \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}

        \tl_put_right:Nx \l__spath_tmpb_tl {{\tl_head:N \l__spath_tmpa_tl}}
        \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl}
        \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}

      }
    }
    {

      \tl_set_eq:NN \l__spath_tmpb_tl \l__spath_tmpc_tl
      \tl_put_right:Nx \l__spath_tmpb_tl {{\tl_head:N \l__spath_tmpa_tl}}
      \dim_set:Nn \l__spath_tmpa_dim {\tl_head:N \l__spath_tmpa_tl}
      \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}

      \tl_put_right:Nx \l__spath_tmpb_tl {{\tl_head:N \l__spath_tmpa_tl}}
      \dim_set:Nn \l__spath_tmpb_dim {\tl_head:N \l__spath_tmpa_tl}
      \tl_set:Nx \l__spath_tmpa_tl {\tl_tail:N \l__spath_tmpa_tl}
      
    }

    \use:c { __prg_map_ \int_use:N \g__prg_map_int :w } \l__spath_tmpc_tl \l__spath_tmpb_tl
    \tl_clear:N \l__spath_tmpb_tl

  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Public Commands}
%
% The next functions are more ``public'' than the previous lot.
% That said, they aren't intended for direct use in a normal document.
%
% Most are just wrappers around internal functions.
%
% \begin{macro}{\MakeSPath}
% Constructs an \Verb+spath+ object out of the given name and path.
%    \begin{macrocode}
\NewDocumentCommand \MakeSPath { m m }
{
  \spath_clear_new:n {#1}
  \spath_put:nno {#1} {path} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\MakeSPathList}
% This constructs a list of \Verb+spath+ objects from a single path by splitting it into components.
%    \begin{macrocode}
\NewDocumentCommand \MakeSPathList { m m }
{
  \tl_gclear_new:c {l__spath_list_#1}
  \int_zero:N \l__spath_tmpa_int
  \spath_map_component:Nn #2 {
    \spath_clear_new:n {#1 _ \int_use:N \l__spath_tmpa_int}
    \spath_put:nnn  {#1 _ \int_use:N \l__spath_tmpa_int} {path} {##1}
    \tl_gput_right:cx {l__spath_list_#1} {{#1 _ \int_use:N \l__spath_tmpa_int}}
    \int_incr:N \l__spath_tmpa_int
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\CloneSPath}
%    \begin{macrocode}
\NewDocumentCommand \CloneSPath { m m }
{
  \spath_clone:nn {#1} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SPathInfo}
%    \begin{macrocode}
\NewDocumentCommand \SPathInfo { m m }
{
  \spath_get:nn {#1} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SPathPrepare}
%    \begin{macrocode}
\NewDocumentCommand \SPathPrepare { m }
{
  \spath_generate_all:n {#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SPathListPrepare}
%    \begin{macrocode}
\NewDocumentCommand \SPathListPrepare { m }
{
  \tl_map_inline:cn {l__spath_list_#1}
  {
    \spath_generate_all:n {##1}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SPathInfoInto}
%    \begin{macrocode}
\NewDocumentCommand \SPathInfoInto { m m m }
{
  \tl_set:Nn \l_tmpa_tl #3
  \spath_get:nnV {#1} {#2} \l_tmpa_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SPathShow}
%    \begin{macrocode}
\NewDocumentCommand \SPathShow { m m }
{
  \spath_show:n {#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SPathTranslate}
%    \begin{macrocode}
\NewDocumentCommand \SPathTranslate { m m m }
{
  \spath_translate:nnn {#1} {#2} {#3}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SPathTranslateInto}
% Clones the path before translating it.
%    \begin{macrocode}
\NewDocumentCommand \SPathTranslateInto { m m m m }
{
  \spath_clone:nn {#1} {#2}
  \spath_translate:nnn {#2} {#3} {#4}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SPathScale}
%    \begin{macrocode}
\NewDocumentCommand \SPathScale { m m m }
{
  \spath_translate:nnn {#1} {#2} {#3}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SPathScaleInto}
% Clones the path first.
%    \begin{macrocode}
\NewDocumentCommand \SPathScaleInto { m m m m }
{
  \spath_clone:nn {#1} {#2}
  \spath_translate:nnn {#2} {#3} {#4}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SPathWeld}
%    \begin{macrocode}
\NewDocumentCommand \SPathWeld { m m }
{
  \spath_weld:nn {#1} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SPathWeldInto}
%    \begin{macrocode}
\NewDocumentCommand \SPathWeldInto { m m m }
{
  \spath_clone:nn {#1} {#2}
  \spath_weld:nn {#2} {#3}
}
%    \end{macrocode}
% \end{macro}
%
% \iffalse
%</spath3>
% \fi
%
% \iffalse
%<*calligraphy>
% \fi
%
% \section{The Calligraphy Package}
%
% \subsection{Initialisation}
%    \begin{macrocode}
\RequirePackage{spath3}
\ExplSyntaxOn

\tl_new:N \l__cal_tmpa_tl
\tl_new:N \l__cal_tmpb_tl
\int_new:N \l__cal_tmpa_int
\int_new:N \l__cal_tmpb_int
\int_new:N \l__cal_path_component_int
\dim_new:N \l__cal_tmpa_dim
\dim_new:N \l__cal_tmpb_dim
\dim_new:N \l__cal_tmpc_dim
\dim_new:N \l__cal_tmpd_dim
\dim_new:N \l__cal_tmpe_dim
\dim_new:N \l__cal_tmpf_dim
\dim_new:N \l__cal_tmpg_dim
\dim_new:N \l__cal_tmph_dim
\bool_new:N \l__cal_taper_start_bool
\bool_new:N \l__cal_taper_end_bool
\bool_new:N \l__cal_taperable_bool
\dim_new:N \l__cal_taper_width_dim
\dim_new:N \l__cal_line_width_dim

\bool_set_true:N \l__cal_taper_start_bool
\bool_set_true:N \l__cal_taper_end_bool
%    \end{macrocode}
%
% \subsection{TikZ Keys}
%
% The public interface to this package is through TikZ keys and styles.
%    \begin{macrocode}
\tikzset{
  define~pen/.code={
    \tikzset{pen~name=#1}
    \pgf@relevantforpicturesizefalse
    \tikz@addmode{
      \pgfsyssoftpath@getcurrentpath\cal@tmp@path
      \MakeSPathList{calligraphy pen \pgfkeysvalueof{/tikz/pen~name}}{\cal@tmp@path}
      \SPathListPrepare{calligraphy pen \pgfkeysvalueof{/tikz/pen~name}}
      \pgfusepath{discard}%
    }
  },
  define~pen/.default={default},
  use~pen/.code={
    \tikzset{pen~name=#1}
    \int_gzero:N \l__cal_path_component_int
    \cs_set_eq:NN \pgfpathmoveto \cal_moveto:n
    \tikz@addmode{
      \pgfsyssoftpath@getcurrentpath\cal@tmp@path
      \MakeSPathList{calligraphy path}{\cal@tmp@path}
      \SPathListPrepare{calligraphy path}
      \CalligraphyPathCreate{calligraphy path}{\pgfkeysvalueof{/tikz/pen~name}}
    }
  },
  use~pen/.default={default},
  pen~name/.initial={default},
  copperplate/.style={pen~name=copperplate},
  pen~colour/.initial={black},
  weight/.is~choice,
  weight/heavy/.style={
    line~width=\pgfkeysvalueof{/tikz/heavy~line~width},
    taper~width=\pgfkeysvalueof{/tikz/light~line~width},
  },
  weight/light/.style={
    line~width=\pgfkeysvalueof{/tikz/light~line~width},
    taper~width=0pt,
  },
  heavy/.style={
    weight=heavy
  },
  light/.style={
    weight=light
  },
  heavy~line~width/.initial=2pt,
  light~line~width/.initial=1pt,
  taper/.is~choice,
  taper/.default=both,
  taper/none/.style={
    taper~start=false,
    taper~end=false,
  },
  taper/both/.style={
    taper~start=true,
    taper~end=true,
  },
  taper/start/.style={
    taper~start=true,
    taper~end=false,
  },
  taper/end/.style={
    taper~start=false,
    taper~end=true,
  },
  taper~start/.code={
    \tl_if_eq:nnTF {#1} {true}
    {
      \bool_set_true:N \l__cal_taper_start_bool
    }
    {
      \bool_set_false:N \l__cal_taper_start_bool
    }
  },
  taper~start/.default={true},
  taper~end/.code={
    \tl_if_eq:nnTF {#1} {true}
    {
      \bool_set_true:N \l__cal_taper_end_bool
    }
    {
      \bool_set_false:N \l__cal_taper_end_bool
    }
  },
  taper~end/.default={true},
  taper~width/.code={\dim_set:Nn \l__cal_taper_width_dim {#1}},
  nib~style/.code~2~args={
    \tl_clear_new:c {l__cal_nib_style_#1}
    \tl_set:cn {l__cal_nib_style_#1} {#2}
  },
  stroke~style/.code~2~args={
    \tl_clear_new:c {l__cal_stroke_style_#1}
    \tl_set:cn {l__cal_stroke_style_#1} {#2}
  },
  this~stroke~style/.code={
    \tl_clear_new:c {l__cal_stroke_inline_style_ \int_use:N \l__cal_path_component_int}
    \tl_set:cn {l__cal_stroke_inline_style_ \int_use:N \l__cal_path_component_int} {#1}
  },
}
%    \end{macrocode}
%
% Some wrappers around the TikZ keys.
%    \begin{macrocode}
\NewDocumentCommand \pen { O{} }
{
  \path[define~ pen,#1]
}

\NewDocumentCommand \definepen { O{} }
{
  \tikz \path[define~ pen,#1]
}

\NewDocumentCommand \calligraphy { O{} }
{
  \path[use~ pen,#1]
}
%    \end{macrocode}
%
% \subsection{The Path Creation}
%
% \begin{macro}{\CalligraphyPathCreate}
% This is the main command for creating the calligraphic paths.
%    \begin{macrocode}
\NewDocumentCommand \CalligraphyPathCreate { m m }
{
  \int_zero:N \l__cal_tmpa_int
  \tl_map_inline:cn {l__spath_list_#1}
  {
    \int_incr:N \l__cal_tmpa_int
    \int_zero:N \l__cal_tmpb_int
    \tl_map_inline:cn {l__spath_list_calligraphy pen #2}
    {
      \int_incr:N \l__cal_tmpb_int
      \group_begin:
      \cal_apply_style:c {l__cal_stroke_style_ \int_use:N \l__cal_tmpa_int}
      \cal_apply_style:c {l__cal_stroke_inline_style_ \int_use:N \l__cal_tmpa_int}
      \cal_apply_style:c {l__cal_nib_style_ \int_use:N \l__cal_tmpb_int}

      \spath_clone:nn {##1} {calligraphy temp path}

      \__spath_get:nnN {####1} {initial point} \l__spath_tmpa_tl
      \spath_translate:nV {calligraphy temp path} \l__spath_tmpa_tl

      \__spath_get:nnN {####1} {length} \l__spath_tmpa_tl
      
      \int_compare:nTF {\l__spath_tmpa_tl = 1}
      {
        \cal_at_least_three:n {calligraphy temp path}

        \__spath_get:nnN {calligraphy temp path} {min bb} \l__spath_tmpa_tl
        \exp_last_unbraced:NV \pgf@protocolsizes\l__spath_tmpa_tl

        \__spath_get:nnN {calligraphy temp path} {max bb} \l__spath_tmpa_tl
        \exp_last_unbraced:NV \pgf@protocolsizes\l__spath_tmpa_tl

        \__spath_get:nnN {calligraphy temp path} {path} \l__spath_tmpa_tl

        \tikz@options
        \dim_set:Nn \l__cal_line_width_dim {\pgflinewidth}
        \cal_maybe_taper:N \l__spath_tmpa_tl
      }
      {

        \spath_weld:nn {calligraphy temp path} {####1}
        \spath_reverse:n {##1}
        \spath_reverse:n {####1}
        \spath_weld:nn {calligraphy temp path} {##1}
        \spath_weld:nn {calligraphy temp path} {####1}
        \spath_reverse:n {##1}
        \spath_reverse:n {####1}

        \__spath_get:nnN {calligraphy temp path} {min bb} \l__spath_tmpa_tl
        \exp_last_unbraced:NV \pgf@protocolsizes\l__spath_tmpa_tl

        \__spath_get:nnN {calligraphy temp path} {max bb} \l__spath_tmpa_tl
        \exp_last_unbraced:NV \pgf@protocolsizes\l__spath_tmpa_tl

        \__spath_get:nnN {calligraphy temp path} {path} \l__spath_tmpa_tl
        \pgfsyssoftpath@setcurrentpath\l__spath_tmpa_tl
        \tikz@options
        \pgfsetfillcolor{\pgfkeysvalueof{/tikz/pen~colour}}
        \pgfusepath{fill}
      }
      \group_end:
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cal_moveto:n}
% When creating the path, we need to keep track of the number of components so that we can apply styles accordingly.
%    \begin{macrocode}
\cs_new_eq:NN \cal_orig_moveto:n \pgfpathmoveto
\cs_new_nopar:Npn \cal_moveto:n #1
{
  \int_gincr:N \l__cal_path_component_int
  \cal_orig_moveto:n {#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cal_apply_style:N}
% Interface for applying \Verb+\tikzset+ to a token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_apply_style:N #1
{
  \tl_if_exist:NT #1 {
    \exp_args:NV \tikzset #1
  }
}
\cs_generate_variant:Nn \cal_apply_style:N {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cal_at_least_three:n}
% A tapered path has to have at least three components.
% This figures out if it is necessary and sets up the splitting.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_at_least_three:n #1
{
  \spath_get:nnN {#1} {real length} \l__cal_tmpa_tl
  \tl_clear:N \l__cal_tmpb_tl
  \int_compare:nTF {\l__cal_tmpa_tl = 1}
  {
    \spath_get:nnN {#1} {path} \l__cal_tmpa_tl
    \spath_map_segment:Nn \l__cal_tmpa_tl
    {
      \tl_case:Nnn ##1 {
        \g__spath_lineto_tl {
          \cal_split_line_in_three:NN \l__cal_tmpb_tl ##2
        }
        \g__spath_curvetoa_tl {
          \cal_split_curve_in_three:NN \l__cal_tmpb_tl ##2
        }
      }
      {
        \tl_put_right:NV \l__cal_tmpb_tl ##2
      }
    }
    \spath_put:nnV {#1} {path} \l__cal_tmpb_tl
  }
  {
    \int_compare:nT {\l__cal_tmpa_tl = 2}
    {
      \spath_get:nnN {#1} {path} \l__cal_tmpa_tl
      \spath_map_segment:Nn \l__cal_tmpa_tl
      {
        \tl_case:Nnn ##1 {
          \g__spath_lineto_tl {
            \cal_split_line_in_two:NN \l__cal_tmpb_tl ##2
          }
          \g__spath_curvetoa_tl {
            \cal_split_curve_in_two:NN \l__cal_tmpb_tl ##2
          }
        }
        {
          \tl_put_right:NV \l__cal_tmpb_tl ##2
        }
      }
      \spath_put:nnV {#1} {path} \l__cal_tmpb_tl
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cal_split_line_in_two:NN}
% Splits a line in two, adding the splits to the first token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_split_line_in_two:NN #1#2
{
  \tl_set_eq:NN \l__cal_tmpc_tl #2

  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpa_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpb_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpc_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}
  \dim_set:Nn \l__cal_tmpd_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \tl_put_right:NV #1 \g__spath_lineto_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(\l__cal_tmpa_dim + \l__cal_tmpc_dim)/2}}
    {\dim_eval:n {(\l__cal_tmpb_dim + \l__cal_tmpd_dim)/2}}
  }

  \tl_put_right:NV #1 \g__spath_lineto_tl
  \tl_put_right:Nx #1 {
    {\dim_use:N \l__cal_tmpc_dim}
    {\dim_use:N \l__cal_tmpd_dim}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cal_split_line_in_three:NN}
% Splits a line in three, adding the splits to the first token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_split_line_in_three:NN #1#2
{
  \tl_set_eq:NN \l__cal_tmpc_tl #2

  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpa_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpb_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpc_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}
  \dim_set:Nn \l__cal_tmpd_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \tl_put_right:NV #1 \g__spath_lineto_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(2\l__cal_tmpa_dim + \l__cal_tmpc_dim)/3}}
    {\dim_eval:n {(2\l__cal_tmpb_dim + \l__cal_tmpd_dim)/3}}
  }

  \tl_put_right:NV #1 \g__spath_lineto_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(\l__cal_tmpa_dim + 2\l__cal_tmpc_dim)/3}}
    {\dim_eval:n {(\l__cal_tmpb_dim + 2\l__cal_tmpd_dim)/3}}
  }

  \tl_put_right:NV #1 \g__spath_lineto_tl
  \tl_put_right:Nx #1 {
    {\dim_use:N \l__cal_tmpc_dim}
    {\dim_use:N \l__cal_tmpd_dim}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cal_split_curve_in_two:NN}
% Splits a curve in two, adding the splits to the first token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_split_curve_in_two:NN #1#2
{
  \tl_set_eq:NN \l__cal_tmpc_tl #2

  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpa_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpb_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpc_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpd_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpe_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpf_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpg_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmph_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \tl_put_right:NV #1 \g__spath_curvetoa_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(\l__cal_tmpa_dim + \l__cal_tmpc_dim)/2}}
    {\dim_eval:n {(\l__cal_tmpb_dim + \l__cal_tmpd_dim)/2}}
  }

  \tl_put_right:NV #1 \g__spath_curvetob_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(\l__cal_tmpa_dim + 2\l__cal_tmpc_dim + \l__cal_tmpe_dim)/4}}
    {\dim_eval:n {(\l__cal_tmpb_dim + 2\l__cal_tmpd_dim + \l__cal_tmpf_dim)/4}}
  }
  
  \tl_put_right:NV #1 \g__spath_curveto_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(\l__cal_tmpa_dim + 3\l__cal_tmpc_dim + 3\l__cal_tmpe_dim + \l__cal_tmpg_dim)/8}}
    {\dim_eval:n {(\l__cal_tmpb_dim + 3\l__cal_tmpd_dim + 3\l__cal_tmpf_dim + \l__cal_tmph_dim)/8}}
  }

  \tl_put_right:NV #1 \g__spath_curvetoa_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(\l__cal_tmpc_dim + 2\l__cal_tmpe_dim + \l__cal_tmpg_dim)/4}}
    {\dim_eval:n {(\l__cal_tmpd_dim + 2\l__cal_tmpf_dim + \l__cal_tmph_dim)/4}}
  }

  \tl_put_right:NV #1 \g__spath_curvetob_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(\l__cal_tmpe_dim + \l__cal_tmpg_dim)/2}}
    {\dim_eval:n {(\l__cal_tmpf_dim + \l__cal_tmph_dim)/2}}
  }

  \tl_put_right:NV #1 \g__spath_curveto_tl

  \tl_put_right:Nx #1 {
    {\dim_use:N \l__cal_tmpg_dim}
    {\dim_use:N \l__cal_tmph_dim}
  }
  
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cal_split_curve_in_three:NN}
% Splits a curve in three, adding the splits to the first token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_split_curve_in_three:NN #1#2
{
  \tl_set_eq:NN \l__cal_tmpc_tl #2

  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpa_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpb_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpc_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpd_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpe_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpf_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmpg_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \dim_set:Nn \l__cal_tmph_dim {\tl_head:N \l__cal_tmpc_tl}
  \tl_set:Nx \l__cal_tmpc_tl {\tl_tail:N \l__cal_tmpc_tl}

  \tl_put_right:NV #1 \g__spath_curvetoa_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(2\l__cal_tmpa_dim + \l__cal_tmpc_dim)/3}}
    {\dim_eval:n {(2\l__cal_tmpb_dim + \l__cal_tmpd_dim)/3}}
  }

  \tl_put_right:NV #1 \g__spath_curvetob_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(4\l__cal_tmpa_dim + 4\l__cal_tmpc_dim + \l__cal_tmpe_dim)/9}}
    {\dim_eval:n {(4\l__cal_tmpb_dim + 4\l__cal_tmpd_dim + \l__cal_tmpf_dim)/9}}
  }
  
  \tl_put_right:NV #1 \g__spath_curveto_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(8\l__cal_tmpa_dim + 12\l__cal_tmpc_dim + 6\l__cal_tmpe_dim + \l__cal_tmpg_dim)/27}}
    {\dim_eval:n {(8\l__cal_tmpb_dim + 12\l__cal_tmpd_dim + 6\l__cal_tmpf_dim + \l__cal_tmph_dim)/27}}
  }

  \tl_put_right:NV #1 \g__spath_curvetoa_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(4\l__cal_tmpa_dim + 12\l__cal_tmpc_dim + 9\l__cal_tmpe_dim + 2\l__cal_tmpg_dim)/27}}
    {\dim_eval:n {(4\l__cal_tmpb_dim + 12\l__cal_tmpd_dim + 9\l__cal_tmpf_dim + 2\l__cal_tmph_dim)/27}}
  }

  \tl_put_right:NV #1 \g__spath_curvetob_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(2\l__cal_tmpa_dim + 9\l__cal_tmpc_dim + 12\l__cal_tmpe_dim + 4\l__cal_tmpg_dim)/27}}
    {\dim_eval:n {(2\l__cal_tmpb_dim + 9\l__cal_tmpd_dim + 12\l__cal_tmpf_dim + 4\l__cal_tmph_dim)/27}}
  }

  \tl_put_right:NV #1 \g__spath_curveto_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(\l__cal_tmpa_dim + 6\l__cal_tmpc_dim + 12\l__cal_tmpe_dim + 8\l__cal_tmpg_dim)/27}}
    {\dim_eval:n {(\l__cal_tmpb_dim + 6\l__cal_tmpd_dim + 12\l__cal_tmpf_dim + 8\l__cal_tmph_dim)/27}}
  }

  \tl_put_right:NV #1 \g__spath_curvetoa_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(\l__cal_tmpc_dim + 4\l__cal_tmpe_dim + 4\l__cal_tmpg_dim)/9}}
    {\dim_eval:n {(\l__cal_tmpd_dim + 4\l__cal_tmpf_dim + 4\l__cal_tmph_dim)/9}}
  }

  \tl_put_right:NV #1 \g__spath_curvetob_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(\l__cal_tmpe_dim + 2\l__cal_tmpg_dim)/3}}
    {\dim_eval:n {(\l__cal_tmpf_dim + 2\l__cal_tmph_dim)/3}}
  }

  \tl_put_right:NV #1 \g__spath_curveto_tl

  \tl_put_right:Nx #1 {
    {\dim_use:N \l__cal_tmpg_dim}
    {\dim_use:N \l__cal_tmph_dim}
  }

}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cal_maybe_taper:N}
% Possibly tapers the path, depending on the booleans.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_maybe_taper:N #1
{
  \tl_set_eq:NN \l__cal_tmpa_tl #1

  \bool_if:NT \l__cal_taper_start_bool
  {

    \dim_set:Nn \l__cal_tmpa_dim {\tl_item:Nn \l__cal_tmpa_tl {2}}
    \dim_set:Nn \l__cal_tmpb_dim {\tl_item:Nn \l__cal_tmpa_tl {3}}
    \tl_set:Nx \l__cal_tmpb_tl {\tl_item:Nn \l__cal_tmpa_tl {4}}

    \tl_case:Nnn \l__cal_tmpb_tl
    {
      \g__spath_lineto_tl
      {

        \bool_set_true:N \l__cal_taperable_bool
        \dim_set:Nn \l__cal_tmpg_dim {\tl_item:Nn \l__cal_tmpa_tl {5}}
        \dim_set:Nn \l__cal_tmph_dim {\tl_item:Nn \l__cal_tmpa_tl {6}}
        \dim_set:Nn \l__cal_tmpc_dim {(2\l__cal_tmpa_dim + \l__cal_tmpg_dim)/3}
        \dim_set:Nn \l__cal_tmpd_dim {(2\l__cal_tmpb_dim + \l__cal_tmph_dim)/3}
        \dim_set:Nn \l__cal_tmpe_dim {(\l__cal_tmpa_dim + 2\l__cal_tmpg_dim)/3}
        \dim_set:Nn \l__cal_tmpf_dim {(\l__cal_tmpb_dim + 2\l__cal_tmph_dim)/3}
        \prg_replicate:nn {4}
        {
          \tl_set:Nx \l__cal_tmpa_tl {\tl_tail:N \l__cal_tmpa_tl}
        }
        \tl_put_left:NV \l__cal_tmpa_tl \g__spath_moveto_tl
      }
      \g__spath_curvetoa_tl
      {
        \bool_set_true:N \l__cal_taperable_bool
        \dim_set:Nn \l__cal_tmpc_dim {\tl_item:Nn \l__cal_tmpa_tl {5}}
        \dim_set:Nn \l__cal_tmpd_dim {\tl_item:Nn \l__cal_tmpa_tl {6}}
        \dim_set:Nn \l__cal_tmpe_dim {\tl_item:Nn \l__cal_tmpa_tl {8}}
        \dim_set:Nn \l__cal_tmpf_dim {\tl_item:Nn \l__cal_tmpa_tl {9}}
        \dim_set:Nn \l__cal_tmpg_dim {\tl_item:Nn \l__cal_tmpa_tl {11}}
        \dim_set:Nn \l__cal_tmph_dim {\tl_item:Nn \l__cal_tmpa_tl {12}}
        \prg_replicate:nn {10}
        {
          \tl_set:Nx \l__cal_tmpa_tl {\tl_tail:N \l__cal_tmpa_tl}
        }
        \tl_put_left:NV \l__cal_tmpa_tl \g__spath_moveto_tl
      }
    }
    {
      \bool_set_false:N \l__cal_taperable_bool
    }
    
    \bool_if:NT \l__cal_taperable_bool
    {
      \__cal_taper_aux:
    }
    
  }

  \bool_if:NT \l__cal_taper_end_bool
  {

    \dim_set:Nn \l__cal_tmpa_dim {\tl_item:Nn \l__cal_tmpa_tl {-2}}
    \dim_set:Nn \l__cal_tmpb_dim {\tl_item:Nn \l__cal_tmpa_tl {-1}}
    \tl_set:Nx \l__cal_tmpb_tl {\tl_item:Nn \l__cal_tmpa_tl {-3}}

    \tl_case:Nnn \l__cal_tmpb_tl
    {
      \g__spath_lineto_tl
      {

        \bool_set_true:N \l__cal_taperable_bool
        \dim_set:Nn \l__cal_tmpg_dim {\tl_item:Nn \l__cal_tmpa_tl {-5}}
        \dim_set:Nn \l__cal_tmph_dim {\tl_item:Nn \l__cal_tmpa_tl {-4}}
        \dim_set:Nn \l__cal_tmpc_dim {(2\l__cal_tmpa_dim + \l__cal_tmpg_dim)/3}
        \dim_set:Nn \l__cal_tmpd_dim {(2\l__cal_tmpb_dim + \l__cal_tmph_dim)/3}
        \dim_set:Nn \l__cal_tmpe_dim {(\l__cal_tmpa_dim + 2\l__cal_tmpg_dim)/3}
        \dim_set:Nn \l__cal_tmpf_dim {(\l__cal_tmpb_dim + 2\l__cal_tmph_dim)/3}
        \tl_reverse:N \l__cal_tmpa_tl
        \prg_replicate:nn {3}
        {
          \tl_set:Nx \l__cal_tmpa_tl {\tl_tail:N \l__cal_tmpa_tl}
        }
        \tl_reverse:N \l__cal_tmpa_tl
      }
      \g__spath_curveto_tl
      {
        \bool_set_true:N \l__cal_taperable_bool
        \dim_set:Nn \l__cal_tmpc_dim {\tl_item:Nn \l__cal_tmpa_tl {-5}}
        \dim_set:Nn \l__cal_tmpd_dim {\tl_item:Nn \l__cal_tmpa_tl {-4}}
        \dim_set:Nn \l__cal_tmpe_dim {\tl_item:Nn \l__cal_tmpa_tl {-8}}
        \dim_set:Nn \l__cal_tmpf_dim {\tl_item:Nn \l__cal_tmpa_tl {-7}}
        \dim_set:Nn \l__cal_tmpg_dim {\tl_item:Nn \l__cal_tmpa_tl {-11}}
        \dim_set:Nn \l__cal_tmph_dim {\tl_item:Nn \l__cal_tmpa_tl {-10}}
        \tl_reverse:N \l__cal_tmpa_tl
        \prg_replicate:nn {9}
        {
          \tl_set:Nx \l__cal_tmpa_tl {\tl_tail:N \l__cal_tmpa_tl}
        }
        \tl_reverse:N \l__cal_tmpa_tl
      }
    }
    {
      \bool_set_false:N \l__cal_taperable_bool
    }
    
    \bool_if:NT \l__cal_taperable_bool
    {
      \__cal_taper_aux:
    }
    
  }

  \pgfsyssoftpath@setcurrentpath\l__cal_tmpa_tl
  \pgfsetstrokecolor{\pgfkeysvalueof{/tikz/pen~colour}}
  \pgfusepath{stroke}

}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\__cal_taper_aux:}
% Auxiliary macro to avoid unnecessary code duplication.
%    \begin{macrocode}
\cs_new_nopar:Npn \__cal_taper_aux:
{
  \tl_clear:N \l__cal_tmpb_tl
  \tl_put_right:NV \l__cal_tmpb_tl \g__spath_moveto_tl

  \fp_set:Nn \l__cal_tmpa_fp
  {
    \l__cal_tmpd_dim - \l__cal_tmpb_dim
  }
  \fp_set:Nn \l__cal_tmpb_fp
  {
    \l__cal_tmpa_dim - \l__cal_tmpc_dim
  }
  \fp_set:Nn \l__cal_tmpe_fp
  {
    (\l__cal_tmpa_fp^2 + \l__cal_tmpb_fp^2)^.5
  }
  
  \fp_set:Nn \l__cal_tmpa_fp {.5*\l__cal_taper_width_dim *     \l__cal_tmpa_fp / \l__cal_tmpe_fp}
  \fp_set:Nn \l__cal_tmpb_fp {.5*\l__cal_taper_width_dim *     \l__cal_tmpb_fp / \l__cal_tmpe_fp}

  \fp_set:Nn \l__cal_tmpc_fp
  {
    \l__cal_tmph_dim - \l__cal_tmpf_dim
  }
  \fp_set:Nn \l__cal_tmpd_fp
  {
    \l__cal_tmpe_dim - \l__cal_tmpg_dim
  }
  \fp_set:Nn \l__cal_tmpe_fp
  {
    (\l__cal_tmpc_fp^2 + \l__cal_tmpd_fp^2)^.5
  }

  \fp_set:Nn \l__cal_tmpc_fp {.5*\l__cal_line_width_dim * \l__cal_tmpc_fp / \l__cal_tmpe_fp}
  \fp_set:Nn \l__cal_tmpd_fp {.5*\l__cal_line_width_dim * \l__cal_tmpd_fp / \l__cal_tmpe_fp}

  \tl_put_right:Nx \l__cal_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpa_fp + \l__cal_tmpa_dim}}
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpb_fp +             \l__cal_tmpb_dim}}
  }

  \tl_put_right:NV \l__cal_tmpb_tl \g__spath_curvetoa_tl

  \tl_put_right:Nx \l__cal_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpa_fp + \l__cal_tmpc_dim}}
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpb_fp + \l__cal_tmpd_dim}}
  }

  \tl_put_right:NV \l__cal_tmpb_tl \g__spath_curvetob_tl

  \tl_put_right:Nx \l__cal_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpc_fp + \l__cal_tmpe_dim}}
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpd_fp + \l__cal_tmpf_dim}}
  }

  \tl_put_right:NV \l__cal_tmpb_tl \g__spath_curveto_tl
  
  \tl_put_right:Nx \l__cal_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpc_fp + \l__cal_tmpg_dim}}
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpd_fp + \l__cal_tmph_dim}}
  }

  \tl_put_right:NV \l__cal_tmpb_tl \g__spath_curvetoa_tl

  \tl_put_right:Nx \l__cal_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpc_fp + \l__cal_tmpg_dim - \fp_to_dim:n{ 1.32 * \l__cal_tmpd_fp}}}
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpd_fp + \l__cal_tmph_dim + \fp_to_dim:n {1.32* \l__cal_tmpc_fp}}}
  }

  \tl_put_right:NV \l__cal_tmpb_tl \g__spath_curvetob_tl

  \tl_put_right:Nx \l__cal_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l__cal_tmpc_fp + \l__cal_tmpg_dim - \fp_to_dim:n {1.32 * \l__cal_tmpd_fp}}}
    {\dim_eval:n { -\fp_to_dim:N \l__cal_tmpd_fp + \l__cal_tmph_dim + \fp_to_dim:n {1.32 * \l__cal_tmpc_fp}}}
  }

  \tl_put_right:NV \l__cal_tmpb_tl \g__spath_curveto_tl

  \tl_put_right:Nx \l__cal_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l__cal_tmpc_fp + \l__cal_tmpg_dim}}
    {\dim_eval:n { -\fp_to_dim:N \l__cal_tmpd_fp + \l__cal_tmph_dim}}
  }

  \tl_put_right:NV \l__cal_tmpb_tl \g__spath_curvetoa_tl

  \tl_put_right:Nx \l__cal_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l__cal_tmpc_fp + \l__cal_tmpe_dim}}
    {\dim_eval:n { -\fp_to_dim:N \l__cal_tmpd_fp + \l__cal_tmpf_dim}}
  }

  \tl_put_right:NV \l__cal_tmpb_tl \g__spath_curvetob_tl

  \tl_put_right:Nx \l__cal_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l__cal_tmpa_fp + \l__cal_tmpc_dim}}
    {\dim_eval:n { -\fp_to_dim:N \l__cal_tmpb_fp + \l__cal_tmpd_dim}}
  }

  \tl_put_right:NV \l__cal_tmpb_tl \g__spath_curveto_tl

  \tl_put_right:Nx \l__cal_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l__cal_tmpa_fp + \l__cal_tmpa_dim}}
    {\dim_eval:n { -\fp_to_dim:N \l__cal_tmpb_fp + \l__cal_tmpb_dim}}
  }

  \tl_put_right:NV \l__cal_tmpb_tl \g__spath_curvetoa_tl

  \tl_put_right:Nx \l__cal_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l__cal_tmpa_fp + \l__cal_tmpa_dim + \fp_to_dim:n{ 1.32 * \l__cal_tmpb_fp}}}
    {\dim_eval:n { -\fp_to_dim:N \l__cal_tmpb_fp + \l__cal_tmpb_dim - \fp_to_dim:n {1.32* \l__cal_tmpa_fp}}}
  }

  \tl_put_right:NV \l__cal_tmpb_tl \g__spath_curvetob_tl

  \tl_put_right:Nx \l__cal_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpa_fp + \l__cal_tmpa_dim + \fp_to_dim:n {1.32 * \l__cal_tmpb_fp}}}
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpb_fp + \l__cal_tmpb_dim - \fp_to_dim:n {1.32 * \l__cal_tmpa_fp}}}
  }

  \tl_put_right:NV \l__cal_tmpb_tl \g__spath_curveto_tl

  \tl_put_right:Nx \l__cal_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpa_fp + \l__cal_tmpa_dim}}
    {\dim_eval:n { \fp_to_dim:N \l__cal_tmpb_fp +             \l__cal_tmpb_dim}}
  }

  \pgfsyssoftpath@setcurrentpath\l__cal_tmpb_tl
  \pgfsetfillcolor{\pgfkeysvalueof{/tikz/pen~colour}}
  \pgfusepath{fill}
}
%    \end{macrocode}
% \end{macro}
%
% Defines a copperplate pen.
%    \begin{macrocode}
\tl_set:Nn \l__cal_tmpa_tl {\pgfsyssoftpath@movetotoken{0pt}{0pt}}
\MakeSPathList{calligraphy pen copperplate}{\l__cal_tmpa_tl}
\SPathListPrepare{calligraphy pen copperplate}
%    \end{macrocode}
%
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
%
% \subsection{Decorations}
%
% If a decoration library is loaded we define some decorations that use the calligraphy library, specifically the copperplate pen with its tapering.
%
% First, a brace decoration.
%    \begin{macrocode}
\expandafter\ifx\csname pgfdeclaredecoration\endcsname\relax
\else
\pgfdeclaredecoration{calligraphic brace}{brace}
{
  \state{brace}[width=+\pgfdecoratedremainingdistance,next state=final]
  {
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}
    \pgfpathmoveto{\pgfpointorigin}
    \pgfpathcurveto
    {\pgfqpoint{.15\pgfdecorationsegmentamplitude}{.3\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
    {
      \pgftransformxshift{+\pgfdecorationsegmentaspect\pgfdecoratedremainingdistance}
      \pgfpathlineto{\pgfqpoint{-\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{-.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{-.15\pgfdecorationsegmentamplitude}{.7\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{0\pgfdecorationsegmentamplitude}{1\pgfdecorationsegmentamplitude}}
      \pgfpathmoveto{\pgfqpoint{0\pgfdecorationsegmentamplitude}{1\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{.15\pgfdecorationsegmentamplitude}{.7\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
    }
    {
      \pgftransformxshift{+\pgfdecoratedremainingdistance}
      \pgfpathlineto{\pgfqpoint{-\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{-.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{-.15\pgfdecorationsegmentamplitude}{.3\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{0pt}{0pt}}
    }
    \tikzset{
      taper width=.5\pgflinewidth,
      taper
    }%
    \pgfsyssoftpath@getcurrentpath\cal@tmp@path
    \MakeSPathList{calligraphy path}{\cal@tmp@path}%
    \SPathListPrepare{calligraphy path}%
    \CalligraphyPathCreate{calligraphy path}{copperplate}%
  }
  \state{final}{}
}
%    \end{macrocode}
%
% The second is a straightened parenthesis (so that when very large it doesn't bow out too far).
%    \begin{macrocode}
\pgfdeclaredecoration{calligraphic straight parenthesis}{brace}
{
  \state{brace}[width=+\pgfdecoratedremainingdistance,next state=final]
  {
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}
    \pgfpathmoveto{\pgfpointorigin}
    \pgfpathcurveto
    {\pgfqpoint{.76604\pgfdecorationsegmentamplitude}{.64279\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{2.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{3.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
    {
      \pgftransformxshift{+\pgfdecoratedremainingdistance}
      \pgfpathlineto{\pgfqpoint{-3.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{-2.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{-.76604\pgfdecorationsegmentamplitude}{.64279\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{0pt}{0pt}}
    }
    \tikzset{
      taper width=.5\pgflinewidth,
      taper
    }%
    \pgfsyssoftpath@getcurrentpath\cal@tmp@path
    \MakeSPathList{calligraphy path}{\cal@tmp@path}%
    \SPathListPrepare{calligraphy path}%
    \CalligraphyPathCreate{calligraphy path}{copperplate}%
  }
  \state{final}{}%
}
%    \end{macrocode}
%
% The third is a curved parenthesis.
%    \begin{macrocode}
\pgfdeclaredecoration{calligraphic curved parenthesis}{brace}
{
  \state{brace}[width=+\pgfdecoratedremainingdistance,next state=final]
  {
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}
    \pgfpathmoveto{\pgfpointorigin}
    \pgf@xa=\pgfdecoratedremainingdistance\relax
    \advance\pgf@xa by -1.5890\pgfdecorationsegmentamplitude\relax
    \edef\cgrphy@xa{\the\pgf@xa}
    \pgfpathcurveto
    {\pgfqpoint{1.5890\pgfdecorationsegmentamplitude}{1.3333\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{\cgrphy@xa}{1.3333\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{\pgfdecoratedremainingdistance}{0pt}}
    \tikzset{
      taper width=.5\pgflinewidth,
      taper
    }%
    \pgfsyssoftpath@getcurrentpath\cal@tmp@path
    \MakeSPathList{calligraphy path}{\cal@tmp@path}%
    \SPathListPrepare{calligraphy path}%
    \CalligraphyPathCreate{calligraphy path}{copperplate}%
  }
  \state{final}{}%
}
%    \end{macrocode}
% End the conditional for if pgfdecoration module is loaded
%    \begin{macrocode}
\fi
%    \end{macrocode}
% \iffalse
%</calligraphy>
% \fi
% 
%
% \iffalse
%<*knots>
% \fi
%%
% \section{Drawing Knots}
%
%
% \subsection{Initialisation}
%
% Test the version of PGF to see if it's what we expect.
% If not, issue a warning (but continue anyway; after all, it \emph{might just work}).
%    \begin{macrocode}
\def\knot@pgfversion{2.10}%
\ifx\pgfversion\knot@pgfversion
\else
\PackageWarning{knots}{This package was designed using PGF2.10; you are using \pgfversion.}%
\fi

\RequirePackage{spath3}
\usetikzlibrary{intersections}

\ExplSyntaxOn

\tl_new:N \l__knot_tmpa_tl
\tl_new:N \l__knot_tmpb_tl
\tl_new:N \l__knot_tmpc_tl
\tl_new:N \l__knot_tmpd_tl
\tl_new:N \l__knot_tmpe_tl
\tl_new:N \l__knot_tmpf_tl
\tl_new:N \l__knot_tmpg_tl
\tl_new:N \l__knot_redraws_tl
\tl_new:N \l__knot_clip_width_tl

\int_new:N \l__knot_strands_int
\int_new:N \l__knot_intersections_int

\dim_new:N \l__knot_tmpa_dim
\dim_new:N \l__knot_tmpb_dim
\dim_new:N \l__knot_tmpc_dim
\dim_new:N \l__knot_tolerance_dim
\dim_new:N \l__knot_clip_radius_dim

\bool_new:N \l__knot_draft_bool
\bool_new:N \l__knot_ignore_ends_bool
\bool_new:N \l__knot_self_intersections_bool
\bool_new:N \l__knot_splits_bool
\bool_new:N \l__knot_super_draft_bool

\bool_new:N \l__knot_prepend_prev_bool
\bool_new:N \l__knot_append_next_bool

\bool_set_true:N \l__knot_ignore_ends_bool

\tikzset{
  save~knot~path/.code={
    \tikz@addmode{
      \pgfsyssoftpath@getcurrentpath\l__knot_tmpa_tl
      \MakeSPath{#1}{\l__knot_tmpa_tl}
    }
  },
  restore~knot~path/.code={
    \SPathInfoInto{#1}{min bb}{\l__knot_tmpa_tl}
    \exp_last_unbraced:NV \pgf@protocolsizes \l__knot_tmpa_tl
    \SPathInfoInto{#1}{maxbb}{\l__knot_tmpa_tl}
    \exp_last_unbraced:NV \pgf@protocolsizes \l__knot_tmpa_tl
    \SPathInfoInto{#1}{path}{\l__knot_tmpa_tl}
    \pgfsyssoftpath@setcurrentpath\l__knot_tmpa_tl
  },
  knot/.is~family,
  knot/.unknown/.code={%
    \tl_set:NN \l__knot_tmpa_tl \pgfkeyscurrentname
    \pgfkeysalso{%
      /tikz/\l__knot_tmpa_tl=#1
    }
  },
  knot,
  every~ strand/.style={},
  only~ when~ rendering/.style={},
  ignore~ endpoint~ intersections/.code={
    \tl_if_eq:nnTF {#1} {true}
    {
      \bool_set_true:N \l__knot_ignore_ends_bool
    }
    {
      \bool_set_false:N \l__knot_ignore_ends_bool
    }
  },
  ignore~ endpoint~ intersections/.default=true,
  consider~ self~ intersections/.is~choice,
  consider~ self~ intersections/true/.code={
    \bool_set_true:N \l__knot_self_intersections_bool
    \bool_set_true:N \l__knot_splits_bool
  },
  consider~ self~ intersections/false/.code={
    \bool_set_false:N \l__knot_self_intersections_bool
    \bool_set_false:N \l__knot_splits_bool
  },
  consider~ self~ intersections/no~ splits/.code={
    \bool_set_true:N \l__knot_self_intersections_bool
    \bool_set_false:N \l__knot_splits_bool
  },
  clip~ radius/.code={
    \dim_set:Nn \l__knot_clip_radius_dim {#1}
  },
  clip~ radius=10pt,
  end~ tolerance/.code={
    \dim_set:Nn \l__knot_tolerance_dim {#1}
  },
  end~ tolerance=14pt,
  clip~ width/.code={
    \tl_set:Nn \l__knot_clip_width_tl {#1}
  },
  clip~ width=3,
  flip~ crossing/.code={%
    \tl_clear_new:c {l__knot_crossing_#1}
    \tl_set:cn {l__knot_crossing_#1} {x}
  },
  background~ colour/.code={%
    \colorlet{knot@bg}{#1}%
  },
  background~ color/.code={%
    \colorlet{knot@bg}{#1}%
  },
  background~ colour=white,
  draft~ mode/.is~ choice,
  draft~ mode/off/.code={%
    \bool_set_false:N \l__knot_draft_bool
    \bool_set_false:N \l__knot_super_draft_bool
  },
  draft~ mode/crossings/.code={%
    \bool_set_true:N \l__knot_draft_bool
    \bool_set_false:N \l__knot_super_draft_bool
  },
  draft~ mode/strands/.code={%
    \bool_set_true:N \l__knot_draft_bool
    \bool_set_true:N \l__knot_super_draft_bool
  },
  draft/.is~ family,
  draft,
  clip~ radius/.initial=10pt,
  crossing~ label/.style={
    fill=white,
    fill~ opacity=.5,
    text~ opacity=1,
    text=blue,
    anchor=south~ east,
    append~ after~ command={
      (\tikzlastnode.center) edge[blue,->] (\tikzlastnode.south~ east)
    }
  },
  strand~ label/.style={
    overlay,
    circle,
    draw=purple,
    fill=white,
    fill~ opacity=.5,
    text~ opacity=1,
    text=purple,
    inner~ sep=0pt
  },
}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_nopar:Npn \knot_apply_style:N #1
{
  \tl_if_exist:NT #1 {
    \exp_args:NV \tikzset #1
  }
}
\cs_generate_variant:Nn \knot_apply_style:N {c}


\NewDocumentCommand \flipcrossings {m}
{
  \tikzset{knot/flip~ crossing/.list={#1}}%
}

\NewDocumentCommand \strand { O{} }
{
  \int_incr:N \l__knot_strands_int
  \tl_clear_new:c {l__knot_options_ \int_use:N \l__knot_strands_int}
  \tl_set:cn {l__knot_options_ \int_use:N \l__knot_strands_int} {#1}
  \path[#1,save~ knot~ path=knot strand \int_use:N  \l__knot_strands_int]
}

\NewDocumentEnvironment{knot} { O{} }
{
  \tikzset{knot/.cd,#1}
  \int_zero:N \l__knot_strands_int
  \tl_clear:N \l__knot_redraws_tl
}
{
  \pgfscope
  \pgftransformreset
  \int_step_variable:nnnNn {1} {1} {\l__knot_strands_int} \l__knot_tmpa_tl
  {
    \pgfscope
    \group_begin:
    \tikzset{knot/every~ strand/.try}
    \knot_apply_style:c {l__knot_options_ \tl_use:N \l__knot_tmpa_tl}
    \tikzset{knot/only~ when~ rendering}
    \spath_get:nnN {knot strand \tl_use:N  \l__knot_tmpa_tl} {min bb} \l__knot_tmpb_tl
    \exp_last_unbraced:NV \pgf@protocolsizes\l__knot_tmpb_tl
    \spath_get:nnN {knot strand \tl_use:N  \l__knot_tmpa_tl} {max bb} \l__knot_tmpb_tl
    \exp_last_unbraced:NV \pgf@protocolsizes\l__knot_tmpb_tl
    \spath_get:nnN {knot strand \tl_use:N  \l__knot_tmpa_tl} {path} \l__knot_tmpb_tl
    \pgfsyssoftpath@setcurrentpath\l__knot_tmpb_tl
    \tikz@options
    \pgfusepath{stroke}
    \group_end:
    \endpgfscope
  }

  \bool_if:NF \l__knot_super_draft_bool
  {
    \int_step_variable:nnnNn {1} {1} {\l__knot_strands_int} \l__knot_tmpa_tl
    {
      \bool_if:NT \l__knot_draft_bool
      {
        \spath_get:nnN {knot strand \tl_use:N \l__knot_tmpa_tl} {final point} \l__knot_tmpb_tl
        \dim_set:Nn \l__knot_tmpa_dim {\tl_item:Nn \l__knot_tmpb_tl {1}}
        \dim_set:Nn \l__knot_tmpb_dim {\tl_item:Nn \l__knot_tmpb_tl {2}}
        \node[knot/draft/strand~label] at (\l__knot_tmpa_dim,\l__knot_tmpb_dim) {\l__knot_tmpa_tl};
        \spath_get:nnN {knot strand \tl_use:N \l__knot_tmpa_tl} {initial point} \l__knot_tmpb_tl
        \dim_set:Nn \l__knot_tmpa_dim {\tl_item:Nn \l__knot_tmpb_tl {1}}
        \dim_set:Nn \l__knot_tmpb_dim {\tl_item:Nn \l__knot_tmpb_tl {2}}
        \node[knot/draft/strand~label] at        (\l__knot_tmpa_dim,\l__knot_tmpb_dim) {\l__knot_tmpa_tl};
      }
      \bool_if:nT {
        \l__knot_self_intersections_bool
        &&
        \l__knot_splits_bool
      }
      {
        % Do self intersection splits here
      }
    }

  \bool_if:NT \l__knot_self_intersections_bool
  {
    % Split strands into components
    % Need to hang on to the originals for redraws ... hmmm
  }
  \int_gzero:N \l__knot_intersections_int
  \int_step_variable:nnnNn {1} {1} {\l__knot_strands_int - 1} \l__knot_tmpa_tl
  {
    \int_step_variable:nnnNn {\tl_use:N \l__knot_tmpa_tl + 1} {1} {\l__knot_strands_int} \l__knot_tmpb_tl
{
  \spath_get:nnN {knot strand \tl_use:N \l__knot_tmpa_tl} {path} \l__knot_tmpc_tl
  \spath_get:nnN {knot strand \tl_use:N \l__knot_tmpb_tl} {path} \l__knot_tmpd_tl

  \pgfintersectionofpaths{\pgfsetpath\l__knot_tmpc_tl}{\pgfsetpath\l__knot_tmpd_tl}

  \int_compare:nT {\pgfintersectionsolutions > 0}
  {
    \int_step_variable:nnnNn {1} {1} {\pgfintersectionsolutions} \l__knot_tmpc_tl
    {
      \pgfpointintersectionsolution{\l__knot_tmpc_tl}
      \dim_set:Nn \l__knot_tmpa_dim {\pgf@x}
      \dim_set:Nn \l__knot_tmpb_dim {\pgf@y}

      \int_compare:nTF {\l__knot_tmpa_tl + 1 == \l__knot_tmpb_tl} 
      {
        \spath_get:nnN {knot strand \tl_use:N \l__knot_tmpa_tl} {final point} \l__knot_tmpd_tl
        \spath_get:nnN {knot strand \tl_use:N \l__knot_tmpb_tl} {initial point} \l__knot_tmpe_tl
        \bool_set:Nn \l__knot_skip_bool
        {
          \dim_compare_p:n
          {
            \dim_abs:n {\pgf@x - \tl_item:Nn \l__knot_tmpd_tl {1}}
            +
            \dim_abs:n {\pgf@y - \tl_item:Nn \l__knot_tmpd_tl {2}}
            <
            \l__knot_tolerance_dim
          }
          &&
          \dim_compare_p:n
          {
            \dim_abs:n {\pgf@x - \tl_item:Nn \l__knot_tmpe_tl {1}}
            +
            \dim_abs:n {\pgf@y - \tl_item:Nn \l__knot_tmpe_tl {2}}
            <
            \l__knot_tolerance_dim
          }
        }
      }
      {
        \bool_set_false:N \l__knot_skip_bool
      }

      \bool_if:NF \l__knot_skip_bool
      {

      % Need to use the above booleans if we've exploded our paths
      % which we haven't implemented as yet ...
        \int_gincr:N \l__knot_intersections_int
        \bool_if:nTF
        {
          \tl_if_exist_p:c {l__knot_crossing_ \int_use:N
            \l__knot_intersections_int}
          &&
          ! \tl_if_empty_p:c {l__knot_crossing_ \int_use:N
            \l__knot_intersections_int}
        }
        {
          \tl_set_eq:NN \l__knot_tmpg_tl \l__knot_tmpb_tl
        }
        {
          \tl_set_eq:NN \l__knot_tmpg_tl \l__knot_tmpa_tl
        }

        \spath_get:nnN {knot strand \tl_use:N \l__knot_tmpg_tl} {initial point} \l__knot_tmpd_tl
        \bool_set:Nn \l__knot_prepend_prev_bool
        {
          \dim_compare_p:n
          {
            \dim_abs:n {\pgf@x - \tl_item:Nn \l__knot_tmpd_tl {1}}
            +
            \dim_abs:n {\pgf@y - \tl_item:Nn \l__knot_tmpd_tl {2}}
            <
            \l__knot_tolerance_dim
          }
        }

        \spath_get:nnN {knot strand \tl_use:N \l__knot_tmpg_tl} {final point} \l__knot_tmpd_tl
        \bool_set:Nn \l__knot_append_next_bool
        {
          \dim_compare_p:n
          {
            \dim_abs:n {\pgf@x - \tl_item:Nn \l__knot_tmpd_tl {1}}
            +
            \dim_abs:n {\pgf@y - \tl_item:Nn \l__knot_tmpd_tl {2}}
            <
            \l__knot_tolerance_dim
          }
        }

        \bool_if:nT
        {
          \l__knot_prepend_prev_bool || \l__knot_append_next_bool
        }
        {

          \spath_clone:nn {knot strand \tl_use:N \l__knot_tmpg_tl}
          {knot strand -1}
          \tl_set_eq:cc {l__knot_options_ \tl_use:N \l__knot_tmpg_tl} {l__knot_options_ -1}

          \bool_if:NT \l__knot_prepend_prev_bool
          {
            \spath_prepend_no_move:nn {knot strand -1} {knot strand
            \int_eval:n {\tl_use:N \l__knot_tmpg_tl - 1}}
          }

          \bool_if:NT \l__knot_append_next_bool
          {
            \spath_append_no_move:nn {knot strand -1} {knot strand
            \int_eval:n {\tl_use:N \l__knot_tmpg_tl + 1}}
          }

          \tl_set:Nn \l__knot_tmpg_tl {-1}
        }

        \knot_draw_crossing:VVV \l__knot_tmpg_tl \l__knot_tmpa_dim \l__knot_tmpb_dim
        \bool_if:NT \l__knot_draft_bool
        {
          \node[knot/draft/crossing~ label] at (\l__knot_tmpa_dim, \l__knot_tmpb_dim) {\int_use:N  \l__knot_intersections_int};
        }
      }
    }
  }
}
  }
  \tl_use:N \l__knot_redraws_tl
  }
  \endpgfscope
}


\cs_new_nopar:Npn \knot_draw_crossing:nnn #1#2#3
{
  \group_begin:
  \pgfscope
  \clip (#2, #3) circle[radius=\l__knot_clip_radius_dim];

  \tikzset{draw,knot/every~ strand/.try}
  \knot_apply_style:c {l__knot_options_ #1}
  \tikzset{knot@bg,line~ width= \tl_use:N \l__knot_clip_width_tl * \pgflinewidth}

  \spath_get:nnN {knot strand #1} {path} \l__knot_tmpd_tl
  \pgfsyssoftpath@setcurrentpath\l__knot_tmpd_tl
  \tikz@options
  \pgfusepath{stroke}

  \endpgfscope

  \pgfscope
  \clip (#2, #3) circle[radius=1.1\l__knot_clip_radius_dim];

  \tikzset{draw,knot/every~ strand/.try}
  \knot_apply_style:c {l__knot_options_ #1}
  \tikzset{knot/only~ when~ rendering}

  \spath_get:nnN {knot strand #1} {path} \l__knot_tmpd_tl
  \pgfsyssoftpath@setcurrentpath\l__knot_tmpd_tl
  \tikz@options
  \pgfusepath{stroke}

  \endpgfscope
  \group_end:
}

\cs_generate_variant:Nn \knot_draw_crossing:nnn {VVV}

\NewDocumentCommand \redraw { m m }
{
  \tikz@scan@one@point\pgfutil@firstofone #2 \relax
  \tl_put_right:Nn \l__knot_redraws_tl {\knot_draw_crossing:nnn}
  \tl_put_right:Nx \l__knot_redraws_tl {
    {#1} {\dim_use:N \pgf@x} {\dim_use:N \pgf@y}
  }
}

\ExplSyntaxOff

%    \end{macrocode}
% \iffalse
%</knots>
% \fi
%\Finale
\endinput
