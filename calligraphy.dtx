% \iffalse meta-comment
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
calligraphy --- a style file for doing calligraphy with TikZ/PGF
E-mail: stacey@math.ntnu.no
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package defines a way of simulating calligraphic lines with TikZ/PGF.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
calligraphy --- a style file for doing calligraphy with TikZ/PGF
E-mail: stacey@math.ntnu.no
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2011 by Andrew Stacey <stacey@math.ntnu.no>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Andrew Stacey.

This work consists of the file  calligraphy.dtx
and the derived files           calligraphy.ins,
                                calligraphy.pdf, and
                                calligraphy.sty.

\endpostamble
\usedir{tex/latex/calligraphy}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/calligraphy}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/demopkg}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*package>
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{calligraphy}[2011/05/19 v1.0 Calligraphic commands with TikZ]
%</package>
%<*driver>
\documentclass{ltxdoc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
%\usepackage{morefloats}
\usepackage{tikz}
\usepackage{\jobname}
\usepackage[numbered]{hypdoc}
\definecolor{lstbgcolor}{rgb}{0.9,0.9,0.9} 
 
\usepackage{listings}
\lstloadlanguages{[LaTeX]TeX}
\lstset{breakatwhitespace=true,breaklines=true,language=TeX}
 
\usepackage{fancyvrb}

\newenvironment{example}
  {\VerbatimEnvironment
   \begin{VerbatimOut}[gobble=2]{example.out}}
  {\end{VerbatimOut}
   \begin{center}
%   \setlength{\parindent}{0pt}
   \fbox{\begin{minipage}{.9\linewidth}
     \lstset{breakatwhitespace=true,breaklines=true,language=TeX,basicstyle=\small}
     \lstinputlisting[]{example.out}
   \end{minipage}}

   \fbox{\begin{minipage}{.9\linewidth}
     \input{example.out}
   \end{minipage}}
\end{center}
}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{1.0}{2011/05/03}{Converted to DTX file}
%
% \DoNotIndex{\newcommand,\newenvironment}
%
% \providecommand*{\url}{\texttt}
% \GetFileInfo{calligraphy.dtx}
% \title{The \textsf{calligraphy} package}
% \author{Andrew Stacey \\ \url{stacey@math.ntnu.no}}
% \date{\fileversion~from \filedate}
%
%
% \maketitle
%
% 
% \section{Introduction}
% 
% The \Verb+calligraphy+ package is designed to enable calligraphic style drawings in TikZ.
% The idea is to be able to ``stroke'' a line with a ``pen''.
% As a simple example, compare the two lines in the following picture.
% 
% \begin{example}
% \begin{center}
% \begin{tikzpicture}
% \pen (-135:.25) -- (45:.25);
% \draw[line width=.5cm] (0,0) .. controls +(45:1) and +(-135:1) .. ++(3,0);
% \calligraphy (0,-1) .. controls +(45:1) and +(-135:1) .. ++(3,0);
% \end{tikzpicture}
% \end{center}
% \end{example}
% 
% The paths are identical in definition but the first is drawn using the standard TikZ path with a line width of .5cm.
% The second is ``stroked'' with a calligraphic pen of width .5cm angled at 45 degrees.
% 
%
% \StopEventually{}
%
% \section{Implementation}
%
% \iffalse
%<*package>
% \fi
%
% This package depends on the \texttt{spath} library for soft path manipulations.
%    \begin{macrocode}
\ProvidesPackage{calligraphy}
\RequirePackage{spath}
%    \end{macrocode}
%
% We start with some initialisation stuff.
% We have some \Verb+\if+s: one for whether we annotate our paths, one for whether we taper the start (of a copperplate path), and one for whether we taper the end.
% We also have some counters: the labels (for annotating the strokes), the nibs, and the parts of paths.
% These latter two are used for styling parts of paths and nibs.
%    \begin{macrocode}
\newif\ifcalligraphy@annotate
\newif\ifcgrphy@taper@start
\newif\ifcgrphy@taper@end
\cgrphy@taper@starttrue
\cgrphy@taper@endtrue
\newcounter{cgrphy@label}
\newcounter{cgrphy@nib}
\newcounter{cgrphy@path@parts}
%    \end{macrocode}
% Now we set all our \Verb+pgfkeys+.
%    \begin{macrocode}
\pgfkeys{
%    \end{macrocode}
% Often need to declare a path without wanting it to be included in the bounding box (for example, when defining a pen).
%    \begin{macrocode}
  /tikz/irrelevant for bounding box/.code={
    \pgf@relevantforpicturesizefalse
  },
%    \end{macrocode}
% Our ``home directory'' is \Verb+/pgf/calligraphy+.
% This ensures that \Verb+calligraphy+ in a TikZ setting switches to our home directory.
%    \begin{macrocode}
  /tikz/calligraphy/.style={
    /pgf/calligraphy/.cd
  },
%    \end{macrocode}
% This is our handler for unknown options.
% First, we check to see if it is a pen name.
% Then, we check to see if it is a colour and if so set the pen colour.
% If neither, we pass it to TikZ and let TikZ handle it.
%    \begin{macrocode}
  /pgf/calligraphy/.unknown/.code={%
    \let\cgrphy@key=\pgfkeyscurrentname%
    \expandafter\ifx\csname calligraphy@pen@\cgrphy@key\endcsname\relax
    \expandafter\pgfutil@in@\expandafter!\expandafter{\cgrphy@key}%
    \ifpgfutil@in@%
\message{It is a colour: \cgrphy@key}%
      \pgfkeyslet{/pgf/calligraphy/pen colour}{\cgrphy@key}%
    \else
    \pgfutil@doifcolorelse{\cgrphy@key}
{
  \pgfkeyslet{/pgf/calligraphy/pen colour}{\cgrphy@key}%
}{
     \pgfkeysalso{%
       /tikz/\cgrphy@key={#1}%
     }
}
    \fi
    \else
      \pgfkeyslet{/pgf/calligraphy/pen name}{\cgrphy@key}%
    \fi
  },
%    \end{macrocode}
% Now we work in our ``home'' directory.
%    \begin{macrocode}
  /pgf/calligraphy/.cd,
%    \end{macrocode}
% This is the style used for defining a pen.
%    \begin{macrocode}
  define pen/.style={
    /tikz/irrelevant for bounding box,
    pen name=#1,
    save pen,
  },
%    \end{macrocode}
% A pen must always be named, so we use \Verb+default+ if we're not told otherwise.
%    \begin{macrocode}
  pen name/.initial=default,
%    \end{macrocode}
% When saving a pen, we have a little problem with scoping.
% It's easy enough to save the soft path.
% What is a little harder is to process the pen (into an \Verb+spath+ object) since that must be done outside the group used to work on the path.
% So we add a little hook at the end of the path (via \Verb+\tikz@path@do@at@end+) to allow us to actually process the path.
% This involves adding an extra group to ensure that everything happens at the right level.
%    \begin{macrocode}
  save pen/.code={
    \tikz@addmode{\pgfsyssoftpath@getcurrentpath\calligraphy@pen@default
    \expandafter\global\expandafter\let\csname calligraphy@pen@\pgfkeysvalueof{/pgf/calligraphy/pen name}@path\endcsname=\calligraphy@pen@default%
    \pgfkeysgetvalue{/pgf/calligraphy/pen name}{\cgrphy@current@pen}%
    \global\let\cgrphy@current@pen=\cgrphy@current@pen}%
    \def\tikz@path@do@at@end{%
      \endgroup
      \tikz@path@do@at@end
      \processpen[\cgrphy@current@pen]%
    }%
    \begingroup
  },
%    \end{macrocode}
% By default, we use the default pen.
%    \begin{macrocode}
  use pen/.default=default,
%    \end{macrocode}
% This is the code that sets up the path for being stroked by a calligraphic pen.
%    \begin{macrocode}
  use pen/.code={%
    \tikz@addmode{\pgfsyssoftpath@getcurrentpath\calligraphy@main@path
      \global\let\calligraphy@main@path=\calligraphy@main@path}
    \let\pgfpathmoveto=\cgrphy@pathmoveto
    \setcounter{cgrphy@path@parts}{0}%
    \tikz@addmode{\cgrphy@thickenpath{\calligraphy@main@path}{\pgfkeysvalueof{/pgf/calligraphy/pen       name}}}%
  },
%    \end{macrocode}
% Our pen colour is initially black.
%    \begin{macrocode}
  pen colour/.initial=black,
%    \end{macrocode}
% We can annotate paths, thus showing how they were constructed.
% The idea here is to be able to do an instruction booklet.
%    \begin{macrocode}
  annotate/.style={
    annotate if,
    annotate reset
  },
%    \end{macrocode}
% Switch to determine if to annotate or not.
%    \begin{macrocode}
  annotate if/.is if=calligraphy@annotate,
%    \end{macrocode}
% When annotating, we count the pieces of the path so need to reset our counter.
%    \begin{macrocode}
  annotate reset/.code={
    \setcounter{cgrphy@label}{0}
  },
%    \end{macrocode}
% Our initial annotation style is a line with an arrowhead in the direction of the path.
%    \begin{macrocode}
  annotation style/.initial={->},
%    \end{macrocode}
% Our default shift of the annotation is 1ex upwards.
%    \begin{macrocode}
  annotation shift/.initial={(0,1ex)},
%    \end{macrocode}
% Our initial style for the nodes in the annotations, just anchor them nicely.
%    \begin{macrocode}
  annotation nodes style/.initial={anchor=south east},
%    \end{macrocode}
% This allows us to set a style according to which piece of the nib is in use.
%    \begin{macrocode}
  pen nib/.code 2 args={
    \expandafter\def\csname calligraphy@nib@style@#1\endcsname{#2}
  },
%    \end{macrocode}
% This allows us to set an annotation style for a specific component of the path.
%    \begin{macrocode} 
  annotation node style/.code 2 args={
    \expandafter\def\csname calligraphy@annotation@style@#1\endcsname{#2}
  },
%    \end{macrocode}
% This is the overall style for the pen nib.
%    \begin{macrocode}
  pen nib style/.initial={},
%    \end{macrocode}
% When drawing a copperplate stroke, we can choose to draw it with a ``heavy'' stroke or a ``light'' one.
% This also affects the tapering.
%    \begin{macrocode}
  weight/.is choice,
  weight/heavy/.style={
    line width=\pgfkeysvalueof{/pgf/calligraphy/heavy line width},
    taper line width=\pgfkeysvalueof{/pgf/calligraphy/light line width},
  },
  weight/light/.style={
    line width=\pgfkeysvalueof{/pgf/calligraphy/light line width},
    taper line width=0pt,
  },
  heavy/.style={
    weight=heavy
  },
  light/.style={
    weight=light
  },
  heavy line width/.initial=2pt,
  light line width/.initial=1pt,
  line width/.initial=1pt,
%    \end{macrocode}
% We taper from the \Verb+taper line width+ to the \Verb+line width+.
% We have complete freedom whether to taper either end.
%    \begin{macrocode}
  taper line width/.initial=0pt,
  taper/.is choice,
  taper/none/.style={
    taper at start=false,
    taper at end=false,
  },
  taper/both/.style={
    taper at start=true,
    taper at end=true,
  },
  taper/start/.style={
    taper at start=true,
    taper at end=false,
  },
  taper/end/.style={
    taper at start=false,
    taper at end=true,
  },
  taper at start/.is if=cgrphy@taper@start,
  taper at end/.is if=cgrphy@taper@end,
%    \end{macrocode}
% It is possible to put a style definition in a path declaration using the \Verb+line style+ key.
% This means we can specify the style corresponding to the current component without having to count up components.
%    \begin{macrocode}
  line style/.code={
    \expandafter\def\csname calligraphy@part@style@\the\value{cgrphy@path@parts}\endcsname{#1}%
  },
}
%    \end{macrocode}
%
%
% \begin{macro}{\calligraphystyle}
% This is a calligraphy version of the \Verb+\tikzset+ command.
%    \begin{macrocode}
\newcommand{\calligraphystyle}[1]{\pgfkeys{/pgf/calligraphy/.cd,#1}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\pen}
% This is a shortcut for defining a pen, it works just like a \Verb+\path+ command.
%    \begin{macrocode}
\newcommand{\pen}[1][]{\path[calligraphy,define pen,#1]}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\calligraphy}
% This is a shortcut for using a pen, it works just like a \Verb+\path+ command.
%    \begin{macrocode}
\newcommand{\calligraphy}[1][]{\path[calligraphy,use pen,#1]}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\definepen}
% This is like \Verb+\pen+ but doesn't need to be in a \Verb+tikzpicture+ environment.
%    \begin{macrocode}
\newcommand{\definepen}[1][]{\tikz \path[calligraphy,define pen,#1]}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\processpen}
% This is the macro that actually processes the pen declaration, converting it into two arrays of \Verb+spath component+ objects (one for the forward path and one for the reverse).
%    \begin{macrocode}
\newcommand{\processpen}[1][default]{%
\expandafter\let\expandafter\cgrphy@tmp@path\csname calligraphy@pen@#1@path\endcsname
    \expandafter\spathsplit\csname calligraphy@pen@#1\endcsname\cgrphy@tmp@path
    \expandafter\let\expandafter\cgrphy@temp\csname calligraphy@pen@#1\endcsname
    \cgrphy@temp.apply to paths(prepare,)%
%    \end{macrocode}
% Reverse the path and save that, too
%    \begin{macrocode}
    \begingroup
    \spath@reverse@init
    \cgrphy@tmp@path
    \g@addbefore@macro\spath@tmppath\pgfsyssoftpath@movetotoken
    \endgroup
    \spathsplit\cgrphy@temp\spath@tmppath
    \expandafter\let\csname calligraphy@pen@#1@rev\endcsname\spath@this@component
    \expandafter\let\expandafter\cgrphy@temp\csname calligraphy@pen@#1@rev\endcsname
    \cgrphy@temp.apply to previous paths(prepare,)%
}
%
%    \end{macrocode}
% \end{macro}
%
% Calligraphy commands
%
% Thicken a piece of the path with the pen.
% So we step through the pen path, thickening each component.
% When the path is originally defined, we need to keep track of the number of components so that we can use the \Verb+line style+ to set an appropriate style.
% For this, we need to redefine the \Verb+moveto+ to step a counter whenever it is called.
%
%    \begin{macrocode}
\let\cgrphy@orig@pathmoveto=\pgfpathmoveto
\def\cgrphy@pathmoveto#1{%
  \stepcounter{cgrphy@path@parts}%
  \cgrphy@orig@pathmoveto{#1}%
}
%    \end{macrocode}
% \begin{macro}{\cgrphy@thickenpath}
% This is the macro that starts us off thickening a path.
% We split the path into components, initialising them as an array of  \Verb+spath component+s.
% Then we reverse it and do the same.
% We find out our pen, and start our counters, and apply our initial styles.
% Then we call the macro that does the \emph{real} work.
%    \begin{macrocode}
\def\cgrphy@thickenpath#1#2{%
  \spathsplit\cgrphy@path#1\relax
  \begingroup
  \spath@reverse@init
  #1%
  \g@addbefore@macro\spath@tmppath\pgfsyssoftpath@movetotoken
  \endgroup
  \spathsplit\cgrphy@tmp\spath@tmppath\relax
  \let\cgrphy@path@rev\spath@this@component
  \expandafter\let\expandafter\cgrphy@pen@path\csname calligraphy@pen@#2\endcsname
  \expandafter\let\expandafter\cgrphy@pen@path@rev\csname calligraphy@pen@#2@rev\endcsname
\ifx\cgrphy@pen@path\relax
\message{Unknown pen: #2}%
\else
  \let\cgrphy@pen@path@start=\cgrphy@pen@path
  \let\cgrphy@pen@path@rev@start=\cgrphy@pen@path@rev
  \setcounter{cgrphy@path@parts}{1}%
  \setcounter{cgrphy@nib}{1}%
  \setcounter{cgrphy@label}{0}%
  \pgfsys@beginscope
  \pgfsys@beginscope
\begingroup
  \expandafter\let\expandafter\cgrphy@style\csname calligraphy@part@style@\the\value{cgrphy@path@parts}\endcsname
  \ifx\cgrphy@style\relax
  \else
  \expandafter\calligraphystyle\expandafter{\cgrphy@style}%
  \fi
  \cgrphy@@thickenpath
\endgroup
  \pgfsys@endscope
  \pgfsys@endscope
\fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cgrphy@@thickenpath}
% This is the macro that does the real work.
% This creates the thickened path working component by component in the given path.
%    \begin{macrocode}
\def\cgrphy@@thickenpath{%
  \pgfsys@beginscope
  \cgrphy@pen@path.get(path,\cgrphy@this@nib)%
  \cgrphy@pen@path@rev.get(path,\cgrphy@this@nib@rev)%
\begingroup
  \expandafter\let\expandafter\cgrphy@style\csname calligraphy@nib@style@\the\value{cgrphy@nib}\endcsname
  \ifx\cgrphy@style\relax
  \else
  \expandafter\calligraphystyle\expandafter{\cgrphy@style}%
  \fi
  \pgfsetstrokecolor{\pgfkeysvalueof{/pgf/calligraphy/pen colour}}%
  \pgfsetfillcolor{\pgfkeysvalueof{/pgf/calligraphy/pen colour}}%
  \pgfsetlinewidth{\pgfkeysvalueof{/pgf/calligraphy/line width}}%
  \cgrphy@path.get(path,\cgrphy@this@path)%
  \cgrphy@path@rev.get(path,\cgrphy@this@path@rev)%
  \cgrphy@this@path.prepare()%
  \cgrphy@this@path@rev.prepare()%
  \cgrphy@this@nib.get(length,\cgrphy@nib@length)%
  \cgrphy@this@nib.get(initial point,\cgrphy@pt)%
  \cgrphy@pt
  \cgrphy@this@path.translate path(\cgrphy@tr@path,\the\pgf@x,\the\pgf@y)%
  \ifnum\cgrphy@nib@length=1\relax
  \cgrphy@tr@path.at least three()%
\edef\cgrphy@temp{\pgfkeysvalueof{/pgf/calligraphy/taper line width}}%
  \cgrphy@tr@path.let(taper line width,\cgrphy@temp)%
   \ifcgrphy@taper@start
    \cgrphy@tr@path.split path by real length(\cgrphy@st@path,\cgrphy@rest@path,1)%
    \cgrphy@st@path.taper out()%
    \cgrphy@st@path.use path(fill)%
   \else
    \let\cgrphy@rest@path=\cgrphy@tr@path
   \fi
   \ifcgrphy@taper@end
    \cgrphy@rest@path.split path by real length(\cgrphy@rest@path,\cgrphy@end@path,-1)%
    \cgrphy@end@path.reverse path()%
    \cgrphy@end@path.taper out()%
    \cgrphy@end@path.use path(fill)%
   \fi
    \cgrphy@rest@path.use path(stroke)%
  \else
  \cgrphy@tr@path.weld(,\cgrphy@this@nib)%
  \cgrphy@tr@path.weld(,\cgrphy@this@path@rev)%
  \cgrphy@tr@path.weld(,\cgrphy@this@nib@rev)%
    \cgrphy@tr@path.use path(fill)%
  \fi
\endgroup
  \pgfsys@endscope
  \let\cgrphy@next=\cgrphy@@thickenpath
  \cgrphy@pen@path.get(next component,\cgrphy@pen@path)%
  \cgrphy@pen@path@rev.get(previous component,\cgrphy@pen@path@rev)%
  \stepcounter{cgrphy@nib}%
  \ifx\cgrphy@pen@path\pgfutil@empty
  \ifcalligraphy@annotate
  \cgrphy@annotatepath
  \fi
\endgroup
   \pgfsys@endscope
   \pgfsys@beginscope
  \let\cgrphy@next=\cgrphy@@thickenpath
   \let\cgrphy@pen@path=\cgrphy@pen@path@start
   \let\cgrphy@pen@path@rev=\cgrphy@pen@path@rev@start
   \setcounter{cgrphy@nib}{1}%
   \cgrphy@path.get(next component,\cgrphy@path)%
   \cgrphy@path@rev.get(previous component,\cgrphy@path@rev)%
   \stepcounter{cgrphy@path@parts}%
\begingroup
  \expandafter\let\expandafter\cgrphy@style\csname calligraphy@part@style@\the\value{cgrphy@path@parts}\endcsname
  \ifx\cgrphy@style\relax
  \else
  \expandafter\calligraphystyle\expandafter{\cgrphy@style}%
  \fi
   \ifx\cgrphy@path\pgfutil@empty
    \let\cgrphy@next=\relax
   \fi
  \fi
  \cgrphy@next
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cgrhy@annotatepath}
% If we're to annotate the path, this macro is called and does the annotation.
%    \begin{macrocode}
\def\cgrphy@annotatepath{%
  \pgfsys@beginscope
\begingroup
  \pgfkeysgetvalue{/pgf/calligraphy/annotation style}{\cgrphy@annotation@style}
  \let\tikz@options=\pgfutil@empty
  \ifx\cgrphy@annotation@style\relax
  \else
   \expandafter\calligraphystyle\expandafter{\cgrphy@annotation@style}
  \fi
  \tikz@options
  \cgrphy@path.get(path,\cgrphy@this@path)%
  \cgrphy@path@rev.get(path,\cgrphy@this@path@rev)%
  \cgrphy@this@path.prepare()%
  \tikz@scan@one@point\cgrphy@getpt\pgfkeysvalueof{/pgf/calligraphy/annotation shift}%
  \cgrphy@this@path.translate path(\cgrphy@tr@path,\the\pgf@x,\the\pgf@y)%
\cgrphy@this@nib.final point()%
  \cgrphy@tr@path.translate path(,\the\pgf@x,\the\pgf@y)%
  \cgrphy@tr@path.reprocess()%
  \def\cgrphy@temp{\cgrphy@tr@path.use path with tikz(}%
\ge@addto@macro\cgrphy@temp\cgrphy@annotation@style
\g@addto@macro\cgrphy@temp{,draw)}%
\cgrphy@temp
  \stepcounter{cgrphy@label}%
  \cgrphy@tr@path.get(final point,\cgrphy@pt)%
  \pgfkeysgetvalue{/pgf/calligraphy/annotation nodes style}{\cgrphy@node@options}%
  \ifx\cgrphy@node@options\relax
  \else
   \g@addto@macro\cgrphy@node@options{,}%
  \fi
  \expandafter\let\expandafter\cgrphy@node@style\csname calligraphy@annotation@style@\the\value{cgrphy@label}\endcsname
  \ifx\cgrphy@node@style\relax
  \else
   \ge@addto@macro{\cgrphy@node@options}{\cgrphy@node@style}%
  \fi
  \ifx\cgrphy@node@options\relax
  \let\cgrphy@node@options=\pgfutil@empty
  \fi
\cgrphy@pt
  \expandafter\node\expandafter[\cgrphy@node@options] at (\the\pgf@x,\the\pgf@y) {\arabic{cgrphy@label}};
\endgroup
  \pgfsys@endscope
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cgrphy@getpt}
% Ought to replace this with \Verb+\pgfutil@firstofone+.
%    \begin{macrocode}
\def\cgrphy@getpt#1{#1}
%    \end{macrocode}
% \end{macro}
%
% Some default pens: copperplate
%    \begin{macrocode}
\def\calligraphy@pen@copperplate@path{\pgfsyssoftpath@movetotoken{0pt}{0pt}}%
\processpen[copperplate]%
%    \end{macrocode}
%
% If the pgfdecoration module is loaded then we define some decorations that use this library.
% The first is a calligraphy brace.
%    \begin{macrocode}
\expandafter\ifx\csname pgfdeclaredecoration\endcsname\relax
\else
\pgfdeclaredecoration{calligraphic brace}{brace}
{
  \state{brace}[width=+\pgfdecoratedremainingdistance,next state=final]
  {
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}
    \pgfpathmoveto{\pgfpointorigin}
    \pgfpathcurveto
    {\pgfqpoint{.15\pgfdecorationsegmentamplitude}{.3\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
    {
      \pgftransformxshift{+\pgfdecorationsegmentaspect\pgfdecoratedremainingdistance}
      \pgfpathlineto{\pgfqpoint{-\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{-.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{-.15\pgfdecorationsegmentamplitude}{.7\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{0\pgfdecorationsegmentamplitude}{1\pgfdecorationsegmentamplitude}}
      \pgfpathmoveto{\pgfqpoint{0\pgfdecorationsegmentamplitude}{1\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{.15\pgfdecorationsegmentamplitude}{.7\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
    }
    {
      \pgftransformxshift{+\pgfdecoratedremainingdistance}
      \pgfpathlineto{\pgfqpoint{-\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{-.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{-.15\pgfdecorationsegmentamplitude}{.3\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{0pt}{0pt}}
    }
    \pgfkeys{
      /pgf/calligraphy/line width=\pgflinewidth,
      /pgf/calligraphy/taper line width=.5\pgflinewidth
    }%
    \pgfsyssoftpath@getcurrentpath{\cgrphy@tmppath}%
    \cgrphy@thickenpath{\cgrphy@tmppath}{copperplate}%
  }
  \state{final}{}
}
%    \end{macrocode}
% The second is a straightened parenthesis (so that when very large it doesn't bow out too far).
%    \begin{macrocode}
\pgfdeclaredecoration{calligraphic straight parenthesis}{brace}
{
  \state{brace}[width=+\pgfdecoratedremainingdistance,next state=final]
  {
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}
    \pgfpathmoveto{\pgfpointorigin}
    \pgfpathcurveto
    {\pgfqpoint{.76604\pgfdecorationsegmentamplitude}{.64279\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{2.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{3.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
    {
      \pgftransformxshift{+\pgfdecoratedremainingdistance}
      \pgfpathlineto{\pgfqpoint{-3.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{-2.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{-.76604\pgfdecorationsegmentamplitude}{.64279\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{0pt}{0pt}}
    }
    \pgfkeys{
      /pgf/calligraphy/line width=\pgflinewidth,
      /pgf/calligraphy/taper line width=.5\pgflinewidth
    }%
    \pgfsyssoftpath@getcurrentpath{\cgrphy@tmppath}%
    \cgrphy@thickenpath{\cgrphy@tmppath}{copperplate}%
  }
  \state{final}{}%
}
%    \end{macrocode}
% The third is a curved parenthesis.
%    \begin{macrocode}
\pgfdeclaredecoration{calligraphic curved parenthesis}{brace}
{
  \state{brace}[width=+\pgfdecoratedremainingdistance,next state=final]
  {
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}
    \pgfpathmoveto{\pgfpointorigin}
    \pgf@xa=\pgfdecoratedremainingdistance\relax
    \advance\pgf@xa by -1.5890\pgfdecorationsegmentamplitude\relax
    \edef\cgrphy@xa{\the\pgf@xa}
    \pgfpathcurveto
    {\pgfqpoint{1.5890\pgfdecorationsegmentamplitude}{1.3333\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{\cgrphy@xa}{1.3333\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{\pgfdecoratedremainingdistance}{0pt}}
    \pgfkeys{
      /pgf/calligraphy/line width=\pgflinewidth,
      /pgf/calligraphy/taper line width=.5\pgflinewidth
    }%
    \pgfsyssoftpath@getcurrentpath{\cgrphy@tmppath}%
    \cgrphy@thickenpath{\cgrphy@tmppath}{copperplate}%
  }
  \state{final}{}%
}
%    \end{macrocode}
% End if pgfdecoration module is loaded
%    \begin{macrocode}
\fi
%    \end{macrocode}
%
% \iffalse
%</package>
% \fi
%
% \Finale
\endinput
