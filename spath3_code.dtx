% \iffalse meta-comment
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
spath3 --- LaTeX3 functions for manipulating PGF soft paths
E-mail: loopspace@mathforge.org
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package defines some functions used to manipulate PGFs soft paths.
As applications of its use, included are a package for drawing calligraphic paths and a package for drawing knot diagrams.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input l3docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
spath3 --- Functions for manipulating PGF soft paths
E-mail: loopspace@mathforge.org
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2011-2019 by Andrew Stacey <loopspace@mathforge.org>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Andrew Stacey.

This work consists of the files  spath3.dtx
                                 calligraphy_doc.tex
                                 knots_doc.tex
and the derived files            spath3.ins,
                                 spath3_code.pdf,
                                 spath3.sty,
                                 tikzlibrarycalligraphy.code.tex
                                 tikzlibraryknots.code.tex
                                 tikzlibraryspath3.code.tex
                                 calligraphy.pdf
                                 knots.pdf
                                 README

\endpostamble
\usedir{tex/latex/spath3}
\generate{
  \file{spath3.sty}{\from{\jobname.dtx}{spath3}}
}
\generate{
  \file{tikzlibrarycalligraphy.code.tex}{\from{\jobname.dtx}{calligraphy}}
}
\generate{
  \file{tikzlibraryknots.code.tex}{\from{\jobname.dtx}{knots}}
}
\generate{
  \file{tikzlibraryspath3.code.tex}{\from{\jobname.dtx}{tikzspath3}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/spath3}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/demopkg}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
\documentclass[full]{l3doc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
%\usepackage{morefloats}
\usepackage{tikz}
\usepackage{trace}
\usepackage{spath3}
%\traceoff
%\usepackage[numbered]{hypdoc}
\definecolor{lstbgcolor}{rgb}{0.9,0.9,0.9} 
 
\usepackage{listings}
\lstloadlanguages{[LaTeX]TeX}
\lstset{
  breakatwhitespace=true,
  breaklines=true,
  language=[LaTeX]TeX,
  basicstyle=\small\ttfamily,
  keepspaces=true,
  columns=fullflexible
}
 
\usepackage{fancyvrb}

\newenvironment{example}
  {\VerbatimEnvironment
   \begin{VerbatimOut}[gobble=2]{example.out}}
  {\end{VerbatimOut}
   \begin{center}
%   \setlength{\parindent}{0pt}
   \fbox{\begin{minipage}{.9\linewidth}
     \lstinputlisting[]{example.out}
   \end{minipage}}
   \fbox{\begin{minipage}{.9\linewidth}
     \centering
     \input{example.out}
   \end{minipage}}
\end{center}
}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \CheckSum{4865}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{1.0}{2011/05/03}{Converted to DTX file}
% \changes{1.1}{2016/02/19}{Fixes due to changes in LaTeX3}
% \changes{1.2}{2019/02/12}{More fixes due to changes in LaTeX3}
% \changes{1.4}{2020/12/18}{A fair amount of code reimplementation and reorganisation, together with defining TikZ keys to make functions available for use.}
%
% \DoNotIndex{\newcommand,\newenvironment}
%
% \providecommand*{\url}{\texttt}
% \GetFileInfo{spath3.sty}
% \title{The \textsf{spath3} package}
% \author{Andrew Stacey \\ \url{loopspace@mathforge.org}}
% \date{\fileversion~from \filedate}
%
%
% \maketitle
%
% 
% \section{Introduction}
%
% The \Verb+spath3+ package is intended as a library for manipulating PGF's \emph{soft paths}.
% In between defining a path and using it, PGF stores a path as a \emph{soft path} where all the defining structure has been resolved into the basic operations but these have not yet been written to the output file.
% They can therefore still be manipulated by \TeX, and as they have a very rigid form (and limited vocabulary), they are relatively easy to modify.
% This package provides some methods for working with these paths.
% It was originally not really intended for use by end users but as a foundation on which other packages can be built.
% However, over the years I've found myself using it at ever higher levels and so a set of interfaces has been designed using TikZ keys.
%
% It also provides the engine that drives a few other packages, such as the  \Verb+calligraphy+, \Verb+knot+, and \Verb+penrose+ packages.
% The first two of these are subpackages of this one.
% The \Verb+calligraphy+ package simulates a calligraphic pen stroking a path.
% The \Verb+knots+ package can be used to draw knot (and similar) diagrams.
%
% For usage, see the documentation of the following packages (\Verb+texdoc <package>+):
%
% \begin{itemize}
% \item \Verb+calligraphy+
% \item \Verb+knots+
% \item \Verb+penrose+
% \item \Verb+spath3+
% \end{itemize}
%
% \section{Technical Details}
%
% The format of a soft path is a sequence of triples of the form \Verb+\macro {dimension}{dimension}+.
% The macro is one of a short list, the dimensions are coordinates in points.
% There are certain further restrictions, particularly that every path must begin with a \Verb+move to+, and B\'ezier curves consist of three triples.
%
% These are stored in a \LaTeX3 \Verb+prop+ along with potentially a slew of other information.
% This information is:
%
% \begin{itemize}
% \item The original soft path.
% \item A reversed copy of the path.
% \item The length, which is the number of actual triples in the path.
% \item The real length, which is the number of triples that actually draw something in the path.
% \item The number of components, which is the number of moves in the path.
% \item The initial point.
% \item The final point.
% \item The initial action, which is the first thing \emph{after} the initial move on the path.
% \item The final action.
% \item The lower left and upper right of the bounding box of the path.
% \end{itemize}
%
% The information isn't computed unless explicitly asked for to avoid unnecessary work.
% But the package tries to hide that requirement so that if you try to get a piece of information and it isn't already computed then it will be done and stored.
%
% A frequent use of this package is to break a path into pieces and do something with each of those pieces.
% To that end, there are various words that I use to describe the levels of the structure of a path.
%
% At the top level is the path itself.
% At the bottom level are the triples of the form \Verb+\macro{dim}{dim}+, as described above.
% In between these are the \emph{segments} and \emph{components}.
%
% A \emph{segment} is a minimal drawing piece.
% Thus it might be a straight line or a B\'ezier curve.
% When a path is broken into segments then each segment is a complete path so it isn't simply a selection of triples from the original path.
%
% A \emph{component} is a minimal connected section of the path.
% So every component starts with a move command and continues until the next move command.
% For ease of implementation (and to enable a copperplate pen in the calligraphy package!), an isolated move is considered as a component.
% Thus the following path consists of three components:
%
% \begin{Verbatim}
% \path (0,0) -- (1,0) (2,0) (3,0) to[out=0,in=90] (4,0);
% \end{Verbatim}
%
% \StopEventually{}
%
% \section{Implementation}
%
% \iffalse
%<*spath3>
% \fi
% \subsection{Initialisation}
%
%    \begin{macrocode}
%<@@=spath>
%    \end{macrocode}
%
% Load the \LaTeX3 foundation and register us as a \LaTeX3\ package.
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{expl3}
\RequirePackage{pgf}
\ProvidesExplPackage {spath3} {2020/12/18} {1.4} {Functions for
manipulating PGF soft paths}
\RequirePackage{xparse}
\RequirePackage{asxutils}
%    \end{macrocode}
%
% We need a slew of temporary variables.
%    \begin{macrocode}
\tl_new:N \l_@@_tmpa_tl
\tl_new:N \l_@@_tmpb_tl
\tl_new:N \l_@@_tmpc_tl
\tl_new:N \l_@@_tmpd_tl
\tl_new:N \l_@@_tmpe_tl
\tl_new:N \l_@@_smuggle_tl
\dim_new:N \l_@@_tmpa_dim
\dim_new:N \l_@@_tmpb_dim
\dim_new:N \l_@@_move_x_dim
\dim_new:N \l_@@_move_y_dim
\fp_new:N \l_@@_tmpa_fp
\fp_new:N \l_@@_tmpb_fp
\int_new:N \l_@@_tmpa_int
\int_new:N \g_@@_map_int
\bool_new:N \l_@@_closed_bool
%    \end{macrocode}
%
% We need to be able to compare against the macros that can occur in  a soft path so these token lists contain them.
%    \begin{macrocode}
\tl_new:N \g_@@_moveto_tl
\tl_new:N \g_@@_lineto_tl
\tl_new:N \g_@@_curveto_tl
\tl_new:N \g_@@_curvetoa_tl
\tl_new:N \g_@@_curvetob_tl
\tl_new:N \g_@@_closepath_tl
\tl_gset:Nn \g_@@_moveto_tl {\pgfsyssoftpath@movetotoken}
\tl_gset:Nn \g_@@_lineto_tl {\pgfsyssoftpath@linetotoken}
\tl_gset:Nn \g_@@_curveto_tl {\pgfsyssoftpath@curvetotoken}
\tl_gset:Nn \g_@@_curvetoa_tl {\pgfsyssoftpath@curvetosupportatoken}
\tl_gset:Nn \g_@@_curvetob_tl {\pgfsyssoftpath@curvetosupportbtoken}
\tl_gset:Nn \g_@@_closepath_tl {\pgfsyssoftpath@closepathtoken}
%    \end{macrocode}
%
%
% We will want to be able to use anonymous spaths internally, so we create a global counter that we can use to refer to them.
%    \begin{macrocode}
\int_new:N \g_@@_anon_int
\int_gzero:N \g_@@_anon_int
\tl_new:N \l_@@_anon_tl
%    \end{macrocode}
%
% Groups and iterations don't mix well and I haven't got a good scheme for protecting local calculations when iterating, so we do our best with iteration-specific variables.
%    \begin{macrocode}
\tl_new:N \l_@@_itera_tl
\tl_new:N \l_@@_iterb_tl
\tl_new:N \l_@@_iterc_tl
\tl_new:N \l_@@_iterd_tl
\tl_new:N \l_@@_iterp_tl
\dim_new:N \l_@@_itera_dim
\dim_new:N \l_@@_iterb_dim
%    \end{macrocode}
%
% And some error messages
%    \begin{macrocode}
\msg_new:nnn { spath3 } { unknown path construction } { The~ path~ construction~ element~ #1~ is~ not~ currently~ supported.}
%    \end{macrocode}
%
% \subsection{Basic Structure and Methods}
%
% A soft path is a \Verb+prop+.
% These are lists of the attributes that we define.
% The first consists of all attributes, the second of those that are ``moveable'' in the sense that they change if we transform the path, the third are the ones that contain actual paths.
%
% Note that if using these attributes outside an \Verb+expl3+ context, the spaces should be omitted.
%
%    \begin{macrocode}
\tl_new:N \g_@@_attributes
\tl_new:N \g_@@_moveable_attributes
\tl_new:N \g_@@_path_attributes
\tl_gset:Nn \g_@@_attributes {
  {path}
  {reverse path}
  {length}
  {real length}
  {number of components}
  {initial point}
  {final point}
  {initial action}
  {final action}
  {min bb}
  {max bb}
}
\tl_gset:Nn \g_@@_moveable_attributes {
  {initial point}
  {final point}
  {min bb}
  {max bb}
}
\tl_gset:Nn \g_@@_path_attributes {
  {path}
  {reverse path}
}
%    \end{macrocode}
%
% An \Verb+spath+ object is actually a \Verb+prop+.
% The following functions are wrappers around the underlying \Verb+prop+ functions.
% We prefix the names to avoid clashing with other \Verb+prop+s that might be lying around, this is why all the \Verb+spath+ methods take argument \Verb+:n+ and not \Verb+:N+.
%
% We use the \Verb+l+ prefix to obey \LaTeX3 naming conventions for variables.
%
%
% \subsubsection{Prop Functions}
%
% We need a variety of functions which are, for the main part, a wrapper around the underlying prop functions.
%
% \begin{macro}[internal]{\spath_new:n}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_new:n #1
{
  \prop_new:c {l_@@_#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_clear:n}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_clear:n #1
{
  \prop_clear:c {l_@@_#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_gclear:n}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_gclear:n #1
{
  \prop_gclear:c {l_@@_#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_clear_new:n}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_clear_new:n #1
{
  \prop_clear_new:c {l_@@_#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_gclear_new:n}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_gclear_new:n #1
{
  \prop_gclear_new:c {l_@@_#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_show:n}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_show:n #1
{
  \prop_show:c {l_@@_#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_put:nnn}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_put:nnn #1#2#3
{
  \prop_put:cnn {l_@@_#1} {#2} {#3}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_gput:nnn}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_gput:nnn #1#2#3
{
  \prop_gput:cnn {l_@@_#1} {#2} {#3}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_remove:nn}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_remove:nn #1#2
{
  \prop_remove:cn {l_@@_#1} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_gremove:nn}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_gremove:nn #1#2
{
  \prop_gremove:cn {l_@@_#1} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_get:nn}
% This function is an internal one since the real \Verb+get+ function will generate its data if it does not already exist.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_get:nn #1#2
{
  \prop_item:cn {l_@@_#1} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_get:nnN}
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_get:nnN #1#2#3
{
  \prop_get:cnN {l_@@_#1} {#2} #3
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_if_in:nn}
%    \begin{macrocode}
\prg_new_conditional:Npnn \spath_if_in:nn #1#2 {p, T, F, TF}
{
  \prop_if_in:cnTF {l_@@_#1} {#2}
  { \prg_return_true: }
  { \prg_return_false: }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_get:nnN}
%    \begin{macrocode}
\cs_generate_variant:Nn \__prop_split:NnTF {cnTF}
\prg_new_protected_conditional:Npnn \@@_get:nnN #1#2#3 {T, F, TF}
{
  \__prop_split:cnTF {l_@@_#1} {#2}
  {
    \tl_set:Nn #3 {##2}
    \prg_return_true:
  }
  { \prg_return_false: }
}
\cs_generate_variant:Nn \spath_put:nnn {nnV, nnx, nno, Vnn, VnV}
\cs_generate_variant:Nn \spath_gput:nnn {nnV, nnx, nno, Vnn}
\cs_generate_variant:Nn \@@_get:nn {Vn}
\cs_generate_variant:Nn \@@_get:nnN {VnN}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_if_exist:n}
%    \begin{macrocode}
\prg_new_conditional:Npnn \spath_if_exist:n #1 {p,T,F,TF}
{
  \prop_if_exist:cTF {l_@@_#1}
  {
    \prg_return_true:
  }
  {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_clone:nn}
% Clones an \Verb+spath+.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_clone:nn #1 #2
{
  \spath_clear_new:n {#2}
  \tl_map_inline:Nn \g_@@_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \@@_get:nnN {#1} {##1} \l_@@_tmpa_tl
      \spath_put:nnV {#2} {##1} \l_@@_tmpa_tl
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_gclone:nn}
% Globally clones an \Verb+spath+.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_gclone:nn #1 #2
{
  \spath_gclear_new:n {#2}
  \tl_map_inline:Nn \g_@@_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \@@_get:nnN {#1} {##1} \l_@@_tmpa_tl
      \spath_gput:nnV {#2} {##1} \l_@@_tmpa_tl
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_new_anonymous:N}
% Put the name of a new anonymous spath into the token list variable.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_new_anonymous:N #1
{
  \spath_new:n {anonymous_ \int_use:N \g_@@_anon_int}
  \tl_set:Nx #1 {anonymous_ \int_use:N \g_@@_anon_int}
  \int_gincr:N \g_@@_anon_int
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{PGF and TikZ Interface Functions}
%
% Spaths come from PGF so we need some functions that get and set spaths from the pgf system.
%
% \begin{macro}[internal]{\spath_get_current_path:n}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_get_current_path:n #1
{
  \pgfsyssoftpath@getcurrentpath\l_@@_tmpa_tl
  \spath_clear_new:n {#1}
  \spath_put:nnV {#1} {path} \l_@@_tmpa_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_gget_current_path:n}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_gget_current_path:n #1
{
  \pgfsyssoftpath@getcurrentpath\l_@@_tmpa_tl
  \spath_gclear_new:n {#1}
  \spath_gput:nnV {#1} {path} \l_@@_tmpa_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_protocol_path:n}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_protocol_path:n #1
{
  \spath_get:nnN {#1} {min bb} \l_@@_tmpa_tl
  \exp_last_unbraced:NV \pgf@protocolsizes\l_@@_tmpa_tl

  \spath_get:nnN {#1} {max bb} \l_@@_tmpa_tl
  \exp_last_unbraced:NV \pgf@protocolsizes\l_@@_tmpa_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_set_current_path:n}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_set_current_path:n #1
{
  \spath_protocol_path:n {#1}
  \spath_get:nnN {#1} {path} \l_@@_tmpa_tl
  \pgfsyssoftpath@setcurrentpath\l_@@_tmpa_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_use_path:nn}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_use_path:nn #1#2
{
  \spath_set_current_path:n {#1}
  \pgfusepath{#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_tikz_path:nn}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_tikz_path:nn #1#2
{
  \path[#1] \pgfextra{
    \spath_protocol_path:n {#2}
    \spath_get:nnN {#2} {path} \l_@@_tmpa_tl
    \pgfsyssoftpath@setcurrentpath \l_@@_tmpa_tl
    \tl_put_right:Nn \tikz@preactions {\def\tikz@actions@path}
    \tl_put_right:Nx \tikz@preactions {{\exp_args:NV \exp_not:n \l_@@_tmpa_tl}}
  };
}
\cs_generate_variant:Nn \spath_tikz_path:nn {Vn}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_set_tikz_coords:n}
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_set_tikz_coords:n #1
{
  \spath_get:nnN { #1 } {final point} \l_@@_tmpa_tl
  \tl_set:Nx \l_@@_tmpa_tl
  {
    \exp_not:c {tikz@lastx}=\tl_item:Nn \l_@@_tmpa_tl {1}
    \exp_not:c {tikz@lasty}=\tl_item:Nn \l_@@_tmpa_tl {2}
    \exp_not:c {tikz@lastxsaved}=\tl_item:Nn \l_@@_tmpa_tl {1}
    \exp_not:c {tikz@lastysaved}=\tl_item:Nn \l_@@_tmpa_tl {2}
  }
  \tl_use:N \l_@@_tmpa_tl
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Computing Information}
%
%
% \begin{macro}[internal]{\@@_to_tl:nN}
% In many of the spath manipulation functions we want to do some heavy computation on the properties of an spath.
% To do these safely, we should do them inside a group.
% But then we want to get the results of those computations out of the group.
% The simplest way to achieve this seems to be to serialise it to a token list, and then expand it back to an spath outside the group.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_to_tl:nN #1#2
{
  \group_begin:
  \tl_clear:N \l_@@_tmpb_tl
  \tl_map_inline:Nn \g_@@_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \@@_get:nnN {#1} {##1} \l_@@_tmpa_tl
      \tl_clear:N \l_@@_tmpc_tl
      \asxutils_tl_gput_right_braced:Nn \l_@@_tmpc_tl {##1}
      \asxutils_tl_gput_right_braced:NV \l_@@_tmpc_tl \l_@@_tmpa_tl
      \asxutils_tl_gput_right_braced:NV \l_@@_tmpb_tl \l_@@_tmpc_tl
    }
  }
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \tl_set_eq:NN #2 \l_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_gto_tl:nN}
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_gto_tl:nN #1#2
{
  \group_begin:
  \tl_clear:N \l_@@_tmpb_tl
  \tl_map_inline:Nn \g_@@_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \@@_get:nnN {#1} {##1} \l_@@_tmpa_tl
      \tl_clear:N \l_@@_tmpc_tl
      \asxutils_tl_gput_right_braced:Nn \l_@@_tmpc_tl {##1}
      \asxutils_tl_gput_right_braced:NV \l_@@_tmpc_tl \l_@@_tmpa_tl
      \asxutils_tl_gput_right_braced:NV \l_@@_tmpb_tl \l_@@_tmpc_tl
    }
  }
  \tl_gset_eq:NN #2 \l_@@_tmpb_tl
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_from_tl:nn}
% This complements the above by setting an spath object from a token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_from_tl:nn #1#2
{
  \spath_clear_new:n {#1}
  \tl_map_inline:nn {#2}
  {
    \spath_put:nnn {#1} ##1
  }
}
\cs_generate_variant:Nn \@@_from_tl:nn {nV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_gfrom_tl:nn}
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_gfrom_tl:nn #1#2
{
  \spath_clear_new:n {#1}
  \tl_map_inline:nn {#2}
  {
    \spath_gput:nnn {#1} ##1
  }
}
\cs_generate_variant:Nn \@@_gfrom_tl:nn {nV}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[internal]{\spath_get:nn}
% The information that we store along with a soft path can be computed from it, but computing it every time is wasteful.
% So this is the real \Verb+\spath_get:nn+ function which checks to see if we have already computed it and then either retrieves it or computes it. 
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_get:nn #1#2
{
  \spath_if_in:nnF {#1} {#2}
  {
    \cs_if_exist_use:cT {spath_generate_#2:n} {{#1}}
  }
  \@@_get:nn {#1} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_get:nnN}
% As above but leaves the result in a token list rather than in the stream.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_get:nnN #1#2#3
{
  \spath_if_in:nnF {#1} {#2}
  {
    \cs_if_exist_use:cT {spath_generate_#2:n} {{#1}}
  }
  \@@_get:nnN {#1} {#2} #3
}
\cs_generate_variant:Nn \spath_get:nnN {VnN}
%    \end{macrocode}
% \end{macro}
%
% The next slew of functions generate data from the original path, storing it in the \Verb+prop+ for further retrieval.
% \begin{macro}[internal]{\spath_generate_length:n}
% Counts the number of triples in the path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_length:n #1
{
  \@@_get:nnN {#1} {path} \l_@@_tmpa_tl
  \spath_put:nnx {#1} {length} {\int_eval:n {\tl_count:N \l_@@_tmpa_tl /3 }}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_generate_reallength:n}
% The real length of a path is the number of triples that actually draw something (that is, the number of lines and curves).
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_reallength:n #1
{
  \group_begin:
  \@@_get:nnN {#1} {path} \l_@@_tmpa_tl
  \int_set:Nn \l_@@_tmpa_int {0}
  \tl_map_inline:Nn \l_@@_tmpa_tl {
    \tl_if_eq:nnT {##1} {\pgfsyssoftpath@linetotoken}
    {
      \int_incr:N \l_@@_tmpa_int
    }
    \tl_if_eq:nnT {##1} {\pgfsyssoftpath@curvetotoken}
    {
      \int_incr:N \l_@@_tmpa_int
    }
  }
  \tl_gclear:N \l_@@_smuggle_tl
  \tl_gset:NV \l_@@_smuggle_tl \l_@@_tmpa_int
  \group_end:
  \spath_put:nnV {#1} {real length} \l_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_generate_numberofcomponents:n}
% A component is a continuous segment of the path, separated by moves.
% Successive moves are not collapsed, and zero length moves count.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_numberofcomponents:n #1
{
  \group_begin:
  \@@_get:nnN {#1} {path} \l_@@_tmpa_tl
  \int_set:Nn \l_@@_tmpa_int {0}
  \tl_map_inline:Nn \l_@@_tmpa_tl {
    \tl_if_eq:nnT {##1} {\pgfsyssoftpath@movetotoken}
    {
      \int_incr:N \l_@@_tmpa_int
    }
  }
  \tl_gclear:N \l_@@_smuggle_tl
  \tl_gset:NV \l_@@_smuggle_tl \l_@@_tmpa_int
  \group_end:
  \spath_put:nnV {#1} {number of components} \l_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_generate_initialpoint:n}
% The starting point of the path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_initialpoint:n #1
{
  \group_begin:
  \@@_get:nnN {#1} {path} \l_@@_tmpa_tl
  \tl_clear:N \l_@@_tmpb_tl
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \tl_put_right:Nx \l_@@_tmpb_tl {{\tl_head:N \l_@@_tmpa_tl}}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \tl_put_right:Nx \l_@@_tmpb_tl {{\tl_head:N \l_@@_tmpa_tl}}
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \spath_put:nnV {#1} {initial point} \l_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_generate_finalpoint:n}
% The final point of the path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_finalpoint:n #1
{
  \group_begin:
  \tl_clear:N \l_@@_tmpb_tl
  \spath_if_in:nnTF {#1} {reverse path}
  {
    \@@_get:nnN {#1} {reverse path} \l_@@_tmpa_tl
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    \tl_put_right:Nx \l_@@_tmpb_tl {{\tl_head:N \l_@@_tmpa_tl}}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    \tl_put_right:Nx \l_@@_tmpb_tl {{\tl_head:N \l_@@_tmpa_tl}}
  }
  {
    \@@_get:nnN {#1} {path} \l_@@_tmpa_tl
    \tl_reverse:N \l_@@_tmpa_tl
    \tl_put_left:Nx \l_@@_tmpb_tl {{\tl_head:N \l_@@_tmpa_tl}}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    \tl_put_left:Nx \l_@@_tmpb_tl {{\tl_head:N \l_@@_tmpa_tl}}
  }
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \spath_put:nnV {#1} {final point} \l_@@_smuggle_tl    
}
\cs_generate_variant:Nn \spath_generate_finalpoint:n {V}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_generate_reversepath:n}
% This computes the reverse of the path.
% TODO: handle closed paths, possibly rectangles.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_reversepath:n #1
{
  \group_begin:
  \@@_get:nnN {#1} {path} \l_@@_tmpa_tl

  \tl_clear:N \l_@@_tmpb_tl
  \tl_clear:N \l_@@_tmpd_tl
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  
  \tl_put_left:Nx \l_@@_tmpb_tl
  {
    {\dim_use:N \l_@@_tmpa_dim}
    {\dim_use:N \l_@@_tmpb_dim}
  }
  
  \bool_set_false:N \l_@@_closed_bool
  
  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_tmpa_tl
  }
  {
    \tl_set:Nx \l_@@_tmpc_tl {\tl_head:N \l_@@_tmpa_tl}

    \tl_case:NnTF \l_@@_tmpc_tl
    {
      \g_@@_moveto_tl {
        
        \bool_if:NT \l_@@_closed_bool
        {
          \tl_put_right:NV \l_@@_tmpd_tl \g_@@_closepath_tl
          \tl_set:Nx \l_@@_tmpe_tl {\tl_tail:N \l_@@_tmpd_tl}
          \tl_put_right:Nx \l_@@_tmpd_tl
          {
            { \tl_head:N \l_@@_tmpd_tl }
            { \tl_head:N \l_@@_tmpe_tl }
          }
        }
        \bool_set_false:N \l_@@_closed_bool
        \tl_put_left:NV \l_@@_tmpd_tl \g_@@_moveto_tl
        \tl_put_left:NV \l_@@_tmpb_tl \l_@@_tmpd_tl
        \tl_clear:N \l_@@_tmpd_tl
      }
      \g_@@_lineto_tl {
        \tl_put_left:NV \l_@@_tmpd_tl \g_@@_lineto_tl
      }
      \g_@@_curveto_tl {
        \tl_put_left:NV \l_@@_tmpd_tl \g_@@_curvetoa_tl
      }
      \g_@@_curvetoa_tl {
        \tl_put_left:NV \l_@@_tmpd_tl \g_@@_curveto_tl
      }
      \g_@@_curvetob_tl {
        \tl_put_left:NV \l_@@_tmpd_tl \g_@@_curvetob_tl
      }
    }
    {
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

      \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

      \tl_put_left:Nx \l_@@_tmpd_tl
      {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }

    }
    {
      \tl_if_eq:NNTF \l_@@_tmpc_tl \g_@@_closepath_tl
      {
        \bool_set_true:N \l_@@_closed_bool
      }
      {
        \msg_warning:nnx { spath3 } { unknown path construction } {\l_@@_tmpc_tl }
      }

      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

    }
  }

  \bool_if:NT \l_@@_closed_bool
  {
    \tl_put_right:NV \l_@@_tmpd_tl \g_@@_closepath_tl
    \tl_set:Nx \l_@@_tmpe_tl {\tl_tail:N \l_@@_tmpd_tl}
    \tl_put_right:Nx \l_@@_tmpd_tl
    {
      { \tl_head:N \l_@@_tmpd_tl }
      { \tl_head:N \l_@@_tmpe_tl }
    }
  }

  \bool_set_false:N \l_@@_closed_bool
  \tl_put_left:NV \l_@@_tmpd_tl \g_@@_moveto_tl
  \tl_put_left:NV \l_@@_tmpb_tl \l_@@_tmpd_tl

  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:

  \spath_put:nnV {#1} {reverse path} \l_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_generate_initialaction:n}
% This is the first thing that the path does (after the initial move).
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_initialaction:n #1
{
  \group_begin:
  \@@_get:nnN {#1} {path} \l_@@_tmpa_tl
  \tl_clear:N \l_@@_tmpb_tl
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \tl_if_empty:NF \l_@@_tmpa_tl {
    \tl_set:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
  }
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \spath_put:nnV {#1} {initial action} \l_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_generate_final action:n}
% This is the last thing that the path does.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_finalaction:n #1
{
  \group_begin:
  \tl_clear:N \l_@@_tmpb_tl
  \spath_if_in:nnTF {#1} {reverse path}
  {
    \@@_get:nnN {#1} {reverse path} \l_@@_tmpa_tl
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  }
  {
    \@@_get:nnN {#1} {path} \l_@@_tmpa_tl
    \tl_reverse:N \l_@@_tmpa_tl
  }
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \tl_if_empty:NF \l_@@_tmpa_tl {
    \tl_set:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
  }
  \tl_if_eq:NNT \l_@@_tmpb_tl \g_@@_curvetoa_tl
  {
    \tl_set_eq:NN \l_@@_tmpb_tl \g_@@_curveto_tl
  }
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \spath_put:nnV {#1} {final action} \l_@@_smuggle_tl    
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_generate_minbb:n}
% This computes the minimum (bottom left) of the bounding box of the path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_minbb:n #1
{
  \group_begin:
  \@@_get:nnN {#1} {path} \l_@@_tmpa_tl
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_tmpa_tl
  }
  {
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    \dim_set:Nn \l_@@_tmpa_dim {\dim_min:nn {\tl_head:N \l_@@_tmpa_tl} {\l_@@_tmpa_dim}}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    \dim_set:Nn \l_@@_tmpb_dim {\dim_min:nn {\tl_head:N \l_@@_tmpa_tl} {\l_@@_tmpb_dim}}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  }
  \tl_clear:N \l_@@_tmpb_tl
  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_use:N \l_@@_tmpa_dim}
    {\dim_use:N \l_@@_tmpb_dim}
  }
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \spath_put:nnV {#1} {min bb} \l_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_generate_max bb:n}
% This computes the maximum (top right) of the bounding box of the path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_generate_maxbb:n #1
{
  \group_begin:
  \@@_get:nnN {#1} {path} \l_@@_tmpa_tl
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_tmpa_tl
  }
  {
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    \dim_set:Nn \l_@@_tmpa_dim {\dim_max:nn {\tl_head:N \l_@@_tmpa_tl} {\l_@@_tmpa_dim}}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    \dim_set:Nn \l_@@_tmpb_dim {\dim_max:nn {\tl_head:N \l_@@_tmpa_tl} {\l_@@_tmpb_dim}}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  }
  \tl_clear:N \l_@@_tmpb_tl
  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_use:N \l_@@_tmpa_dim}
    {\dim_use:N \l_@@_tmpb_dim}
  }
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \spath_put:nnV {#1} {max bb} \l_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_generate_all:n}
% This function generates all of the data in one fell swoop.
% By traversing the path just once it is quicker than doing each one individually.
% However, it does need to store a lot of data as it goes.
% \begin{itemize}
% \item \Verb+\l_@@_rp_tl+ will hold the reversed path
% \item \Verb+\l_@@_l_int+ will hold the length
% \item \Verb+\l_@@_rl_int+ will hold the real length
% \item \Verb+\l_@@_nc_int+ will hold the number of components
% \item \Verb+\l_@@_ip_tl+ will hold the initial point
% \item \Verb+\l_@@_fp_tl+ will hold the final point
% \item \Verb+\l_@@_ia_tl+ will hold the initial action
% \item \Verb+\l_@@_fa_tl+ will hold the final action
% \item \Verb+\l_@@_minx_dim+ will hold the min x bb
% \item \Verb+\l_@@_miny_dim+ will hold the min y bb
% \item \Verb+\l_@@_maxx_dim+ will hold the max x bb
% \item \Verb+\l_@@_maxy_dim+ will hold the max y bb
% \end{itemize}
%    \begin{macrocode}
\tl_new:N \l_@@_rp_tl
\int_new:N \l_@@_l_int
\int_new:N \l_@@_rl_int
\int_new:N \l_@@_nc_int
\tl_new:N \l_@@_ip_tl
\tl_new:N \l_@@_fp_tl
\tl_new:N \l_@@_ia_tl
\tl_new:N \l_@@_fa_tl
\dim_new:N \l_@@_minx_dim
\dim_new:N \l_@@_miny_dim
\dim_new:N \l_@@_maxx_dim
\dim_new:N \l_@@_maxy_dim

\cs_new_nopar:Npn \spath_generate_all:n #1
{
  \group_begin:
  \@@_get:nnN {#1} {path} \l_@@_tmpa_tl

  \tl_clear:N \l_@@_rp_tl
  \int_set:Nn \l_@@_l_int {1}
  \int_zero:N \l_@@_rl_int
  \int_set:Nn \l_@@_nc_int {1}
  \tl_clear:N \l_@@_ip_tl
  \tl_clear:N \l_@@_fp_tl
  \tl_clear:N \l_@@_ia_tl
  \tl_clear:N \l_@@_fa_tl
  \dim_zero:N \l_@@_minx_dim
  \dim_zero:N \l_@@_miny_dim
  \dim_zero:N \l_@@_maxx_dim
  \dim_zero:N \l_@@_maxy_dim

  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

  \tl_clear:N \l_@@_ip_tl
  \tl_put_right:Nx \l_@@_ip_tl
  {
    {\dim_use:N \l_@@_tmpa_dim}
    {\dim_use:N \l_@@_tmpb_dim}
  }
  \tl_put_right:Nx \l_@@_fp_tl
  {
    {\dim_use:N \l_@@_tmpa_dim}
    {\dim_use:N \l_@@_tmpb_dim}
  }

  \dim_set_eq:NN \l_@@_minx_dim \l_@@_tmpa_dim
  \dim_set_eq:NN \l_@@_miny_dim \l_@@_tmpb_dim
  \dim_set_eq:NN \l_@@_maxx_dim \l_@@_tmpa_dim
  \dim_set_eq:NN \l_@@_maxy_dim \l_@@_tmpb_dim

  \tl_set:Nn \l_@@_tmpd_tl {}
  \bool_set_false:N \l_@@_closed_bool
  \tl_put_left:Nx \l_@@_tmpd_tl
  {
    {\dim_use:N \l_@@_tmpa_dim}
    {\dim_use:N \l_@@_tmpb_dim}
  }

  \tl_set:Nx \l_@@_ia_tl {\tl_head:N \l_@@_tmpa_tl}

  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_tmpa_tl
  }
  {
    \tl_set:Nx \l_@@_tmpc_tl {\tl_head:N \l_@@_tmpa_tl}
    \tl_set_eq:NN \l_@@_fa_tl \l_@@_tmpc_tl
    \int_incr:N \l_@@_l_int

    \tl_case:NnTF \l_@@_tmpc_tl
    {
      \g_@@_moveto_tl {
        
        \bool_if:NT \l_@@_closed_bool
        {
          \tl_put_right:NV \l_@@_tmpd_tl \g_@@_closepath_tl
          \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpd_tl}
          \tl_put_right:Nx \l_@@_tmpd_tl
          {
            { \tl_head:N \l_@@_tmpd_tl }
            { \tl_head:N \l_@@_tmpb_tl }
          }
        }
        \bool_set_false:N \l_@@_closed_bool
        \tl_put_left:NV \l_@@_tmpd_tl \g_@@_moveto_tl
        \tl_put_left:NV \l_@@_rp_tl \l_@@_tmpd_tl
        \tl_clear:N \l_@@_tmpd_tl
        \int_incr:N \l_@@_nc_int
      }
      \g_@@_lineto_tl {
        \tl_put_left:NV \l_@@_tmpd_tl \g_@@_lineto_tl
        \int_incr:N \l_@@_rl_int
      }
      \g_@@_curveto_tl {
        \tl_put_left:NV \l_@@_tmpd_tl \g_@@_curvetoa_tl
        \int_incr:N \l_@@_rl_int
      }
      \g_@@_curvetoa_tl {
        \tl_put_left:NV \l_@@_tmpd_tl \g_@@_curveto_tl
      }
      \g_@@_curvetob_tl {
        \tl_put_left:NV \l_@@_tmpd_tl \g_@@_curvetob_tl
      }
    }
    {
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

      \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

      \dim_set:Nn \l_@@_minx_dim {\dim_min:nn { \l_@@_minx_dim} {\l_@@_tmpa_dim}}
      \dim_set:Nn \l_@@_miny_dim {\dim_min:nn { \l_@@_miny_dim} {\l_@@_tmpb_dim}}
      \dim_set:Nn \l_@@_maxx_dim {\dim_max:nn { \l_@@_maxx_dim} {\l_@@_tmpa_dim}}
      \dim_set:Nn \l_@@_maxy_dim {\dim_max:nn { \l_@@_maxy_dim} {\l_@@_tmpb_dim}}

      \tl_put_left:Nx \l_@@_tmpd_tl
      {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }

      \tl_set:Nx \l_@@_fp_tl
      {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }
    }
    {
      \tl_if_eq:NNTF \l_@@_tmpc_tl \g_@@_closepath_tl
      {
        \bool_set_true:N \l_@@_closed_bool
      }
      {
        \msg_warning:nnx { spath3 } { unknown path construction } {\l_@@_tmpc_tl }
      }

      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

    }
  }

  \bool_if:NT \l_@@_closed_bool
  {
    \tl_put_right:NV \l_@@_tmpd_tl \g_@@_closepath_tl
    \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpd_tl}
    \tl_put_right:Nx \l_@@_tmpd_tl
    {
      { \tl_head:N \l_@@_tmpd_tl }
      { \tl_head:N \l_@@_tmpb_tl }
    }
  }

  \bool_set_false:N \l_@@_closed_bool
  \tl_put_left:NV \l_@@_tmpd_tl \g_@@_moveto_tl
  \tl_put_left:NV \l_@@_rp_tl \l_@@_tmpd_tl

  \spath_put:nnV {#1} {reverse path} \l_@@_rp_tl
  \spath_put:nnV {#1} {length} \l_@@_l_int
  \spath_put:nnV {#1} {real length} \l_@@_rl_int
  \spath_put:nnV {#1} {number of components} \l_@@_nc_int
  \spath_put:nnV {#1} {initial point} \l_@@_ip_tl
  \spath_put:nnV {#1} {final point} \l_@@_fp_tl
  \spath_put:nnV {#1} {initial action} \l_@@_ia_tl
  \spath_put:nnV {#1} {final action} \l_@@_fa_tl

  \tl_clear:N \l_@@_tmpb_tl
  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_use:N \l_@@_minx_dim}
    {\dim_use:N \l_@@_miny_dim}
  }
  \spath_put:nnV {#1} {min bb} \l_@@_tmpb_tl

  \tl_clear:N \l_@@_tmpb_tl
  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_use:N \l_@@_maxx_dim}
    {\dim_use:N \l_@@_maxy_dim}
  }
  \spath_put:nnV {#1} {max bb} \l_@@_tmpb_tl


  \@@_gto_tl:nN {#1} \l_@@_smuggle_tl
  \group_end:
  \@@_from_tl:nV {#1} \l_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_globalise:n}
% Takes all of the data generated for an \Verb+spath+ and promotes it to global (some of the data may have been automatically generated so this avoids duplicating a load of code).
%
% There's no point in globalising just \emph{part} of the spath data structure.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_globalise:n #1
{
  \group_begin:
  \tl_map_inline:Nn \g_@@_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \@@_get:nnN {#1} {##1} \l_@@_tmpa_tl
      \spath_gput:nnV {#1} {##1} \l_@@_tmpa_tl
    }
  }
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Path Manipulation}
%
% \begin{macro}[internal]{\spath_translate:nnn}
% Translates a path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_translate:nnn #1#2#3
{
  \tl_map_inline:Nn \g_@@_moveable_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \group_begin:
      \@@_get:nnN {#1} {##1} \l_@@_tmpa_tl

      \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl + #2}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl + #3}
      \tl_clear:N \l_@@_tmpb_tl
      \tl_put_right:Nx \l_@@_tmpb_tl
      {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }

      \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
      \group_end:
      \spath_put:nnV {#1} {##1} \l_@@_smuggle_tl
    }
  }
  \tl_map_inline:Nn \g_@@_path_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \group_begin:
      \@@_get:nnN {#1} {##1} \l_@@_tmpa_tl
      \tl_clear:N \l_@@_tmpb_tl
      \bool_until_do:nn {
        \tl_if_empty_p:N \l_@@_tmpa_tl
      }
      {
        \tl_put_right:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        
        \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl + #2}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

        \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl + #3}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

        \tl_put_right:Nx \l_@@_tmpb_tl
        {
          {\dim_use:N \l_@@_tmpa_dim}
          {\dim_use:N \l_@@_tmpb_dim}
        }
      }
      \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
      \group_end:
      \spath_put:nnV {#1} {##1} \l_@@_smuggle_tl
    }
  }
}

\cs_generate_variant:Nn \spath_translate:nnn {nxx}
%    \end{macrocode}
%
% This variant allows for passing the coordinates as a single braced group as it strips off the outer braces of the second argument.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_translate:nn #1#2
{
  \spath_translate:nnn {#1} #2
}

\cs_generate_variant:Nn \spath_translate:nn {nV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_scale:nnn}
% Scale a path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_scale:nnn #1#2#3
{
  \tl_map_inline:Nn \g_@@_moveable_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \group_begin:
      \@@_get:nnN {#1} {##1} \l_@@_tmpa_tl

      \fp_set:Nn \l_@@_tmpa_fp {\tl_head:N \l_@@_tmpa_tl * #2}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \fp_set:Nn \l_@@_tmpb_fp {\tl_head:N \l_@@_tmpa_tl * #3}
      \tl_clear:N \l_@@_tmpb_tl
      \tl_put_right:Nx \l_@@_tmpb_tl
      {
        {\fp_to_dim:N \l_@@_tmpa_fp}
        {\fp_to_dim:N \l_@@_tmpb_fp}
      }
      \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
      \group_end:
      \spath_put:nnV {#1} {##1} \l_@@_smuggle_tl
    }
  }
  \tl_map_inline:Nn \g_@@_path_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \group_begin:
      \@@_get:nnN {#1} {##1} \l_@@_tmpa_tl
      \tl_clear:N \l_@@_tmpb_tl
      \bool_until_do:nn {
        \tl_if_empty_p:N \l_@@_tmpa_tl
      }
      {
        \tl_put_right:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        
        \fp_set:Nn \l_@@_tmpa_fp {\tl_head:N \l_@@_tmpa_tl * #2}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

        \fp_set:Nn \l_@@_tmpb_fp {\tl_head:N \l_@@_tmpa_tl * #3}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

        \tl_put_right:Nx \l_@@_tmpb_tl
        {
          {\fp_to_dim:N \l_@@_tmpa_fp}
          {\fp_to_dim:N \l_@@_tmpb_fp}
        }
      }
      \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
      \group_end:
      \spath_put:nnV {#1} {##1} \l_@@_smuggle_tl
    }
  }
}
\cs_generate_variant:Nn \spath_scale:nnn {nxx}
%    \end{macrocode}
%
% This variant allows for passing the coordinates as a single braced group as it strips off the outer braces of the second argument.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_scale:nn #1#2
{
  \spath_scale:nnn {#1} #2
}

\cs_generate_variant:Nn \spath_scale:nn {nV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_transform:nnnnnnn}
% Applies an affine (matrix and vector) transformation to path.
% The matrix is specified in rows first.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_transform:nnnnnnn #1#2#3#4#5#6#7
{
  \tl_map_inline:Nn \g_@@_moveable_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \group_begin:
      \@@_get:nnN {#1} {##1} \l_@@_tmpa_tl
      \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpb_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_head:N \l_@@_tmpa_tl}
      \fp_set:Nn \l_@@_tmpa_fp {\l_@@_tmpa_tl * #2 + \l_@@_tmpb_tl * #3 + #6}
      \fp_set:Nn \l_@@_tmpb_fp {\l_@@_tmpa_tl * #4 + \l_@@_tmpb_tl * #5 + #7}
      \tl_clear:N \l_@@_tmpb_tl
      \tl_put_right:Nx \l_@@_tmpb_tl
      {
        {\fp_to_dim:N \l_@@_tmpa_fp}
        {\fp_to_dim:N \l_@@_tmpb_fp}
      }

      \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
      \group_end:
      \spath_put:nnV {#1} {##1} \l_@@_smuggle_tl
    }
  }
  \tl_map_inline:Nn \g_@@_path_attributes
  {
    \spath_if_in:nnT {#1} {##1}
    {
      \group_begin:
      \@@_get:nnN {#1} {##1} \l_@@_tmpa_tl
      \tl_clear:N \l_@@_tmpb_tl
      \bool_until_do:nn {
        \tl_if_empty_p:N \l_@@_tmpa_tl
      }
      {
        \tl_put_right:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_tmpa_tl {\tl_head:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

        \fp_set:Nn \l_@@_tmpa_fp {\l_tmpa_tl * #2 + \l_tmpb_tl * #3 + #6}
        \fp_set:Nn \l_@@_tmpb_fp {\l_tmpa_tl * #4 + \l_tmpb_tl * #5 + #7}
        \tl_put_right:Nx \l_@@_tmpb_tl
        {
          {\fp_to_dim:N \l_@@_tmpa_fp}
          {\fp_to_dim:N \l_@@_tmpb_fp}
        }
      }

      \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
      \group_end:
      \spath_put:nnV {#1} {##1} \l_@@_smuggle_tl
    }
  }
}

\cs_generate_variant:Nn \spath_transform:nnnnnnn {nxxxxxx}
%    \end{macrocode}
%
% This variant allows for passing the coordinates as a single braced group as it strips off the outer braces of the second argument.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_transform:nn #1#2
{
  \spath_transform:nnnnnnn {#1} #2
}

\cs_generate_variant:Nn \spath_transform:nn {nV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_reverse:n}
% This reverses a path.
% As a lot of the data is invariant under reversing, there isn't a lot to do.
%     \begin{macrocode}
\cs_new_nopar:Npn \spath_reverse:n #1
{
  \spath_if_in:nnF {#1} {reverse path} {
    \use:c {spath_generate_reverse path:n} {#1}
  }
  \spath_swap:nnn {#1} {path} {reverse path}
  \spath_swap:nnn {#1} {initial point} {final point}
  \spath_swap:nnn {#1} {initial action} {final action}
  \@@_get:nnNT {#1} {initial action} \l_@@_tmpa_tl
  {
    \tl_if_eq:NNT \l_@@_tmpa_tl \g_@@_curveto_tl
    {
      \spath_put:nnV {#1} {initial action} \g_@@_curvetoa_tl
    }
  }
  \@@_get:nnNT {#1} {final action} \l_@@_tmpa_tl
  {
    \tl_if_eq:NNT \l_@@_tmpa_tl \g_@@_curvetoa_tl
    {
      \spath_put:nnV {#1} {final action} \g_@@_curveto_tl
    }
  }
}
\cs_generate_variant:Nn \spath_reverse:n {V}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_swap:nnn}
% Swaps two entries, being careful to ensure that their existence (or otherwise) is preserved.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_swap:nnn #1#2#3
{
  \group_begin:
  \tl_gclear:N \l_@@_smuggle_tl
  \@@_get:nnNF {#1} {#2} \l_@@_tmpa_tl {\tl_clear:N \l_@@_tmpa_tl}
  \@@_get:nnNF {#1} {#3} \l_@@_tmpb_tl {\tl_clear:N \l_@@_tmpb_tl}
  \tl_if_empty:NTF \l_@@_tmpb_tl
  {
    \tl_gput_right:Nn \l_@@_smuggle_tl
    {
      \spath_remove:nn {#1} {#2}
    }
  }
  {
    \tl_gput_right:Nn \l_@@_smuggle_tl
    {
      \spath_put:nnn {#1} {#2}
    }
    \asxutils_tl_gput_right_braced:NV \l_@@_smuggle_tl \l_@@_tmpb_tl
  }
  \tl_if_empty:NTF \l_@@_tmpa_tl
  {
    \tl_gput_right:Nn \l_@@_smuggle_tl
    {
      \spath_remove:nn {#1} {#3}
    }
  }
  {
    \tl_gput_right:Nn \l_@@_smuggle_tl
    {
      \spath_put:nnn {#1} {#3}
    }
    \asxutils_tl_gput_right_braced:NV \l_@@_smuggle_tl \l_@@_tmpa_tl
  }
  \group_end:
  \tl_use:N \l_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_weld:nn}
% This welds one path to another, moving the second so that its initial point coincides with the first's final point.
% It is called a \emph{weld} because the initial move of the second path is removed.
% The first path is updated, the second is not modified.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_weld:nn #1#2
{
  \spath_generate_finalaction:n {#1}
  \spath_generate_finalpoint:n {#1}
  \spath_generate_initialpoint:n {#2}

  \group_begin:
  \spath_clone:nn {#2} {tmp_path}
  \spath_get:nnN {#1} {final point} \l_@@_tmpa_tl

  \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}

  \spath_get:nnN {tmp_path} {initial point} \l_@@_tmpa_tl

  \dim_sub:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_sub:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}

  \spath_translate:nxx {tmp_path} {\dim_use:N \l_@@_tmpa_dim} {\dim_use:N \l_@@_tmpb_dim}

  \@@_get:nnN {#1} {path} \l_@@_tmpa_tl
  \@@_get:nnN {tmp_path} {path} \l_@@_tmpb_tl
  \@@_get:nnN {#1} {final action} \l_@@_tmpc_tl
  \tl_if_eq:NNF \l_@@_tmpc_tl  \g_@@_closepath_tl
  {
    \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
    \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
    \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl

  \spath_put:nnV {#1} {path} \l_@@_tmpa_tl

  \@@_get:nnNTF {tmp_path} {final point} \l_@@_tmpa_tl
  {
    \spath_put:nnV {#1} {final point} \l_@@_tmpa_tl
  }
  {
    \spath_remove:nn {#1} {final point}
  }

  \@@_get:nnNTF {tmp_path} {final action} \l_@@_tmpa_tl
  {
    \spath_put:nnV {#1} {final action} \l_@@_tmpa_tl
  }
  {
    \spath_remove:nn {#1} {final action}
  }

  \@@_get:nnNT {tmp_path} {min bb} \l_@@_tmpa_tl
  {
    \@@_get:nnNT {#1} {min bb} \l_@@_tmpb_tl
    {
      \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}

      \dim_set:Nn \l_@@_tmpa_dim {\dim_min:nn {\l_@@_tmpa_dim} {\tl_head:N           \l_@@_tmpb_tl}}
      \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
      \dim_set:Nn \l_@@_tmpb_dim {\dim_min:nn {\l_@@_tmpb_dim} {\tl_head:N \l_@@_tmpb_tl}}
      
      \tl_clear:N \l_@@_tmpb_tl
      \tl_put_right:Nx \l_@@_tmpb_tl
      {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }
      \spath_put:nnV {#1} {min bb} \l_@@_tmpb_tl
    }
  }

  \@@_get:nnNT {tmp_path} {max bb} \l_@@_tmpa_tl
  {
    \@@_get:nnNT {#1} {max bb} \l_@@_tmpb_tl
    {
      \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}

      \dim_set:Nn \l_@@_tmpa_dim {\dim_max:nn {\l_@@_tmpa_dim} {\tl_head:N           \l_@@_tmpb_tl}}
      \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
      \dim_set:Nn \l_@@_tmpb_dim {\dim_max:nn {\l_@@_tmpb_dim} {\tl_head:N \l_@@_tmpb_tl}}
      
      \tl_clear:N \l_@@_tmpb_tl
      \tl_put_right:Nx \l_@@_tmpb_tl
      {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }
      \spath_put:nnV {#1} {max bb} \l_@@_tmpb_tl
    }
  }
  
  \@@_get:nnNT {tmp_path} {reverse path} \l_@@_tmpa_tl
  {
    \@@_get:nnNT {#1} {reverse path} \l_@@_tmpb_tl
    {
      \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
      \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
      \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
      \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl

      \spath_put:nnV {#1} {reverse path} \l_@@_tmpa_tl
    }
  }

  \@@_get:nnNT {tmp_path} {length} \l_@@_tmpa_tl
  {
    \@@_get:nnNT {#1} {length} \l_@@_tmpb_tl
    {
      \int_set:Nn \l_@@_tmpa_int {\l_@@_tmpa_tl + \l_@@_tmpb_tl - 1}
      \spath_put:nnV {#1} {length} \l_@@_tmpa_int
    }
  }

  \@@_get:nnNT {tmp_path} {real length} \l_@@_tmpa_tl
  {
    \@@_get:nnNT {#1} {real length} \l_@@_tmpb_tl
    {
      \int_set:Nn \l_@@_tmpa_int {\l_@@_tmpa_tl + \l_@@_tmpb_tl}
      \spath_put:nnV {#1} {real length} \l_@@_tmpa_int
    }
  }

  \@@_get:nnNT {tmp_path} {number of components} \l_@@_tmpa_tl
  {
    \@@_get:nnNT {#1} {number of components} \l_@@_tmpb_tl
    {
      \int_set:Nn \l_@@_tmpa_int {\l_@@_tmpa_tl + \l_@@_tmpb_tl - 1}
      \spath_put:nnV {#1} {number of components} \l_@@_tmpa_int
    }
  }
  \@@_gto_tl:nN {#1} \l_@@_smuggle_tl
  \group_end:
  \@@_from_tl:nV {#1} \l_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_prepend_no_move:nn}
% Prepend the path from the second \Verb+spath+ to the first, removing
% the adjoining move.  
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_prepend_no_move:nn #1#2
{
  \spath_if_exist:nT {#2}
  {
    \group_begin:
    \@@_get:nnN {#2} {path} \l_@@_tmpa_tl
    \@@_get:nnN {#1} {path} \l_@@_tmpb_tl
    \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
    \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
    \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
    \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
    \spath_put:nnV {#1} {path} \l_@@_tmpa_tl

    \spath_if_in:nnTF {#2} {initial point}
    {
      \@@_get:nnN {#2} {initial point} \l_@@_tmpa_tl
      \spath_put:nnV {#1} {initial point} \l_@@_tmpa_tl
    }
    {
      \spath_remove:nn {#1} {initial point}
    }

    \spath_if_in:nnTF {#2} {initial action}
    {
      \@@_get:nnN {#2} {initial action} \l_@@_tmpa_tl
      \spath_put:nnV {#1} {initial action} \l_@@_tmpa_tl
    }
    {
      \spath_remove:nn {#1} {initial action}
    }

    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {length}
      &&
      \spath_if_in_p:nn {#2} {length}
    }
    {
      \@@_get:nnN {#1} {length} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {length} \l_@@_tmpb_tl
      \spath_put:nnx {#1} {length} {\int_eval:n {\l_@@_tmpa_tl +
          \l_@@_tmpb_tl - 1}}
    }
    {
      \spath_remove:nn {#1} {length}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {real length}
      &&
      \spath_if_in_p:nn {#2} {real length}
    }
    {
      \@@_get:nnN {#1} {real length} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {real length} \l_@@_tmpb_tl
      \spath_put:nnx {#1} {real length} {\int_eval:n {\l_@@_tmpa_tl +
          \l_@@_tmpb_tl }}
    }
    {
      \spath_remove:nn {#1} {real length}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {number of components}
      &&
      \spath_if_in_p:nn {#2} {number of components}
    }
    {
      \@@_get:nnN {#1} {number of components} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {number of components} \l_@@_tmpb_tl
      \spath_put:nnx {#1} {number of components} {\int_eval:n {\l_@@_tmpa_tl +
          \l_@@_tmpb_tl - 1}}
    }
    {
      \spath_remove:nn {#1} {number of components}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {min bb}
      &&
      \spath_if_in_p:nn {#2} {min bb}
    }
    {
      \@@_get:nnN {#1} {min bb} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {min bb} \l_@@_tmpb_tl
      \dim_set:Nn \l_@@_tmpa_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {1}} {\tl_item:Nn
          \l_@@_tmpb_tl {1}}}
      \dim_set:Nn \l_@@_tmpb_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {2}} {\tl_item:Nn
          \l_@@_tmpb_tl {2}}}
      \spath_put:nnx {#1} {min bb} {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }
    }
    {
      \spath_remove:nn {#1} {min bb}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {max bb}
      &&
      \spath_if_in_p:nn {#2} {max bb}
    }
    {
      \@@_get:nnN {#1} {max bb} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {max bb} \l_@@_tmpb_tl
      \dim_set:Nn \l_@@_tmpa_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {1}} {\tl_item:Nn
          \l_@@_tmpb_tl {1}}}
      \dim_set:Nn \l_@@_tmpb_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {2}} {\tl_item:Nn
          \l_@@_tmpb_tl {2}}}
      \spath_put:nnx {#1} {max bb} {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }
    }
    {
      \spath_remove:nn {#1} {max bb}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {reverse path}
      &&
      \spath_if_in_p:nn {#2} {reverse path}
    }
    {
      \@@_get:nnN {#1} {reverse path} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {reverse path} \l_@@_tmpb_tl
      \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
      \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
      \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
      \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
      \spath_put:nnV {#1} {reverse path} \l_@@_tmpb_tl
    }
    {
      \spath_remove:nn {#1} {reverse path}
    }
    \@@_gto_tl:nN {#1} \l_@@_smuggle_tl
    \group_end:
    \@@_from_tl:nV {#1} \l_@@_smuggle_tl
  }
}
\cs_generate_variant:Nn \spath_prepend_no_move:nn {VV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_prepend:nn}
% Prepend the path from the second \Verb+spath+ to the first.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_prepend:nn #1#2
{
  \spath_if_exist:nT {#2}
  {
    \group_begin:
    \@@_get:nnN {#2} {path} \l_@@_tmpa_tl
    \@@_get:nnN {#1} {path} \l_@@_tmpb_tl
    \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
    \spath_put:nnV {#1} {path} \l_@@_tmpa_tl

    \spath_if_in:nnTF {#2} {initial point}
    {
      \@@_get:nnN {#2} {initial point} \l_@@_tmpa_tl
      \spath_put:nnV {#1} {initial point} \l_@@_tmpa_tl
    }
    {
      \spath_remove:nn {#1} {initial point}
    }

    \spath_if_in:nnTF {#2} {initial action}
    {
      \@@_get:nnN {#2} {initial action} \l_@@_tmpa_tl
      \spath_put:nnV {#1} {initial action} \l_@@_tmpa_tl
    }
    {
      \spath_remove:nn {#1} {initial action}
    }

    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {length}
      &&
      \spath_if_in_p:nn {#2} {length}
    }
    {
      \@@_get:nnN {#1} {length} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {length} \l_@@_tmpb_tl
      \spath_put:nnx {#1} {length} {\int_eval:n {\l_@@_tmpa_tl +
          \l_@@_tmpb_tl - 1}}
    }
    {
      \spath_remove:nn {#1} {length}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {real length}
      &&
      \spath_if_in_p:nn {#2} {real length}
    }
    {
      \@@_get:nnN {#1} {real length} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {real length} \l_@@_tmpb_tl
      \spath_put:nnx {#1} {real length} {\int_eval:n {\l_@@_tmpa_tl +
          \l_@@_tmpb_tl }}
    }
    {
      \spath_remove:nn {#1} {real length}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {number of components}
      &&
      \spath_if_in_p:nn {#2} {number of components}
    }
    {
      \@@_get:nnN {#1} {number of components} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {number of components} \l_@@_tmpb_tl
      \spath_put:nnx {#1} {number of components} {\int_eval:n {\l_@@_tmpa_tl +
          \l_@@_tmpb_tl - 1}}
    }
    {
      \spath_remove:nn {#1} {number of components}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {min bb}
      &&
      \spath_if_in_p:nn {#2} {min bb}
    }
    {
      \@@_get:nnN {#1} {min bb} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {min bb} \l_@@_tmpb_tl
      \dim_set:Nn \l_@@_tmpa_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {1}} {\tl_item:Nn
          \l_@@_tmpb_tl {1}}}
      \dim_set:Nn \l_@@_tmpb_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {2}} {\tl_item:Nn
          \l_@@_tmpb_tl {2}}}
      \spath_put:nnx {#1} {min bb} {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }
    }
    {
      \spath_remove:nn {#1} {min bb}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {max bb}
      &&
      \spath_if_in_p:nn {#2} {max bb}
    }
    {
      \@@_get:nnN {#1} {max bb} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {max bb} \l_@@_tmpb_tl
      \dim_set:Nn \l_@@_tmpa_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {1}} {\tl_item:Nn
          \l_@@_tmpb_tl {1}}}
      \dim_set:Nn \l_@@_tmpb_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {2}} {\tl_item:Nn
          \l_@@_tmpb_tl {2}}}
      \spath_put:nnx {#1} {max bb} {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }
    }
    {
      \spath_remove:nn {#1} {max bb}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {reverse path}
      &&
      \spath_if_in_p:nn {#2} {reverse path}
    }
    {
      \@@_get:nnN {#1} {reverse path} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {reverse path} \l_@@_tmpb_tl
      \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
      \spath_put:nnV {#1} {reverse path} \l_@@_tmpb_tl
    }
    {
      \spath_remove:nn {#1} {reverse path}
    }
    \@@_gto_tl:nN {#1} \l_@@_smuggle_tl
    \group_end:
    \@@_from_tl:nV {#1} \l_@@_smuggle_tl
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_append_no_move:nn}
% Append the path from the second \Verb+spath+ to the first, removing
% the adjoining move.  
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_append_no_move:nn #1#2
{
  \spath_if_exist:nT {#2}
  {
    \group_begin:
    \spath_get:nnN {#1} {path} \l_@@_tmpa_tl
    \spath_get:nnN {#2} {path} \l_@@_tmpb_tl
    \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
    \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
    \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
    \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
    \spath_put:nnV {#1} {path} \l_@@_tmpa_tl
    \spath_if_in:nnTF {#2} {final point}
    {
      \@@_get:nnN {#2} {final point} \l_@@_tmpa_tl
      \spath_put:nnV {#1} {final point} \l_@@_tmpa_tl
    }
    {
      \spath_remove:nn {#1} {final point}
    }
    \spath_if_in:nnTF {#2} {final action}
    {
      \@@_get:nnN {#2} {final action} \l_@@_tmpa_tl
      \spath_put:nnV {#1} {final action} \l_@@_tmpa_tl
    }
    {
      \spath_remove:nn {#1} {final action}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {length}
      &&
      \spath_if_in_p:nn {#2} {length}
    }
    {
      \@@_get:nnN {#1} {length} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {length} \l_@@_tmpb_tl
      \spath_put:nnx {#1} {length} {\int_eval:n {\l_@@_tmpa_tl +
          \l_@@_tmpb_tl - 1}}
    }
    {
      \spath_remove:nn {#1} {length}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {real length}
      &&
      \spath_if_in_p:nn {#2} {real length}
    }
    {
      \@@_get:nnN {#1} {real length} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {real length} \l_@@_tmpb_tl
      \spath_put:nnx {#1} {real length} {\int_eval:n {\l_@@_tmpa_tl +
          \l_@@_tmpb_tl }}
    }
    {
      \spath_remove:nn {#1} {real length}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {number of components}
      &&
      \spath_if_in_p:nn {#2} {number of components}
    }
    {
      \@@_get:nnN {#1} {number of components} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {number of components} \l_@@_tmpb_tl
      \spath_put:nnx {#1} {number of components} {\int_eval:n {\l_@@_tmpa_tl +
          \l_@@_tmpb_tl - 1}}
    }
    {
      \spath_remove:nn {#1} {number of components}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {min bb}
      &&
      \spath_if_in_p:nn {#2} {min bb}
    }
    {
      \@@_get:nnN {#1} {min bb} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {min bb} \l_@@_tmpb_tl
      \dim_set:Nn \l_@@_tmpa_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {1}} {\tl_item:Nn
          \l_@@_tmpb_tl {1}}}
      \dim_set:Nn \l_@@_tmpb_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {2}} {\tl_item:Nn
          \l_@@_tmpb_tl {2}}}
      \spath_put:nnx {#1} {min bb} {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }
    }
    {
      \spath_remove:nn {#1} {min bb}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {max bb}
      &&
      \spath_if_in_p:nn {#2} {max bb}
    }
    {
      \@@_get:nnN {#1} {max bb} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {max bb} \l_@@_tmpb_tl
      \dim_set:Nn \l_@@_tmpa_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {1}} {\tl_item:Nn
          \l_@@_tmpb_tl {1}}}
      \dim_set:Nn \l_@@_tmpb_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {2}} {\tl_item:Nn
          \l_@@_tmpb_tl {2}}}
      \spath_put:nnx {#1} {max bb} {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }
    }
    {
      \spath_remove:nn {#1} {max bb}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {reverse path}
      &&
      \spath_if_in_p:nn {#2} {reverse path}
    }
    {
      \@@_get:nnN {#2} {reverse path} \l_@@_tmpa_tl
      \@@_get:nnN {#1} {reverse path} \l_@@_tmpb_tl
      \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
      \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
      \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
      \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
      \spath_put:nnV {#1} {reverse path} \l_@@_tmpb_tl
    }
    {
      \spath_remove:nn {#1} {reverse path}
    }
    \@@_gto_tl:nN {#1} \l_@@_smuggle_tl
    \group_end:
    \@@_from_tl:nV {#1} \l_@@_smuggle_tl
  }
}
\cs_generate_variant:Nn \spath_append_no_move:nn {VV}
%    \end{macrocode}
%
% \end{macro}
%
% \begin{macro}[internal]{\spath_append:nn}
% Append the path from the second \Verb+spath+ to the first.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_append:nn #1#2
{
  \spath_if_exist:nT {#2}
  {
    \group_begin:
    \spath_get:nnN {#1} {path} \l_@@_tmpa_tl
    \spath_get:nnN {#2} {path} \l_@@_tmpb_tl
    \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
    \spath_put:nnV {#1} {path} \l_@@_tmpa_tl
    \spath_if_in:nnTF {#2} {final point}
    {
      \@@_get:nnN {#2} {final point} \l_@@_tmpa_tl
      \spath_put:nnV {#1} {final point} \l_@@_tmpa_tl
    }
    {
      \spath_remove:nn {#1} {final point}
    }
    \spath_if_in:nnTF {#2} {final action}
    {
      \@@_get:nnN {#2} {final action} \l_@@_tmpa_tl
      \spath_put:nnV {#1} {final action} \l_@@_tmpa_tl
    }
    {
      \spath_remove:nn {#1} {final action}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {length}
      &&
      \spath_if_in_p:nn {#2} {length}
    }
    {
      \@@_get:nnN {#1} {length} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {length} \l_@@_tmpb_tl
      \spath_put:nnx {#1} {length} {\int_eval:n {\l_@@_tmpa_tl +
          \l_@@_tmpb_tl - 1}}
    }
    {
      \spath_remove:nn {#1} {length}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {real length}
      &&
      \spath_if_in_p:nn {#2} {real length}
    }
    {
      \@@_get:nnN {#1} {real length} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {real length} \l_@@_tmpb_tl
      \spath_put:nnx {#1} {real length} {\int_eval:n {\l_@@_tmpa_tl +
          \l_@@_tmpb_tl }}
    }
    {
      \spath_remove:nn {#1} {real length}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {number of components}
      &&
      \spath_if_in_p:nn {#2} {number of components}
    }
    {
      \@@_get:nnN {#1} {number of components} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {number of components} \l_@@_tmpb_tl
      \spath_put:nnx {#1} {number of components} {\int_eval:n {\l_@@_tmpa_tl +
          \l_@@_tmpb_tl - 1}}
    }
    {
      \spath_remove:nn {#1} {number of components}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {min bb}
      &&
      \spath_if_in_p:nn {#2} {min bb}
    }
    {
      \@@_get:nnN {#1} {min bb} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {min bb} \l_@@_tmpb_tl
      \dim_set:Nn \l_@@_tmpa_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {1}} {\tl_item:Nn
          \l_@@_tmpb_tl {1}}}
      \dim_set:Nn \l_@@_tmpb_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {2}} {\tl_item:Nn
          \l_@@_tmpb_tl {2}}}
      \spath_put:nnx {#1} {min bb} {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }
    }
    {
      \spath_remove:nn {#1} {min bb}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {max bb}
      &&
      \spath_if_in_p:nn {#2} {max bb}
    }
    {
      \@@_get:nnN {#1} {max bb} \l_@@_tmpa_tl
      \@@_get:nnN {#2} {max bb} \l_@@_tmpb_tl
      \dim_set:Nn \l_@@_tmpa_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {1}} {\tl_item:Nn
          \l_@@_tmpb_tl {1}}}
      \dim_set:Nn \l_@@_tmpb_dim {\dim_min:nn {\tl_item:Nn
          \l_@@_tmpa_tl {2}} {\tl_item:Nn
          \l_@@_tmpb_tl {2}}}
      \spath_put:nnx {#1} {max bb} {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }
    }
    {
      \spath_remove:nn {#1} {max bb}
    }
    \bool_if:nTF
    {
      \spath_if_in_p:nn {#1} {reverse path}
      &&
      \spath_if_in_p:nn {#2} {reverse path}
    }
    {
      \@@_get:nnN {#2} {reverse path} \l_@@_tmpa_tl
      \@@_get:nnN {#1} {reverse path} \l_@@_tmpb_tl
      \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
      \spath_put:nnV {#1} {reverse path} \l_@@_tmpb_tl
    }
    {
      \spath_remove:nn {#1} {reverse path}
    }
    \@@_gto_tl:nN {#1} \l_@@_smuggle_tl
    \group_end:
    \@@_from_tl:nV {#1} \l_@@_smuggle_tl
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_bake_round:n}
% Ought to clear the reverse path, if set.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_bake_round:n #1
{
  \group_begin:
  \@@_get:nnN {#1} {path} \l_@@_tmpa_tl
  \pgf@@@@processround \l_@@_tmpa_tl\l_@@_tmpb_tl
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \spath_put:nnV {#1} {path} \l_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_close_path:n}
% Appends a close path to the end of the path, and to the end of the reverse path.
% For now, the point is the initial or final point (respectively).
% To be future proof, it ought to be the point of the adjacent move to.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_close_path:n #1
{
  \group_begin:
  \spath_get:nnN {#1} {initial point} \l_@@_tmpb_tl
  \@@_get:nnN {#1} {path} \l_@@_tmpa_tl
  \tl_put_right:NV \l_@@_tmpa_tl \g_@@_closepath_tl
  \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \spath_put:nnV {#1} {path} \l_@@_smuggle_tl
  \spath_if_in:nnT {#1} {reverse path}
  {
    \group_begin:
    \spath_get:nnN {#1} {final point} \l_@@_tmpb_tl
    \@@_get:nnN {#1} {reverse path} \l_@@_tmpa_tl
    \tl_put_right:NV \l_@@_tmpa_tl \g_@@_closepath_tl
    \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
    \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpa_tl
    \group_end:
    \spath_put:nnV {#1} {reverse path} \l_@@_smuggle_tl
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_open_path:n}
% Removes all close paths from the path, replacing them by \Verb+lineto+ if they move any distance.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_open_path:n #1
{
  \group_begin:
  \@@_get:nnN {#1} {path} \l_@@_tmpa_tl
  \tl_clear:N \l_@@_tmpb_tl
  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_tmpa_tl
  }
  {
    \tl_set:Nx \l_@@_tmpc_tl {\tl_head:N \l_@@_tmpa_tl}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

    \tl_case:NnF \l_@@_tmpc_tl
    {
      \g_@@_closepath_tl {

        \bool_if:nF
        {
          \dim_compare_p:n
          {
            \l_@@_move_x_dim == \l_@@_tmpa_dim
          }
          &&
          \dim_compare_p:n
          {
            \l_@@_move_y_dim == \l_@@_tmpb_dim
          }
        }
        {
          \tl_put_right:NV \l_@@_tmpb_tl \g_@@_lineto_tl
        
          \tl_put_right:Nx \l_@@_tmpb_tl {
            { \dim_use:N \l_@@_move_x_dim }
            { \dim_use:N \l_@@_move_y_dim }
          }
        }
        
        \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      }

      \g_@@_moveto_tl {
        \tl_put_right:NV \l_@@_tmpb_tl \l_@@_tmpc_tl
        
        \dim_set:Nn \l_@@_move_x_dim {\tl_head:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        \dim_set:Nn \l_@@_move_y_dim {\tl_head:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

        \tl_put_right:Nx \l_@@_tmpb_tl {
          { \dim_use:N \l_@@_move_x_dim }
          { \dim_use:N \l_@@_move_y_dim }
        }

        \dim_set_eq:NN \l_@@_tmpa_dim \l_@@_move_x_dim
        \dim_set_eq:NN \l_@@_tmpb_dim \l_@@_move_y_dim
      }
    }
    {
      \tl_put_right:NV \l_@@_tmpb_tl \l_@@_tmpc_tl
      
      \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

      \tl_put_right:Nx \l_@@_tmpb_tl {
        { \dim_use:N \l_@@_tmpa_dim }
        { \dim_use:N \l_@@_tmpb_dim }
      }
    }
  }
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \spath_put:nnV {#1} {path} \l_@@_smuggle_tl
  \spath_remove:nn {#1} {reverse path}
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Iteration Functions}
%
% There are two types of iteration functions.
% One works on the \emph{components} of a path, and the other on the \emph{segments}.%
% Furthermore, we sometimes want to call the iteration on a token list containing a PGF soft path and sometimes on an already existing spath object.
% The iterations actually just work on the soft path, so the latter is a wrapper around the former.
% If the function name include \Verb+map_path+ then it works on a soft path, if it just says \Verb+map+ then on an spath object.
%
% \begin{macro}[internal]{\spath_map_path_components_function:NN}
% This iterates through the components of a pgf soft path (given as a token list variable), applying the inline function to each.
%
% The inline function should take a single \Verb+n+ type argument which will be the component of the path.
%
% This one works on the path itself.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_map_path_components_function:NN #1#2
{
  \tl_set_eq:NN \l_@@_itera_tl #1
  \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
  \tl_put_right:NV \l_@@_itera_tl \g_@@_moveto_tl
  \tl_set_eq:NN \l_@@_iterb_tl \g_@@_moveto_tl
  \bool_do_until:nn {
    \tl_if_empty_p:N \l_@@_itera_tl
  }
  {
    \tl_set:Nx \l_@@_iterc_tl {\tl_head:N \l_@@_itera_tl}
    \tl_if_eq:NNT \l_@@_iterc_tl \g_@@_moveto_tl
    {
      \exp_args:NnV \use:c { @@_map_ \int_use:N \g_@@_map_int :n } \l_@@_iterb_tl
\tl_clear:N \l_@@_iterb_tl
    }
    \tl_if_single:NTF \l_@@_iterc_tl
    {
      \tl_put_right:NV \l_@@_iterb_tl \l_@@_iterc_tl
    }
    {
      \tl_put_right:Nx \l_@@_iterb_tl {{\l_@@_iterc_tl}}
    }
    \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
  }
}
\cs_generate_variant:Nn \spath_map_path_components_function:NN {Nc,cN,cc}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_map_path_components_inline:Nn}
% Inline version of the above.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_map_path_components_inline:Nn #1#2
{
  \int_gincr:N \g_@@_map_int
  \cs_gset:cpn { @@_map_ \int_use:N \g_@@_map_int :n } ##1 {#2}
  \spath_map_path_components_function:Nc #1 { @@_map_ \int_use:N \g_@@_map_int :n }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_map_path_segments_function:NN}
% This iterates through the segments of a soft path applying the specified function to each.
% The specified function should take two \Verb+N+ type arguments.
% The first is a token representing the type of path segment, the second is the path segment itself.
% Note that the segment is a complete path with the appropriate initial move prepended to it.
%
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_map_path_segments_function:NN #1#2
{
  \tl_set_eq:NN \l_@@_itera_tl #1
  \tl_clear:N \l_@@_iterb_tl
  \dim_zero:N \l_@@_itera_dim
  \dim_zero:N \l_@@_iterb_dim

  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_itera_tl
  }
  {
    \tl_set:Nx \l_@@_iterc_tl {\tl_head:N \l_@@_itera_tl}
    \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
    \tl_case:NnF \l_@@_iterc_tl
    {
      \g_@@_lineto_tl
      {
        \tl_set_eq:NN \l_@@_iterb_tl \g_@@_moveto_tl
        \tl_put_right:Nx \l_@@_iterb_tl
        {
          {\dim_use:N \l_@@_itera_dim}
          {\dim_use:N \l_@@_iterb_dim}
        }
        \tl_put_right:NV \l_@@_iterb_tl \g_@@_lineto_tl

        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_itera_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_iterb_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

      }

      \g_@@_curvetoa_tl
      {
        \tl_set_eq:NN \l_@@_iterb_tl \g_@@_moveto_tl
        \tl_put_right:Nx \l_@@_iterb_tl
        {
          {\dim_use:N \l_@@_itera_dim}
          {\dim_use:N \l_@@_iterb_dim}
        }
        \tl_put_right:NV \l_@@_iterb_tl \g_@@_curvetoa_tl

        \prg_replicate:nn {2} {
          \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
          \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
          \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N               \l_@@_itera_tl}}
          \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
          \tl_put_right:Nx \l_@@_iterb_tl {\tl_head:N             \l_@@_itera_tl}
          \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
        }

        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_itera_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_iterb_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

      }

      \g_@@_closepath_tl
      {
        \tl_set_eq:NN \l_@@_iterb_tl \g_@@_moveto_tl
        \tl_put_right:Nx \l_@@_iterb_tl
        {
          {\dim_use:N \l_@@_itera_dim}
          {\dim_use:N \l_@@_iterb_dim}
        }
        \tl_put_right:NV \l_@@_iterb_tl \g_@@_lineto_tl

        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_itera_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_iterb_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

      }
      
    }    
    {

      \tl_set_eq:NN \l_@@_iterb_tl \l_@@_iterc_tl
      \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
      \dim_set:Nn \l_@@_itera_dim {\tl_head:N \l_@@_itera_tl}
      \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

      \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
      \dim_set:Nn \l_@@_iterb_dim {\tl_head:N \l_@@_itera_tl}
      \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
      
    }

    #2 \l_@@_iterc_tl \l_@@_iterb_tl
    \tl_clear:N \l_@@_iterb_tl

  }
}
\cs_generate_variant:Nn \spath_map_path_segments_function:NN {Nc}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_map_path_segments_inline:Nn}
% Inline version of the above, taking a token list for the path.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_map_path_segments_inline:Nn #1#2
{
  \int_gincr:N \g_@@_map_int
  \cs_gset:cpn { @@_map_ \int_use:N \g_@@_map_int :w } ##1 ##2 {#2}
  \spath_map_path_segments_function:Nc #1 { @@_map_ \int_use:N \g_@@_map_int :w }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_map_segments_inline:nn}
% This iterates through the segments of the path of an \Verb+spath+ object, applying the inline function to each.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_map_segments_inline:nn #1#2
{
  \spath_get:nnN {#1} {path} \l_@@_iterp_tl
  \spath_map_path_segments_inline:Nn \l_@@_iterp_tl {#2}
}
\cs_generate_variant:Nn \spath_map_segments_inline:nn {Vn}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_map_segments_function:nN}
% This iterates through the segments of the path of an \Verb+spath+ object, applying the specified function to each.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_map_segments_function:nN #1#2
{
  \spath_get:nnN {#1} {path} \l_@@_iterp_tl
  \spath_map_path_segments_function:NN \l_@@_iterp_tl #2
}
%    \end{macrocode}
% \end{macro}
%
% It is often useful to have lists of spaths.
%
% \begin{macro}[internal]{\spath_map_path_segments_into_list:nN}
% Split a soft path into a list of segments
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_map_path_segments_into_list:NN #1#2
{
  \tl_clear_new:N #2
  
  \spath_map_path_segments_inline:Nn #1 {
    \tl_if_eq:NNF ##1 \g_@@_moveto_tl
    {
      \spath_new_anonymous:N \l_@@_anon_tl
      \spath_put:VnV \l_@@_anon_tl {path} ##2
      \asxutils_tl_put_right_braced:NV #2 \l_@@_anon_tl
    }
  }
}
\cs_generate_variant:Nn \spath_map_path_segments_into_list:NN {Nc, cN, cc}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[internal]{\spath_map_segments_into_list:nN}
% Split an spath into a list of segments
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_map_segments_into_list:nN #1#2
{
  \spath_get:nnN {#1} {path} \l_@@_iterp_tl
  \spath_map_path_segments_into_list:NN \l_@@_iterp_tl #2
}
\cs_generate_variant:Nn \spath_map_segments_into_list:nN {nc}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_map_path_components_into_list:NN}
% This splits a pgf soft path into a token list of spath objects.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_map_path_components_into_list:NN #1#2
{
  \tl_clear:N #2
  \spath_map_path_components_inline:Nn #1 {
    \spath_new_anonymous:N \l_@@_anon_tl
    \spath_put:Vnn \l_@@_anon_tl {path} {##1}
    \asxutils_tl_put_right_braced:NV #2 \l_@@_anon_tl
  }
}
\cs_generate_variant:Nn \spath_map_path_components_into_list:NN {cN, cc, Nc}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_map_components_into_list:NN}
% This splits an spath object into a token list of spath objects.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_map_components_into_list:nN #1#2
{
  \spath_get:nnN {#1} {path} \l_@@_iterp_tl
  \spath_map_path_components_into_list:NN \l_@@_iterp_tl #2
}
\cs_generate_variant:Nn \spath_map_components_into_list:nN {nc}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Splitting Commands}
%
% \begin{macro}[internal]{\spath_split_curve:nnNN}
% Splits a Bezier cubic into pieces.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_split_curve:nnNN #1#2#3#4
{
  \group_begin:
  \tl_set_eq:NN \l_@@_tmpa_tl \g_@@_moveto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl {
    {\tl_item:nn {#2} {2}}
    {\tl_item:nn {#2} {3}}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \g_@@_curvetoa_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
    {
      (1 - #1) * \tl_item:nn {#2} {2} + (#1) * \tl_item:nn {#2} {5}
    }}
    {\fp_to_dim:n
    {
      (1 - #1) * \tl_item:nn {#2} {3} + (#1) * \tl_item:nn {#2} {6}
    }}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \g_@@_curvetob_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
    {
      (1 - #1)^2 * \tl_item:nn {#2} {2} + 2 * (1 - #1) * (#1) * \tl_item:nn {#2} {5} + (#1)^2 * \tl_item:nn {#2} {8}
    }}
    {\fp_to_dim:n
    {
      (1 - #1)^2 * \tl_item:nn {#2} {3} + 2 * (1 - #1) * (#1) * \tl_item:nn {#2} {6} + (#1)^2 * \tl_item:nn {#2} {9}
    }}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \g_@@_curveto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
      {
      (1 - #1)^3 * \tl_item:nn {#2} {2} + 3 * (1 - #1)^2 * (#1) * \tl_item:nn {#2} {5} + 3 * (1 - #1) * (#1)^2 * \tl_item:nn {#2} {8} + (#1)^3 * \tl_item:nn {#2} {11}
    }}
    {\fp_to_dim:n
    {
      (1 - #1)^3 * \tl_item:nn {#2} {3} + 3 * (1 - #1)^2 * (#1) * \tl_item:nn {#2} {6} + 3 * (1 - #1) * (#1)^2 * \tl_item:nn {#2} {9} + (#1)^3 * \tl_item:nn {#2} {12}
    }}
  }
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #3 \l_@@_smuggle_tl
  \group_begin:
  \tl_set_eq:NN \l_@@_tmpa_tl \g_@@_moveto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
      {
      (1 - #1)^3 * \tl_item:nn {#2} {2} + 3 * (1 - #1)^2 * (#1) * \tl_item:nn {#2} {5} + 3 * (1 - #1) * (#1)^2 * \tl_item:nn {#2} {8} + (#1)^3 * \tl_item:nn {#2} {11}
    }}
    {\fp_to_dim:n
    {
      (1 - #1)^3 * \tl_item:nn {#2} {3} + 3 * (1 - #1)^2 * (#1) * \tl_item:nn {#2} {6} + 3 * (1 - #1) * (#1)^2 * \tl_item:nn {#2} {9} + (#1)^3 * \tl_item:nn {#2} {12}
    }}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \g_@@_curvetoa_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
    {
      (1 - #1)^2 * \tl_item:nn {#2} {5} + 2 * (1 - #1) * (#1) * \tl_item:nn {#2} {8} + (#1)^2 * \tl_item:nn {#2} {11}
    }}
    {\fp_to_dim:n
    {
      (1 - #1)^2 * \tl_item:nn {#2} {6} + 2 * (1 - #1) * (#1) * \tl_item:nn {#2} {9} + (#1)^2 * \tl_item:nn {#2} {12}
    }}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \g_@@_curvetob_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
    {
      (1 - #1) * \tl_item:nn {#2} {8} + (#1) * \tl_item:nn {#2} {11}
    }}
    {\fp_to_dim:n
    {
      (1 - #1) * \tl_item:nn {#2} {9} + (#1) * \tl_item:nn {#2} {12}
    }}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \g_@@_curveto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl {
    {\tl_item:nn {#2} {11}}
    {\tl_item:nn {#2} {12}}
  }
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #4 \l_@@_smuggle_tl
}

\cs_generate_variant:Nn \spath_split_curve:nnNN {nVNN, VVNN}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_split_line:nnNN}
% Splits a line segment.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_split_line:nnNN #1#2#3#4
{
  \group_begin:
  \tl_gclear:N \l_@@_smuggle_tl
  \tl_set_eq:NN \l_@@_tmpa_tl \g_@@_moveto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl {
    {\tl_item:nn {#2} {2}}
    {\tl_item:nn {#2} {3}}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \g_@@_lineto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
    {
      (1 - #1) * \tl_item:nn {#2} {2} + (#1) * \tl_item:nn {#2} {5}
    }}
    {\fp_to_dim:n
    {
      (1 - #1) * \tl_item:nn {#2} {3} + (#1) * \tl_item:nn {#2} {6}
    }}
  }
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #3 \l_@@_smuggle_tl
  \group_begin:
  \tl_gclear:N \l_@@_smuggle_tl
  \tl_set_eq:NN \l_@@_tmpa_tl \g_@@_moveto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
    {
      (1 - #1) * \tl_item:nn {#2} {2} + (#1) * \tl_item:nn {#2} {5}
    }}
    {\fp_to_dim:n
    {
      (1 - #1) * \tl_item:nn {#2} {3} + (#1) * \tl_item:nn {#2} {6}
    }}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \g_@@_lineto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl {
    {\tl_item:nn {#2} {5}}
    {\tl_item:nn {#2} {6}}
  }
  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #4 \l_@@_smuggle_tl
}

\cs_generate_variant:Nn \spath_split_line:nnNN {nVNN, VVNN}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\int_new:N \l_@@_split_int
\int_new:N \l_@@_splitat_int
\fp_new:N \l_@@_split_fp
\bool_new:N \l_@@_split_bool
\tl_new:N \l_@@_split_path_tl
\tl_new:N \l_@@_split_patha_tl
\tl_new:N \l_@@_split_pathb_tl
\tl_new:N \l_@@_split_intoa_tl
\tl_new:N \l_@@_split_intob_tl
\dim_new:N \l_@@_splitx_dim
\dim_new:N \l_@@_splity_dim
%    \end{macrocode}
%
% \begin{macro}[internal]{\spath_split_at:nnnn}
% Split an spath according to the parameter generated by the intersection routine
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_split_at:nnnn #1#2#3#4
{
  \group_begin:
  \int_set:Nn \l_@@_splitat_int {\fp_to_int:n {floor(#2) + 1}}
  \fp_set:Nn \l_@@_split_fp {#2 - floor(#2)}
  \int_zero:N \l_@@_split_int
  \bool_set_true:N \l_@@_split_bool

  \spath_get:nnN {#1} {path} \l_@@_split_path_tl
  \tl_clear:N \l_@@_split_patha_tl

  \dim_zero:N \l_@@_splitx_dim
  \dim_zero:N \l_@@_splity_dim

  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_split_path_tl
    ||
    \int_compare_p:n { \l_@@_splitat_int == \l_@@_split_int  }
  }
  {
    \tl_set:Nx \l_@@_tmpc_tl {\tl_head:N \l_@@_split_path_tl}
    \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
    \tl_case:Nn \l_@@_tmpc_tl
    {
      \g_@@_lineto_tl
      {
        \int_incr:N \l_@@_split_int
      }
      \g_@@_curvetoa_tl
      {
        \int_incr:N \l_@@_split_int
      }
    }
    \int_compare:nT { \l_@@_split_int < \l_@@_splitat_int  }
    {
      \tl_put_right:NV \l_@@_split_patha_tl \l_@@_tmpc_tl
      
      \tl_put_right:Nx \l_@@_split_patha_tl
      {{ \tl_head:N \l_@@_split_path_tl }}
      \dim_set:Nn \l_@@_splitx_dim {\tl_head:N \l_@@_split_path_tl}
      \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      
      \tl_put_right:Nx \l_@@_split_patha_tl
      {{ \tl_head:N \l_@@_split_path_tl }}
      \dim_set:Nn \l_@@_splity_dim {\tl_head:N \l_@@_split_path_tl}
      \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      
    }
  }

  \tl_clear:N \l_@@_split_pathb_tl
  \tl_put_right:NV \l_@@_split_pathb_tl \g_@@_moveto_tl
  \tl_put_right:Nx \l_@@_split_pathb_tl
  {
    {\dim_use:N \l_@@_splitx_dim}
    {\dim_use:N \l_@@_splity_dim}
  }
  \tl_case:Nn \l_@@_tmpc_tl
  {
    \g_@@_lineto_tl
    {
      \tl_put_right:NV \l_@@_split_pathb_tl \l_@@_tmpc_tl
      \tl_put_right:Nx \l_@@_split_pathb_tl
      {{ \tl_head:N \l_@@_split_path_tl }}
      \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      
      \tl_put_right:Nx \l_@@_split_pathb_tl
      {{ \tl_head:N \l_@@_split_path_tl }}
      \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      
      \spath_split_line:VVNN \l_@@_split_fp \l_@@_split_pathb_tl
      \l_@@_split_intoa_tl
      \l_@@_split_intob_tl

      \prg_replicate:nn {3} {
        \tl_set:Nx \l_@@_split_intoa_tl {\tl_tail:N \l_@@_split_intoa_tl}
      }

      \tl_put_right:NV \l_@@_split_patha_tl \l_@@_split_intoa_tl
      \tl_put_right:NV \l_@@_split_intob_tl \l_@@_split_path_tl
    }
    \g_@@_curvetoa_tl
    {
      \tl_put_right:NV \l_@@_split_pathb_tl \l_@@_tmpc_tl
      \tl_put_right:Nx \l_@@_split_pathb_tl
      {{ \tl_head:N \l_@@_split_path_tl }}
      \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      
      \tl_put_right:Nx \l_@@_split_pathb_tl
      {{ \tl_head:N \l_@@_split_path_tl }}
      \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      
      \prg_replicate:nn {2} {
        
        \tl_put_right:Nx \l_@@_split_pathb_tl
        { \tl_head:N \l_@@_split_path_tl }
        \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
        
        \tl_put_right:Nx \l_@@_split_pathb_tl
        {{ \tl_head:N \l_@@_split_path_tl }}
        \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      
        \tl_put_right:Nx \l_@@_split_pathb_tl
        {{ \tl_head:N \l_@@_split_path_tl }}
        \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      }

      \spath_split_curve:VVNN \l_@@_split_fp \l_@@_split_pathb_tl
      \l_@@_split_intoa_tl
      \l_@@_split_intob_tl

      \prg_replicate:nn {3} {
        \tl_set:Nx \l_@@_split_intoa_tl {\tl_tail:N \l_@@_split_intoa_tl}
      }

      \tl_put_right:NV \l_@@_split_patha_tl \l_@@_split_intoa_tl
      \tl_put_right:NV \l_@@_split_intob_tl \l_@@_split_path_tl
    }
  }

  \tl_gclear:N \l_@@_smuggle_tl
  \tl_gput_right:Nn \l_@@_smuggle_tl
  {
    \spath_gput:nnn {#3} {path}
  }
  \asxutils_tl_gput_right_braced:NV \l_@@_smuggle_tl \l_@@_split_patha_tl
  \tl_gput_right:Nn \l_@@_smuggle_tl
  {
    \spath_gput:nnn {#4} {path}
  }
  \asxutils_tl_gput_right_braced:NV \l_@@_smuggle_tl \l_@@_split_intob_tl
  
  \group_end:

  \spath_clear_new:n {#3}
  \spath_clear_new:n {#4}
  \tl_use:N \l_@@_smuggle_tl
}

\cs_generate_variant:Nn \spath_split_at:nnnn {VVnn, Vnnn}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Shortening Paths}
%
% This code relates to shortening paths
%
%    \begin{macrocode}
\tl_new:N \l_@@_shorten_fa_tl
\tl_new:N \l_@@_shorten_path_tl
\tl_new:N \l_@@_shorten_last_tl
\int_new:N \l_@@_shorten_int
\fp_new:N \l_@@_shorten_x_fp
\fp_new:N \l_@@_shorten_y_fp
%    \end{macrocode}
%
% \begin{macro}[internal]{\spath_shorten:nn}
% This macro shortens an spath from the end by a dimension.
%
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_shorten:nn #1#2
{
  \group_begin:
  \spath_get:nnN {#1} {final action} \l_@@_shorten_fa_tl
  \spath_get:nnN {#1} {path} \l_@@_shorten_path_tl
  \tl_reverse:N \l_@@_shorten_path_tl

  \tl_clear:N \l_@@_shorten_last_tl
  \tl_if_eq:NNTF \l_@@_shorten_fa_tl \g_@@_curveto_tl
  {
    \int_set:Nn \l_@@_shorten_int {3}
  }
  {
    \int_set:Nn \l_@@_shorten_int {1}
  }

  \prg_replicate:nn { \l_@@_shorten_int }
  {
    \tl_put_right:Nx \l_@@_shorten_last_tl
    {
      {\tl_head:N \l_@@_shorten_path_tl}
    }
    \tl_set:Nx \l_@@_shorten_path_tl {\tl_tail:N \l_@@_shorten_path_tl}
    \tl_put_right:Nx \l_@@_shorten_last_tl
    {
      {\tl_head:N \l_@@_shorten_path_tl}
    }
    \tl_set:Nx \l_@@_shorten_path_tl {\tl_tail:N \l_@@_shorten_path_tl}
    \tl_put_right:Nx \l_@@_shorten_last_tl
    {
      \tl_head:N \l_@@_shorten_path_tl
    }
    \tl_set:Nx \l_@@_shorten_path_tl {\tl_tail:N \l_@@_shorten_path_tl}
  }

  \tl_put_right:Nx \l_@@_shorten_last_tl
  {
    {\tl_item:Nn \l_@@_shorten_path_tl {1}}
    {\tl_item:Nn \l_@@_shorten_path_tl {2}}
  }
  \tl_put_right:NV \l_@@_shorten_last_tl \g_@@_moveto_tl
  
  \tl_reverse:N \l_@@_shorten_path_tl

  \fp_set:Nn \l_@@_shorten_x_fp
  {
    \dim_to_fp:n {\tl_item:Nn \l_@@_shorten_last_tl {4}}
    -
    \dim_to_fp:n {\tl_item:Nn \l_@@_shorten_last_tl {1}}
  }
  
  \fp_set:Nn \l_@@_shorten_y_fp
  {
    \dim_to_fp:n {\tl_item:Nn \l_@@_shorten_last_tl {5}}
    -
    \dim_to_fp:n {\tl_item:Nn \l_@@_shorten_last_tl {2}}
  }

  \fp_set:Nn \l_@@_shorten_len_fp
  {
    sqrt( \l_@@_shorten_x_fp * \l_@@_shorten_x_fp +  \l_@@_shorten_y_fp *  \l_@@_shorten_y_fp )
  }

  \fp_set:Nn \l_@@_shorten_len_fp
  {
    (\l_@@_shorten_len_fp - #2)/ \l_@@_shorten_len_fp
  }

  \tl_reverse:N \l_@@_shorten_last_tl
  
  \tl_if_eq:NNTF \l_@@_shorten_fa_tl \g_@@_curveto_tl
  {
    \fp_set:Nn \l_@@_shorten_len_fp
    {
      1 - (1 -\l_@@_shorten_len_fp)/3
    }
    \spath_split_curve:VVNN \l_@@_shorten_len_fp \l_@@_shorten_last_tl
    \l_@@_shorten_lasta_tl
    \l_@@_shorten_lastb_tl
  }
  {
    \spath_split_line:VVNN \l_@@_shorten_len_fp \l_@@_shorten_last_tl
    \l_@@_shorten_lasta_tl
    \l_@@_shorten_lastb_tl
  }

  \prg_replicate:nn {3}
  {
    \tl_set:Nx \l_@@_shorten_lasta_tl {\tl_tail:N \l_@@_shorten_lasta_tl}
  }

  \tl_put_right:NV \l_@@_shorten_path_tl \l_@@_shorten_lasta_tl

  \tl_gset_eq:NN \l_@@_smuggle_tl \l_@@_shorten_path_tl
  \group_end:

  \spath_clear:n {#1}
  \spath_put:nnV {#1} {path} \l_@@_smuggle_tl
  \spath_remove:nn {#1} {final point}
}
\cs_generate_variant:Nn \spath_shorten:nn {Vn, VV}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Intersection Routines}
%
% \begin{macro}[internal]{\spath_intersect:nn}
% Pass two spaths to pgf's intersection routine.
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_intersect:nn #1#2
{
  \spath_get:nnN {#1} {path} \l_@@_tmpa_tl
  \spath_get:nnN {#2} {path} \l_@@_tmpb_tl
  \pgfintersectionofpaths%
  {%
    \pgfsetpath\l_@@_tmpa_tl
  }{%
    \pgfsetpath\l_@@_tmpb_tl
  }
}
\cs_generate_variant:Nn \spath_intersect:nn {VV, Vn}
%    \end{macrocode}
% \end{macro}
%
%
%    \begin{macrocode}
\tl_new:N \spathselfintersectioncount

\tl_new:N \l_@@_split_tmpa_tl
\tl_new:N \l_@@_split_path_a_tl
\tl_new:N \l_@@_split_path_b_tl
\tl_new:N \l_@@_split_join_a_tl
\tl_new:N \l_@@_split_join_b_tl
\tl_new:N \l_@@_split_first_tl
\tl_new:N \l_@@_split_second_tl

\tl_new:N \l_@@_split_one_tl
\tl_set:Nn \l_@@_split_one_tl {1}
\tl_new:N \l_@@_split_I_tl
\tl_set:Nn \l_@@_split_I_tl {I}
\tl_new:N \l_@@_split_A_tl
\tl_set:Nn \l_@@_split_A_tl {A}
\tl_new:N \l_@@_split_B_tl
\tl_set:Nn \l_@@_split_B_tl {B}

\int_new:N \l_@@_split_count_int
\int_new:N \l_@@_split_intersection_int
\seq_new:N \l_@@_split_segments_seq
\seq_new:N \l_@@_split_segments_processed_seq
\seq_new:N \l_@@_split_segments_middle_seq

\seq_new:N \l_@@_split_joins_seq
\seq_new:N \l_@@_split_joins_processed_seq
\seq_new:N \l_@@_split_joins_middle_seq

\seq_new:N \l_@@_split_intersections_seq

\bool_new:N \l_@@_split_join_bool
%    \end{macrocode}
%
%
% \begin{macro}[internal]{\spath_split_at_self_intersections:nnn}
%
% Splits a path at its self intersections.
%
% Arguments:
%  1. Path to split
%  2. Prefix for name of new paths
%  3. List of how to split at intersections
%     A - don't split first path at intersection
%     B - don't split second path at intersection
%     C - split both paths at intersection
%
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_split_at_self_intersections:nnn #1#2#3
{
  \group_begin:
  % The third argument says whether to rejoin segments at the intersections
  \seq_set_split:Nnn \l_@@_split_intersections_seq {} {#3}
  % Clone the path as we'll mess around with it
  \spath_clone:nn {#1} {spath split tmp}
  % Clear the sequence of joining information
  % The join information says whether to rejoin a segment to its predecessor
  \seq_clear:N \l_@@_split_joins_seq
  % Check the last action to see if it is a close path
  \spath_get:nnN {spath split tmp} {final action} \l_@@_split_tmpa_tl
  \tl_if_eq:NNTF \l_@@_split_tmpa_tl \g_@@_closepath_tl
  {
    % Last action is a close, so mark it as needing rejoining
    \seq_put_right:Nn \l_@@_split_joins_seq {1}
  }
  {
    % Last action is not a close, so mark it as needing rejoining
    \seq_put_right:Nn \l_@@_split_joins_seq {0}
  }
  % Remove close paths
  \spath_open_path:n {spath split tmp}
  % Separate into segments (creates a token list)
  \spath_map_segments_into_list:nN {spath split tmp} \l_@@_list_splitsegments
  % so convert to a sequence
  \seq_set_split:NnV \l_@@_split_segments_seq {} \l_@@_list_splitsegments

  % Iterate over the number of terms in the sequence, adding the
  % rejoining information
  \int_step_inline:nnnn {1} {1} {\seq_count:N \l_@@_split_segments_seq - 1}
  {
    \seq_put_right:Nn \l_@@_split_joins_seq {1}
  }
  
  % Clear a couple of auxiliaries
  \seq_clear:N \l_@@_split_segments_processed_seq
  \seq_clear:N \l_@@_split_joins_processed_seq
  \int_zero:N \l_@@_split_count_int
  \int_zero:N \l_@@_split_intersection_int

  % Iterate over the sequence
  \bool_while_do:nn
  {
    !\seq_if_empty_p:N \l_@@_split_segments_seq
  }
  {
    % Remove the left-most items for consideration
    \seq_pop_left:NN \l_@@_split_segments_seq \l_@@_split_path_a_tl
    \seq_pop_left:NN \l_@@_split_joins_seq \l_@@_split_join_a_tl

    % Clear some sequences, these will hold any pieces we create from splitting our path under consideration except for the first piece
    \seq_clear:N \l_@@_split_segments_middle_seq
    \seq_clear:N \l_@@_split_joins_middle_seq

    % Put the rejoining information in the processed sequence
    \seq_put_right:NV \l_@@_split_joins_processed_seq \l_@@_split_join_a_tl
    
    % Iterate over the rest of the segments
    \int_step_inline:nnnn {1} {1} {\seq_count:N \l_@@_split_segments_seq}
    {
      % Store the next segment for intersection
      \tl_set:Nx \l_@@_split_path_b_tl {\seq_item:Nn \l_@@_split_segments_seq {##1}}
      % Get the next joining information
      \tl_set:Nx \l_@@_split_join_b_tl {\seq_item:Nn \l_@@_split_joins_seq {##1}}
      % And put it onto our saved stack of joins
      \seq_put_right:NV \l_@@_split_joins_middle_seq \l_@@_split_join_b_tl
      
      % Sort intersections along the first path
      \pgfintersectionsortbyfirstpath
      % Find the intersections of these segments
      \spath_intersect:VV \l_@@_split_path_a_tl \l_@@_split_path_b_tl

      % If we get intersections
      \int_compare:nTF {\pgfintersectionsolutions > 0}
      {
        % Find the times of the first intersection (which will be the first along the segment we're focussing on)
        \pgfintersectiongetsolutiontimes{1}{\l_@@_split_first_tl}{\l_@@_split_second_tl}

        % Ignore intersections that are very near end points
        \bool_if:nT {
          \fp_compare_p:n {
            \l_@@_split_first_tl < .99
          }
          &&
          \fp_compare_p:n {
            \l_@@_split_first_tl > .01
          }
          &&
          \fp_compare_p:n {
            \l_@@_split_second_tl < .99
          }
          &&
          \fp_compare_p:n {
            \l_@@_split_second_tl > .01
          }
        }
        {
          % We have a genuine intersection
          \int_incr:N \l_@@_split_intersection_int
        }

        % Do we split the first path?
        \bool_if:nT {
          \fp_compare_p:n {
            \l_@@_split_first_tl < .99
          }
          &&
          \fp_compare_p:n {
            \l_@@_split_first_tl > .01
          }
        }
        {
          % Split the first path at the intersection
          \spath_split_at:VVnn \l_@@_split_path_a_tl \l_@@_split_first_tl {split \int_use:N \l_@@_split_count_int}{split \int_eval:n { \l_@@_split_count_int + 1}}

          % Put the latter part into our temporary sequence
          \seq_put_left:Nx \l_@@_split_segments_middle_seq {split \int_eval:n{ \l_@@_split_count_int + 1}}
          % Mark this intersection in the joining information
          % Label the breaks as "IA#" and "IB#"
          \seq_put_left:Nx \l_@@_split_joins_middle_seq {IA \int_use:N  \l_@@_split_intersection_int }
          
          % Replace our segment under consideration by the initial part
          \tl_set:Nx \l_@@_split_path_a_tl {split \int_use:N \l_@@_split_count_int }
          % Increment our counter
          \int_incr:N \l_@@_split_count_int
          \int_incr:N \l_@@_split_count_int
        }

        % Do we split the second path?
        \bool_if:nTF {
          \fp_compare_p:n {
            \l_@@_split_second_tl < .99
          }
          &&
          \fp_compare_p:n {
            \l_@@_split_second_tl > .01
          }
        }
        {
          % Split the second segment at the intersection point
          \spath_split_at:VVnn \l_@@_split_path_b_tl \l_@@_split_second_tl {split \int_use:N \l_@@_split_count_int}{split \int_eval:n { \l_@@_split_count_int + 1}}

          % Add these segments to our list of segments we've considered
          \seq_put_right:Nx \l_@@_split_segments_middle_seq {split \int_eval:n{ \l_@@_split_count_int}}
          \seq_put_right:Nx \l_@@_split_segments_middle_seq {split \int_eval:n{ \l_@@_split_count_int + 1}}
          \seq_put_right:Nx \l_@@_split_joins_middle_seq {IB \int_use:N \l_@@_split_intersection_int}
          
          % Increment the counter
          \int_incr:N \l_@@_split_count_int
          \int_incr:N \l_@@_split_count_int
        }
        {
          % If we didn't split the second segment, we just put the second segment on the list of segments we've considered
          \seq_put_right:NV \l_@@_split_segments_middle_seq \l_@@_split_path_b_tl
        }

      }
      {
        % If we didn't split the second segment, we just put the second segment on the list of segments we've considered
        \seq_put_right:NV \l_@@_split_segments_middle_seq \l_@@_split_path_b_tl
      }

    }
    % Having been through the loop for our segment under consideration, we replace the segment list since some of them might have been split and add any remainders of the segment under consideration
    \seq_set_eq:NN \l_@@_split_segments_seq \l_@@_split_segments_middle_seq
    \seq_set_eq:NN \l_@@_split_joins_seq \l_@@_split_joins_middle_seq

    % We add the initial segment to our sequence of dealt with segments
    \seq_put_right:NV \l_@@_split_segments_processed_seq \l_@@_split_path_a_tl
  }

  \seq_clear:N \l_@@_split_segments_seq
  
  \tl_set:Nx \l_@@_split_path_a_tl {\seq_item:Nn \l_@@_split_segments_processed_seq {1}}
  
  \int_step_inline:nnnn {2} {1} {\seq_count:N \l_@@_split_segments_processed_seq}
  {
    % Get the next path and joining information
    \tl_set:Nx \l_@@_split_path_b_tl {\seq_item:Nn \l_@@_split_segments_processed_seq {##1}}
    \tl_set:Nx \l_@@_split_join_b_tl {\seq_item:Nn \l_@@_split_joins_processed_seq {##1}}

    % Do we join this to our previous path?
    \bool_set_false:N \l_@@_split_join_bool

    % If it came from when we split the original path, join them
    \tl_if_eq:NNT \l_@@_split_join_b_tl \l_@@_split_one_tl
    {
      \bool_set_true:N \l_@@_split_join_bool
    }

    % Is this a labelled intersection?
    \tl_set:Nx \l_@@_split_tmpa_tl {\tl_head:N \l_@@_split_join_b_tl}
    \tl_if_eq:NNT \l_@@_split_tmpa_tl \l_@@_split_I_tl
    {
      % Strip off the "I" prefix
      \tl_set:Nx \l_@@_split_tmpa_tl {\tl_tail:N \l_@@_split_join_b_tl}

      % Next letter is "A" or "B"
      \tl_set:Nx \l_@@_split_join_b_tl {\tl_head:N \l_@@_split_tmpa_tl}

      % Remainder is the intersection index
      \int_compare:nTF {\tl_tail:N \l_@@_split_tmpa_tl <= \seq_count:N \l_@@_split_intersections_seq}
      {
        \tl_set:Nx \l_@@_split_join_a_tl {\seq_item:Nn \l_@@_split_intersections_seq {\tl_tail:N \l_@@_split_tmpa_tl}}
      }
      {
        % Default is to rejoin neither segment
        \tl_set:Nn \l_@@_split_join_a_tl {0}
      }

      \bool_if:nT
      {
        (
        \tl_if_eq_p:NN \l_@@_split_join_b_tl \l_@@_split_A_tl
        &&
        \int_compare_p:n { \int_mod:nn{\l_@@_split_join_a_tl}{2} == 1 }
        ) ||
        (
        \tl_if_eq_p:NN \l_@@_split_join_b_tl \l_@@_split_B_tl
        &&
        \int_compare_p:n { \int_div_truncate:nn {\l_@@_split_join_a_tl}{2} == 1 }
        )
      }
      {
        \bool_set_true:N \l_@@_split_join_bool
      }
      
    }

    \bool_if:NTF \l_@@_split_join_bool
    {
      % Yes, so append it
      \spath_append_no_move:VV \l_@@_split_path_a_tl \l_@@_split_path_b_tl
    }
    {
      % No, so put the first path onto the stack
      \seq_put_right:NV \l_@@_split_segments_seq \l_@@_split_path_a_tl

      % Swap out the paths
      \tl_set_eq:NN \l_@@_split_path_a_tl \l_@@_split_path_b_tl
    }
  }

  % Do we need to add the first path to the last?
  \tl_set:Nx \l_@@_split_join_a_tl {\seq_item:Nn \l_@@_split_joins_processed_seq {1}}

  \tl_if_eq:NNTF \l_@@_split_join_a_tl \l_@@_split_one_tl
  {
    \tl_set:Nx \l_@@_split_path_b_tl {\seq_item:Nn \l_@@_split_segments_processed_seq {1}}
    \spath_prepend_no_move:VV \l_@@_split_path_b_tl \l_@@_split_path_a_tl
    
  }
  {
    \seq_put_right:NV \l_@@_split_segments_seq \l_@@_split_path_a_tl
  }

  % Put our paths into a list
  \int_zero:N \l_@@_split_count_int
  \seq_map_inline:Nn \l_@@_split_segments_seq
  {
    \int_incr:N \l_@@_split_count_int
    \spath_gclone:nn {##1} {#2~\int_use:N \l_@@_split_count_int}
  }
  \tl_gset:NV \spathselfintersectioncount \l_@@_split_count_int
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
%
%    \begin{macrocode}
\seq_new:N \l_@@_split_first_seq
\seq_new:N \l_@@_split_second_seq
\seq_new:N \l_@@_split_first_segments_seq
\seq_new:N \l_@@_split_second_segments_seq

\tl_new:N \spathfirstintersectioncount
\tl_new:N \spathsecondintersectioncount
%    \end{macrocode}
%
% \begin{macro}[internal]{\spath_split_at_intersections:nnnnn}
%
% Arguments:
%  1. First path to split
%  2. Second path to split
%  3. Prefix for name of new paths of first path
%  4. Prefix for name of new paths of second path
%  5. List of how to split at intersections
%     0 - split both paths
%     1 - split only second path
%     2 - split only first path
%     3 - split neither path
%
%    \begin{macrocode}
\cs_new_nopar:Npn \spath_split_at_intersections:nnnnn #1#2#3#4#5
{
  \group_begin:
  % The third argument says whether to rejoin segments at the intersections
  \seq_set_split:Nnn \l_@@_split_intersections_seq {} {#5}
  % Clone the paths as we'll mess around with them
  \spath_clone:nn {#1} {spath split tmpa}
  \spath_clone:nn {#2} {spath split tmpb}
  % Remove close paths
  \spath_open_path:n {spath split tmpa}
  \spath_open_path:n {spath split tmpb}

  % Sort intersections along the first path
  \pgfintersectionsortbyfirstpath
  % Find the intersections of these segments
  \spath_intersect:nn {spath split tmpa}{spath split tmpb}

  \seq_clear:N \l_@@_split_first_segments_seq
  \seq_clear:N \l_@@_split_second_segments_seq

  \seq_clear:N \l_@@_split_first_seq
  \seq_clear:N \l_@@_split_second_seq
  
  % If we get intersections
  \int_compare:nT {\pgfintersectionsolutions > 0}
  {
    % Find the times of the first intersection (which will be the first along the segment we're focussing on)

    \int_step_inline:nnnn {1} {1} {\pgfintersectionsolutions}
    {
    \pgfintersectiongetsolutiontimes{##1}{\l_@@_split_first_tl}{\l_@@_split_second_tl}
    \seq_put_left:NV \l_@@_split_first_seq \l_@@_split_first_tl
    \seq_put_left:NV \l_@@_split_second_seq \l_@@_split_second_tl
    }

    \seq_sort:Nn \l_@@_split_second_seq
    {
      \fp_compare:nNnTF { ##1 } < { ##2 }
      { \sort_return_swapped: }
      { \sort_return_same: }
    }
 
  
    \tl_set:Nn \l_@@_split_path_a_tl {spath split tmpa}
    \tl_set:Nn \l_@@_split_path_b_tl {spath split tmpb}


    \int_step_inline:nnnn {1} {1} {\pgfintersectionsolutions}
    {
      \tl_set:Nx \l_@@_split_first_tl {\seq_item:Nn \l_@@_split_first_seq {##1}}
      \tl_set:Nx \l_@@_split_second_tl {\seq_item:Nn \l_@@_split_second_seq {##1}}
      
      \bool_set_true:N \l_@@_split_join_bool

      \int_compare:nT { ##1 <= \seq_count:N \l_@@_split_intersections_seq }
      {
        \tl_set:Nx \l_@@_split_join_a_tl {\seq_item:Nn \l_@@_split_intersections_seq {##1}}

        \int_compare:nT { \int_mod:nn{\l_@@_split_join_a_tl}{2} == 0 }
        {
          \bool_set_false:N \l_@@_split_join_bool
        }

      }

      \bool_if:NT \l_@@_split_join_bool
      {
        \spath_split_at:VVnn \l_@@_split_path_a_tl \l_@@_split_first_tl {path a ##1 start} {path a ##1 end}
        \seq_put_left:Nn \l_@@_split_first_segments_seq {path a ##1 end}
        \tl_set:Nn \l_@@_split_path_a_tl {path a ##1 start}
      }
    
      \bool_set_true:N \l_@@_split_join_bool

      \int_compare:nT { ##1 <= \seq_count:N \l_@@_split_intersections_seq }
      {
        \tl_set:Nx \l_@@_split_join_a_tl {\seq_item:Nn \l_@@_split_intersections_seq {##1}}
        
        \int_compare:nT { \int_div_truncate:nn {\l_@@_split_join_a_tl}{2} == 0 }
        {
          \bool_set_false:N \l_@@_split_join_bool
        }

      }

      \bool_if:NT \l_@@_split_join_bool
      {
        \spath_split_at:VVnn \l_@@_split_path_b_tl \l_@@_split_second_tl {path b ##1 start} {path b ##1 end}
        \seq_put_left:Nn \l_@@_split_second_segments_seq {path b ##1 end}
        \tl_set:Nn \l_@@_split_path_b_tl {path b ##1 start}
      }
    
    }
    \seq_put_left:NV \l_@@_split_first_segments_seq \l_@@_split_path_a_tl
    \seq_put_left:NV \l_@@_split_second_segments_seq \l_@@_split_path_b_tl
  }

  \seq_if_empty:NT \l_@@_split_first_segments_seq
  {
    \seq_put_left:Nn \l_@@_split_first_segments_seq {spath split tmpa}
  }
  \seq_if_empty:NT \l_@@_split_second_segments_seq
  {
    \seq_put_left:Nn \l_@@_split_second_segments_seq {spath split tmpb}
  }
  

  \int_zero:N \l_@@_split_count_int
  \seq_map_inline:Nn \l_@@_split_first_segments_seq
  {
    \int_incr:N \l_@@_split_count_int
    \spath_gclone:nn {##1} {#3~\int_use:N \l_@@_split_count_int}
  }
  \tl_gset:NV \spathfirstintersectioncount \l_@@_split_count_int

  \int_zero:N \l_@@_split_count_int
  \seq_map_inline:Nn \l_@@_split_second_segments_seq
  {
    \int_incr:N \l_@@_split_count_int
    \spath_gclone:nn {##1} {#4~\int_use:N \l_@@_split_count_int}
  }
  \tl_gset:NV \spathsecondintersectioncount \l_@@_split_count_int
  
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Public Commands}
%
% The next functions are more ``public'' than the previous lot.
% That said, they aren't intended for direct use in a normal document.
%
% Most are just wrappers around internal functions.
% By default, they work globally.
% The star argument makes them local.
%
% \begin{macro}[internal]{\MakeSPath}
% Constructs an \Verb+spath+ object out of the given name and path.
%    \begin{macrocode}
\NewDocumentCommand \MakeSPath { s m m }
{
  \IfBooleanTF {#1}
  {
    \spath_clear_new:n {#2}
    \spath_put:nno {#2} {path} {#3}
  }
  {
    \spath_gclear_new:n {#2}
    \spath_gput:nno {#2} {path} {#3}
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[internal]{\MakeSPathList}
% This constructs a list of \Verb+spath+ objects from a single path by splitting it into components.
%    \begin{macrocode}
\NewDocumentCommand \MakeSPathList { s m m }
{
  \spath_map_components_into_list:nc {#2}{l_@@_list_#3}
  \IfBooleanT {#1}
  {
    \tl_map_inline:cn {l_@@_list_#3}
    {
      \spath_globalise:n {##1}
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\CloneSPath}
%    \begin{macrocode}
\NewDocumentCommand \CloneSPath { s m m }
{
  \IfBooleanTF {#1}
  {
    \spath_clone:nn {#2} {#3}
  }
  {
    \spath_gclone:nn {#2} {#3}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathInfo}
%    \begin{macrocode}
\NewDocumentCommand \SPathInfo { m m }
{
  \spath_get:nn {#1} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathPrepare}
%    \begin{macrocode}
\NewDocumentCommand \SPathPrepare { s m }
{
  \spath_generate_all:n {#2}
  \IfBooleanF {#1}
  {
    \spath_globalise:n {#2}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathListPrepare}
%    \begin{macrocode}
\NewDocumentCommand \SPathListPrepare { s m }
{
  \tl_map_inline:cn {l_@@_list_#2}
  {
    \spath_generate_all:n {##1}
    \IfBooleanF {#1}
    {
      \spath_globalise:n {##1}
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathListOpen}
%    \begin{macrocode}
\NewDocumentCommand \SPathListOpen { m }
{
  \tl_map_inline:cn {l_@@_list_#1}
  {
    \spath_open_path:n {##1}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathInfoInto}
%    \begin{macrocode}
\NewDocumentCommand \SPathInfoInto { m m m }
{
  \tl_clear_new:N #3
  \spath_get:nnN {#1} {#2} #3
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathShow}
%    \begin{macrocode}
\NewDocumentCommand \SPathShow { m }
{
  \spath_show:n {#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathTranslate}
%    \begin{macrocode}
\NewDocumentCommand \SPathTranslate { s m m m }
{
  \spath_translate:nnn {#2} {#3} {#4}
  \IfBooleanF {#1}
  {
    \spath_globalise:n {#2}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathTranslateInto}
% Clones the path before translating it.
%    \begin{macrocode}
\NewDocumentCommand \SPathTranslateInto { s m m m m }
{
  \IfBooleanTF {#1}
  {
    \spath_clone:nn {#2} {#3}
  }
  {
    \spath_gclone:nn {#2} {#3}
  }
  \spath_translate:nnn {#3} {#4} {#5}
  \IfBooleanF {#1}
  {
    \spath_globalise:n {#3}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathScale}
%    \begin{macrocode}
\NewDocumentCommand \SPathScale { s m m m }
{
  \spath_scale:nnn {#2} {#3} {#4}
  \IfBooleanF {#1}
  {
    \spath_globalise:n {#2}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathScaleInto}
% Clones the path first.
%    \begin{macrocode}
\NewDocumentCommand \SPathScaleInto { s m m m m }
{
  \IfBooleanTF {#1}
  {
    \spath_clone:nn {#2} {#3}
  }
  {
    \spath_gclone:nn {#2} {#3}
  }
  \spath_scale:nnn {#3} {#4} {#5}
  \IfBooleanF {#1}
  {
    \spath_globalise:n {#3}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathWeld}
%    \begin{macrocode}
\NewDocumentCommand \SPathWeld { s m m }
{
  \spath_weld:nn {#2} {#3}
  \IfBooleanF {#1}
  {
    \spath_globalise:n {#2}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathWeldInto}
%    \begin{macrocode}
\NewDocumentCommand \SPathWeldInto { s m m m }
{
  \IfBooleanTF {#1}
  {
    \spath_clone:nn {#2} {#3}
  }
  {
    \spath_gclone:nn {#2} {#3}
  }
  \spath_weld:nn {#3} {#4}
  \IfBooleanF {#1}
  {
    \spath_globalise:n {#3}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathReverse}
%    \begin{macrocode}
\DeclareDocumentCommand \SPathReverse {s m}
{
  \spath_reverse:n {#2}
  \IfBooleanF {#1}
  {
    \spath_globalise:n {#2}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathClose}
%    \begin{macrocode}
\DeclareDocumentCommand \SPathClose {s m}
{
  \spath_close_path:n {#2}
  \IfBooleanF {#1}
  {
    \spath_globalise:n {#2}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\SPathOpen}
%    \begin{macrocode}
\DeclareDocumentCommand \SPathOpen {s m}
{
  \spath_open_path:n {#2}
  \IfBooleanF {#1}
  {
    \spath_globalise:n {#2}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \iffalse
%</spath3>
% \fi
%
% \iffalse
%<*tikzspath3>
% \fi
% Interfaces via TikZ keys.
%
% When saving an \Verb+spath+ we make it global since we're probably buried deep within groups and scopes.
%     \begin{macrocode}
\RequirePackage{spath3}
\RequirePackage{expl3}
\ExplSyntaxOn
\tikzset{
  save~ spath/.code={
    \tikz@addmode{
      \spath_gget_current_path:n {#1}
    }
  },
  restore~ spath/.code={
    \spath_if_exist:nT { #1 }
    {
      \spath_set_current_path:n {#1}
      \spath_set_tikz_coords:n {#1}
    }
  },
  clone~ spath/.code~2~args={
    \spath_clone:nn {#1} {#2}
  },
  append~ spath/.code={
    \spath_if_exist:nT { #1 }
    {
      \spath_get_current_path:n {current path}
      \spath_weld:nn { current path } { #1 }
      \spath_set_current_path:n { current path }
      \spath_get:nnN { current path } {final point} \l_@@_tmpa_tl
      \spath_set_tikz_coords:n { current path }
    }
  },
  reverse~ spath/.code={
    \spath_if_exist:nT { #1 }
    {
      \spath_reverse:n { #1 }
    }
  },
  append~ reverse~ spath/.code={
    \spath_if_exist:nT { #1 }
    {
      \spath_reverse:n { #1 }
      \spath_get_current_path:n { current path }
      \spath_weld:nn { current path } { #1 }
      \spath_set_current_path:n { current path }
      \spath_set_tikz_coords:n { current path }
    }
  },    
  insert~ spath/.code={
    \spath_if_exist:nT { #1 }
    {
      \spath_get_current_path:n {current path}
      \spath_append:nn { current path } { #1 }
      \spath_set_current_path:n { current path }
      \spath_set_tikz_coords:n { current path }
    }
  },
  shorten~spath~at~end/.code~ 2~ args={
    \spath_if_exist:nT { #1 }
    {
      \spath_shorten:nn {#1} {#2}
    }
  },
  shorten~spath~at~start/.code~ 2~ args ={
    \spath_if_exist:nT { #1 }
    {
      \spath_reverse:n {#1}
      \spath_shorten:nn {#1} {#2}
      \spath_reverse:n {#1}
    }
  },
  shorten~spath~at~both~ends/.code~ 2~ args={
    \spath_if_exist:nT { #1 }
    {
      \spath_shorten:nn {#1} {#2}
      \spath_reverse:n {#1}
      \spath_shorten:nn {#1} {#2}
      \spath_reverse:n {#1}
    }
  },
  globalise~ spath/.code={
    \spath_if_exist:nT { #1 }
    {
      \spath_globalise:n {#1}
    }
  },
  translate~ spath/.code~ n~ args={3}{
    \spath_if_exist:nT { #1 }
    {
      \spath_translate:nnn {#1}{#2}{#3}
    }
  },
  transform~ spath/.code~ 2~ args={
    \spath_if_exist:nT { #1 }
    {
      \group_begin:
      \pgftransformreset
      \tikzset{#2}
      \pgfgettransform \l_@@_tmpa_tl
      \tl_gset:Nn \l_@@_smuggle_tl
      {
        \spath_transform:nnnnnnn { #1 }
      }
      \tl_gput_right:NV \l_@@_smuggle_tl \l_@@_tmpa_tl
      \group_end:
      \tl_use:N \l_@@_smuggle_tl
    }
  },
  split~ at~ self~ intersections/.code~ 2~ args={
    \use:c {tikz@addmode}{
      \group_begin:
      \spath_get_current_path:n {spath split tmpa}
      \spath_split_at_self_intersections:nnn {spath split tmpa} {#1} {#2}
      \group_end:
    }
  },
  split~ at~ intersections/.code~ n~ args={5}{
    \spath_split_at_intersections:nnnnn {#1}{#2}{#3}{#4}{#5}
  }
}
\ExplSyntaxOff
%    \end{macrocode}
% \iffalse
%</tikzspath3>
% \fi
%
% \iffalse
%<*calligraphy>
% \fi
%
% \section{The Calligraphy Package}
%
%    \begin{macrocode}
%<@@=cal>
%    \end{macrocode}
%
% \subsection{Initialisation}
%    \begin{macrocode}
\RequirePackage{spath3}
\ExplSyntaxOn

\tl_new:N \l_@@_tmpa_tl
\tl_new:N \l_@@_tmpb_tl
\int_new:N \l_@@_tmpa_int
\int_new:N \l_@@_tmpb_int
\int_new:N \l_@@_path_component_int
\int_new:N \l_@@_label_int
\dim_new:N \l_@@_tmpa_dim
\dim_new:N \l_@@_tmpb_dim
\dim_new:N \l_@@_tmpc_dim
\dim_new:N \l_@@_tmpd_dim
\dim_new:N \l_@@_tmpe_dim
\dim_new:N \l_@@_tmpf_dim
\dim_new:N \l_@@_tmpg_dim
\dim_new:N \l_@@_tmph_dim
\bool_new:N \l_@@_annotate_bool
\bool_new:N \l_@@_taper_start_bool
\bool_new:N \l_@@_taper_end_bool
\bool_new:N \l_@@_taperable_bool
\dim_new:N \l_@@_taper_width_dim
\dim_new:N \l_@@_line_width_dim

\bool_set_true:N \l_@@_taper_start_bool
\bool_set_true:N \l_@@_taper_end_bool

\cs_generate_variant:Nn \tl_put_right:Nn {Nv}

\msg_new:nnn { calligraphy } { undefined pen } { The~ pen~ "#1"~ is~ not~ defined. }
%    \end{macrocode}
%
% \subsection{TikZ Keys}
%
% The public interface to this package is through TikZ keys and styles.
%    \begin{macrocode}
\tikzset{
  define~pen/.code={
    \tikzset{pen~name=#1}
    \pgf@relevantforpicturesizefalse
    \tikz@addmode{
      \pgfsyssoftpath@getcurrentpath\l_@@_tmpa_tl
      \spath_map_path_components_into_list:Nc \l_@@_tmpa_tl {l_@@_pen_\pgfkeysvalueof{/tikz/pen~name}}
      \tl_map_inline:cn {l_@@_pen_\pgfkeysvalueof{/tikz/pen~name}}
      {
        \spath_generate_all:n {####1}
        \spath_globalise:n {####1}
      }
      \tl_gset_eq:cc {l_@@_pen_\pgfkeysvalueof{/tikz/pen~name}} {l_@@_pen_\pgfkeysvalueof{/tikz/pen~name}}
      \pgfusepath{discard}%
    }
  },
  define~pen/.default={default},
  use~pen/.code={
    \tikzset{pen~name=#1}
    \int_gzero:N \l_@@_path_component_int
    \cs_set_eq:NN \pgfpathmoveto \cal_moveto:n
    \tikz@addmode{
      \pgfsyssoftpath@getcurrentpath\l_@@_tmpa_tl
      \spath_map_path_components_into_list:NN \l_@@_tmpa_tl \l_@@_spath_list
      \tl_map_inline:Nn \l_@@_spath_list
      {
        \spath_open_path:n {####1}
        \spath_generate_all:n {####1}
      }
      \tl_if_exist:cTF {l_@@_pen_\pgfkeysvalueof{/tikz/pen~name}}
      {
        \cal_path_create:Nc \l_@@_spath_list {l_@@_pen_\pgfkeysvalueof{/tikz/pen~name}}
      }
      {
        \msg_warning:nnx { calligraphy } { undefined pen } { \pgfkeysvalueof{/tikz/pen~name} }
      }
    }
  },
  use~pen/.default={default},
  pen~name/.initial={default},
  copperplate/.style={pen~name=copperplate},
  pen~colour/.initial={black},
  weight/.is~choice,
  weight/heavy/.style={
    line~width=\pgfkeysvalueof{/tikz/heavy~line~width},
    taper~width=\pgfkeysvalueof{/tikz/light~line~width},
  },
  weight/light/.style={
    line~width=\pgfkeysvalueof{/tikz/light~line~width},
    taper~width=0pt,
  },
  heavy/.style={
    weight=heavy
  },
  light/.style={
    weight=light
  },
  heavy~line~width/.initial=2pt,
  light~line~width/.initial=1pt,
  taper/.is~choice,
  taper/.default=both,
  taper/none/.style={
    taper~start=false,
    taper~end=false,
  },
  taper/both/.style={
    taper~start=true,
    taper~end=true,
  },
  taper/start/.style={
    taper~start=true,
    taper~end=false,
  },
  taper/end/.style={
    taper~start=false,
    taper~end=true,
  },
  taper~start/.code={
    \tl_if_eq:nnTF {#1} {true}
    {
      \bool_set_true:N \l_@@_taper_start_bool
    }
    {
      \bool_set_false:N \l_@@_taper_start_bool
    }
  },
  taper~start/.default={true},
  taper~end/.code={
    \tl_if_eq:nnTF {#1} {true}
    {
      \bool_set_true:N \l_@@_taper_end_bool
    }
    {
      \bool_set_false:N \l_@@_taper_end_bool
    }
  },
  taper~end/.default={true},
  taper~width/.code={\dim_set:Nn \l_@@_taper_width_dim {#1}},
  nib~style/.code~2~args={
    \tl_clear_new:c {l_@@_nib_style_#1}
    \tl_set:cn {l_@@_nib_style_#1} {#2}
  },
  stroke~style/.code~2~args={
    \tl_clear_new:c {l_@@_stroke_style_#1}
    \tl_set:cn {l_@@_stroke_style_#1} {#2}
  },
  this~stroke~style/.code={
    \tl_clear_new:c {l_@@_stroke_inline_style_ \int_use:N \l_@@_path_component_int}
    \tl_set:cn {l_@@_stroke_inline_style_ \int_use:N \l_@@_path_component_int} {#1}
  },
  annotate/.style={
    annotate~if,
    annotate~reset,
    annotation~style/.update~value={#1},
  },
  annotate~if/.default={true},
  annotate~if/.code={
    \tl_if_eq:nnTF {#1} {true}
    {
      \bool_set_true:N \l_@@_annotate_bool
    }
    {
      \bool_set_false:N \l_@@_annotate_bool
    }
  },
  annotate~reset/.code={
    \int_gzero:N \l_@@_label_int
  },
  annotation~style/.initial={draw,->},
  annotation~shift/.initial={(0,1ex)},
  every~annotation~node/.initial={anchor=south~west},
  annotation~node~style/.code~2~args={
    \tl_set:cn {l_@@_annotation_style_ #1 _tl}{#2}
  },
  tl~use:N/.code={
    \exp_args:NV \pgfkeysalso #1
  },
  tl~use:c/.code={
    \tl_if_exist:cT {#1}
    {
      \exp_args:Nv \pgfkeysalso {#1}
    }
  },
  /handlers/.update~style/.code={
    \tl_if_eq:nnF {#1} {\pgfkeysnovalue}
    {
      \pgfkeys{\pgfkeyscurrentpath/.code=\pgfkeysalso{#1}}
    }
  },
  /handlers/.update~value/.code={
    \tl_if_eq:nnF {#1} {\pgfkeysnovalue}
    {
      \pgfkeyssetvalue{\pgfkeyscurrentpath}{#1}
    }
  }
}
%    \end{macrocode}
%
% Some wrappers around the TikZ keys.
%    \begin{macrocode}
\NewDocumentCommand \pen { O{} }
{
  \path[define~ pen,every~ calligraphy~ pen/.try,#1]
}

\NewDocumentCommand \definepen { O{} }
{
  \tikz \path[define~ pen,every~ calligraphy~ pen/.try,#1]
}

\NewDocumentCommand \calligraphy { O{} }
{
  \path[use~ pen,every~ calligraphy/.try,#1]
}
%    \end{macrocode}
%
% \subsection{The Path Creation}
%
% \begin{macro}[internal]{\cal_path_create:NN}
% This is the main command for creating the calligraphic paths.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_path_create:NN #1#2
{
  \int_zero:N \l_@@_tmpa_int
  \tl_map_inline:Nn #1
  {
    \__spath_get:nnN {##1} {length} \l_@@_tmpa_tl

    \int_compare:nT {\l_@@_tmpa_tl > 1}
    {
      
      \int_incr:N \l_@@_tmpa_int
      \int_zero:N \l_@@_tmpb_int

      \tl_map_inline:Nn #2
      {
        \int_incr:N \l_@@_tmpb_int
        \group_begin:
        \pgfsys@beginscope
        \cal_apply_style:c {l_@@_stroke_style_ \int_use:N \l_@@_tmpa_int}
        \cal_apply_style:c {l_@@_stroke_inline_style_ \int_use:N \l_@@_tmpa_int}
        \cal_apply_style:c {l_@@_nib_style_ \int_use:N \l_@@_tmpb_int}
        \spath_clone:nn {##1} {calligraphy temp path}

        \__spath_get:nnN {####1} {initial point} \l_@@_tmpa_tl

        \spath_translate:nV {calligraphy temp path} \l_@@_tmpa_tl

        \__spath_get:nnN {####1} {length} \l_@@_tmpa_tl

        \int_compare:nTF {\l_@@_tmpa_tl = 1}
        {
          \cal_at_least_three:n {calligraphy temp path}

          \spath_protocol_path:n {calligraphy temp path}

          \__spath_get:nnN {calligraphy temp path} {path} \l_@@_tmpa_tl

          \tikz@options
          \dim_set:Nn \l_@@_line_width_dim {\pgflinewidth}
          \cal_maybe_taper:N \l_@@_tmpa_tl
        }
        {
          \spath_weld:nn {calligraphy temp path} {####1}
          \spath_reverse:n {##1}
          \spath_reverse:n {####1}
          \spath_weld:nn {calligraphy temp path} {##1}
          \spath_weld:nn {calligraphy temp path} {####1}
          \spath_reverse:n {##1}
          \spath_reverse:n {####1}

          \tl_clear:N \l_@@_tmpa_tl
          \tl_set:Nn \l_@@_tmpa_tl {fill=\pgfkeysvalueof{/tikz/pen~colour},draw=none}
          \tl_if_exist:cT  {l_@@_stroke_style_ \int_use:N \l_@@_tmpa_int}
          {
            \tl_put_right:Nv \l_@@_tmpa_tl {l_@@_stroke_style_ \int_use:N \l_@@_tmpa_int}
          }
          \tl_if_exist:cT  {l_@@_stroke_inline_style_ \int_use:N \l_@@_tmpa_int}
          {
            \tl_put_right:Nn \l_@@_tmpa_tl {,}
            \tl_put_right:Nv \l_@@_tmpa_tl {l_@@_stroke_inline_style_ \int_use:N \l_@@_tmpa_int}
          }
          \tl_if_exist:cT  {l_@@_nib_style_ \int_use:N \l_@@_tmpb_int}
          {
            \tl_put_right:Nn \l_@@_tmpa_tl {,}
            \tl_put_right:Nv \l_@@_tmpa_tl {l_@@_nib_style_ \int_use:N \l_@@_tmpb_int}
          }
          \spath_tikz_path:Vn \l_@@_tmpa_tl {calligraphy temp path}

        }
        \pgfsys@endscope
        \group_end:
      }

      \bool_if:NT \l_@@_annotate_bool
      {
        \spath_clone:nn {##1} {calligraphy temp path}
        \tl_set_eq:NN \l_tmpa_tl #2
        \tl_reverse:N \l_tmpa_tl
        \tl_set:Nx \l_tmpa_tl {\tl_head:N \l_tmpa_tl}
        \spath_generate_finalpoint:V \l_tmpa_tl
        \spath_get:VnN \l_tmpa_tl {final point} \l_tmpa_tl
        \spath_translate:nV {calligraphy temp path} \l_tmpa_tl
        \tikz@scan@one@point\pgfutil@firstofone\pgfkeysvalueof{/tikz/annotation~shift}
        \spath_translate:nnn {calligraphy temp path} {\pgf@x} {\pgf@y}
      
        \pgfkeysgetvalue{/tikz/annotation~style}{\l_tmpa_tl}
        \spath_tikz_path:Vn \l_tmpa_tl {calligraphy temp path}
        \spath_get:nnN {calligraphy temp path} {final point} \l_tmpa_tl
        \exp_last_unbraced:NV \pgfqpoint \l_tmpa_tl
        \begin{scope}[reset~ cm]
        \node[every~annotation~node/.try,tl~use:c =  {l_@@_annotation_style_ \int_use:N \l_@@_tmpa_int _tl}] at (\pgf@x,\pgf@y) {\int_use:N \l_@@_tmpa_int};
        \end{scope}
      }
    }
  }
}
\cs_generate_variant:Nn \cal_path_create:NN {Nc}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\cal_moveto:n}
% When creating the path, we need to keep track of the number of components so that we can apply styles accordingly.
%    \begin{macrocode}
\cs_new_eq:NN \cal_orig_moveto:n \pgfpathmoveto
\cs_new_nopar:Npn \cal_moveto:n #1
{
  \int_gincr:N \l_@@_path_component_int
  \cal_orig_moveto:n {#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\cal_apply_style:N}
% Interface for applying \Verb+\tikzset+ to a token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_apply_style:N #1
{
  \tl_if_exist:NT #1 {
    \exp_args:NV \tikzset #1
  }
}
\cs_generate_variant:Nn \cal_apply_style:N {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\cal_at_least_three:n}
% A tapered path has to have at least three components.
% This figures out if it is necessary and sets up the splitting.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_at_least_three:n #1
{
  \spath_get:nnN {#1} {real length} \l_@@_tmpa_tl
  \tl_clear:N \l_@@_tmpb_tl
  \int_compare:nTF {\l_@@_tmpa_tl = 1}
  {
    \spath_map_segments_inline:nn {#1}
    {
      \tl_case:NnF ##1 {
        \g__spath_lineto_tl {
          \cal_split_line_in_three:NN \l_@@_tmpb_tl ##2
        }
        \g__spath_curvetoa_tl {
          \cal_split_curve_in_three:NN \l_@@_tmpb_tl ##2
        }
      }
      {
        \tl_put_right:NV \l_@@_tmpb_tl ##2
      }
    }
    \spath_put:nnV {#1} {path} \l_@@_tmpb_tl
  }
  {
    \int_compare:nT {\l_@@_tmpa_tl = 2}
    {
      \spath_map_segments_inline:nn {#1}
      {
        \tl_case:NnF ##1 {
          \g__spath_lineto_tl {
            \cal_split_line_in_two:NN \l_@@_tmpb_tl ##2
          }
          \g__spath_curvetoa_tl {
            \cal_split_curve_in_two:NN \l_@@_tmpb_tl ##2
          }
        }
        {
          \tl_put_right:NV \l_@@_tmpb_tl ##2
        }
      }
      \spath_put:nnV {#1} {path} \l_@@_tmpb_tl
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\cal_split_line_in_two:NN}
% Splits a line in two, adding the splits to the first token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_split_line_in_two:NN #1#2
{
  \tl_set_eq:NN \l_@@_tmpc_tl #2

  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}

  \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpc_tl}
  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}

  \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpc_tl}
  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}

  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}

  \dim_set:Nn \l_@@_tmpc_dim {\tl_head:N \l_@@_tmpc_tl}
  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}
  \dim_set:Nn \l_@@_tmpd_dim {\tl_head:N \l_@@_tmpc_tl}
  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}

  \tl_put_right:NV #1 \g__spath_lineto_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(\l_@@_tmpa_dim + \l_@@_tmpc_dim)/2}}
    {\dim_eval:n {(\l_@@_tmpb_dim + \l_@@_tmpd_dim)/2}}
  }

  \tl_put_right:NV #1 \g__spath_lineto_tl
  \tl_put_right:Nx #1 {
    {\dim_use:N \l_@@_tmpc_dim}
    {\dim_use:N \l_@@_tmpd_dim}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\cal_split_line_in_three:NN}
% Splits a line in three, adding the splits to the first token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_split_line_in_three:NN #1#2
{
  \tl_set_eq:NN \l_@@_tmpc_tl #2

  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}

  \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpc_tl}
  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}

  \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpc_tl}
  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}

  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}

  \dim_set:Nn \l_@@_tmpc_dim {\tl_head:N \l_@@_tmpc_tl}
  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}
  \dim_set:Nn \l_@@_tmpd_dim {\tl_head:N \l_@@_tmpc_tl}
  \tl_set:Nx \l_@@_tmpc_tl {\tl_tail:N \l_@@_tmpc_tl}

  \tl_put_right:NV #1 \g__spath_lineto_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(2\l_@@_tmpa_dim + \l_@@_tmpc_dim)/3}}
    {\dim_eval:n {(2\l_@@_tmpb_dim + \l_@@_tmpd_dim)/3}}
  }

  \tl_put_right:NV #1 \g__spath_lineto_tl

  \tl_put_right:Nx #1 {
    {\dim_eval:n {(\l_@@_tmpa_dim + 2\l_@@_tmpc_dim)/3}}
    {\dim_eval:n {(\l_@@_tmpb_dim + 2\l_@@_tmpd_dim)/3}}
  }

  \tl_put_right:NV #1 \g__spath_lineto_tl
  \tl_put_right:Nx #1 {
    {\dim_use:N \l_@@_tmpc_dim}
    {\dim_use:N \l_@@_tmpd_dim}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\cal_split_curve_in_two:NN}
% Splits a curve in two, adding the splits to the first token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_split_curve_in_two:NN #1#2
{
  \spath_split_curve:nVNN {.5} #2 \l_tmpa_tl \l_tmpb_tl
  \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
  \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
  \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
  \tl_set:Nx \l_tmpb_tl {\tl_tail:N \l_tmpb_tl}
  \tl_set:Nx \l_tmpb_tl {\tl_tail:N \l_tmpb_tl}
  \tl_set:Nx \l_tmpb_tl {\tl_tail:N \l_tmpb_tl}
  \tl_put_right:NV #1 \l_tmpa_tl
  \tl_put_right:NV #1 \l_tmpb_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\cal_split_curve_in_three:NN}
% Splits a curve in three, adding the splits to the first token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_split_curve_in_three:NN #1#2
{
  \spath_split_curve:nVNN {1/3} #2 \l_tmpa_tl \l_tmpb_tl

  \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
  \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
  \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
  \tl_put_right:NV #1 \l_tmpa_tl

  \spath_split_curve:nVNN {.5} \l_tmpb_tl \l_tmpa_tl \l_tmpb_tl
  \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
  \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
  \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
  \tl_set:Nx \l_tmpb_tl {\tl_tail:N \l_tmpb_tl}
  \tl_set:Nx \l_tmpb_tl {\tl_tail:N \l_tmpb_tl}
  \tl_set:Nx \l_tmpb_tl {\tl_tail:N \l_tmpb_tl}
  \tl_put_right:NV #1 \l_tmpa_tl
  \tl_put_right:NV #1 \l_tmpb_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\cal_maybe_taper:N}
% Possibly tapers the path, depending on the booleans.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_maybe_taper:N #1
{
  \tl_set_eq:NN \l_@@_tmpa_tl #1

  \bool_if:NT \l_@@_taper_start_bool
  {

    \dim_set:Nn \l_@@_tmpa_dim {\tl_item:Nn \l_@@_tmpa_tl {2}}
    \dim_set:Nn \l_@@_tmpb_dim {\tl_item:Nn \l_@@_tmpa_tl {3}}
    \tl_set:Nx \l_@@_tmpb_tl {\tl_item:Nn \l_@@_tmpa_tl {4}}

    \tl_case:NnF \l_@@_tmpb_tl
    {
      \g__spath_lineto_tl
      {

        \bool_set_true:N \l_@@_taperable_bool
        \dim_set:Nn \l_@@_tmpg_dim {\tl_item:Nn \l_@@_tmpa_tl {5}}
        \dim_set:Nn \l_@@_tmph_dim {\tl_item:Nn \l_@@_tmpa_tl {6}}
        \dim_set:Nn \l_@@_tmpc_dim {(2\l_@@_tmpa_dim + \l_@@_tmpg_dim)/3}
        \dim_set:Nn \l_@@_tmpd_dim {(2\l_@@_tmpb_dim + \l_@@_tmph_dim)/3}
        \dim_set:Nn \l_@@_tmpe_dim {(\l_@@_tmpa_dim + 2\l_@@_tmpg_dim)/3}
        \dim_set:Nn \l_@@_tmpf_dim {(\l_@@_tmpb_dim + 2\l_@@_tmph_dim)/3}
        \prg_replicate:nn {4}
        {
          \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        }
        \tl_put_left:NV \l_@@_tmpa_tl \g__spath_moveto_tl
      }
      \g__spath_curvetoa_tl
      {
        \bool_set_true:N \l_@@_taperable_bool
        \dim_set:Nn \l_@@_tmpc_dim {\tl_item:Nn \l_@@_tmpa_tl {5}}
        \dim_set:Nn \l_@@_tmpd_dim {\tl_item:Nn \l_@@_tmpa_tl {6}}
        \dim_set:Nn \l_@@_tmpe_dim {\tl_item:Nn \l_@@_tmpa_tl {8}}
        \dim_set:Nn \l_@@_tmpf_dim {\tl_item:Nn \l_@@_tmpa_tl {9}}
        \dim_set:Nn \l_@@_tmpg_dim {\tl_item:Nn \l_@@_tmpa_tl {11}}
        \dim_set:Nn \l_@@_tmph_dim {\tl_item:Nn \l_@@_tmpa_tl {12}}
        \prg_replicate:nn {10}
        {
          \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        }
        \tl_put_left:NV \l_@@_tmpa_tl \g__spath_moveto_tl
      }
    }
    {
      \bool_set_false:N \l_@@_taperable_bool
    }
    
    \bool_if:NT \l_@@_taperable_bool
    {
      \@@_taper_aux:
    }
    
  }

  \bool_if:NT \l_@@_taper_end_bool
  {

    \dim_set:Nn \l_@@_tmpa_dim {\tl_item:Nn \l_@@_tmpa_tl {-2}}
    \dim_set:Nn \l_@@_tmpb_dim {\tl_item:Nn \l_@@_tmpa_tl {-1}}
    \tl_set:Nx \l_@@_tmpb_tl {\tl_item:Nn \l_@@_tmpa_tl {-3}}

    \tl_case:NnF \l_@@_tmpb_tl
    {
      \g__spath_lineto_tl
      {

        \bool_set_true:N \l_@@_taperable_bool
        \dim_set:Nn \l_@@_tmpg_dim {\tl_item:Nn \l_@@_tmpa_tl {-5}}
        \dim_set:Nn \l_@@_tmph_dim {\tl_item:Nn \l_@@_tmpa_tl {-4}}
        \dim_set:Nn \l_@@_tmpc_dim {(2\l_@@_tmpa_dim + \l_@@_tmpg_dim)/3}
        \dim_set:Nn \l_@@_tmpd_dim {(2\l_@@_tmpb_dim + \l_@@_tmph_dim)/3}
        \dim_set:Nn \l_@@_tmpe_dim {(\l_@@_tmpa_dim + 2\l_@@_tmpg_dim)/3}
        \dim_set:Nn \l_@@_tmpf_dim {(\l_@@_tmpb_dim + 2\l_@@_tmph_dim)/3}
        \tl_reverse:N \l_@@_tmpa_tl
        \prg_replicate:nn {3}
        {
          \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        }
        \tl_reverse:N \l_@@_tmpa_tl
      }
      \g__spath_curveto_tl
      {
        \bool_set_true:N \l_@@_taperable_bool
        \dim_set:Nn \l_@@_tmpc_dim {\tl_item:Nn \l_@@_tmpa_tl {-5}}
        \dim_set:Nn \l_@@_tmpd_dim {\tl_item:Nn \l_@@_tmpa_tl {-4}}
        \dim_set:Nn \l_@@_tmpe_dim {\tl_item:Nn \l_@@_tmpa_tl {-8}}
        \dim_set:Nn \l_@@_tmpf_dim {\tl_item:Nn \l_@@_tmpa_tl {-7}}
        \dim_set:Nn \l_@@_tmpg_dim {\tl_item:Nn \l_@@_tmpa_tl {-11}}
        \dim_set:Nn \l_@@_tmph_dim {\tl_item:Nn \l_@@_tmpa_tl {-10}}
        \tl_reverse:N \l_@@_tmpa_tl
        \prg_replicate:nn {9}
        {
          \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        }
        \tl_reverse:N \l_@@_tmpa_tl
      }
    }
    {
      \bool_set_false:N \l_@@_taperable_bool
    }
    
    \bool_if:NT \l_@@_taperable_bool
    {
      \@@_taper_aux:
    }
    
  }

  \pgfsyssoftpath@setcurrentpath\l_@@_tmpa_tl
  \pgfsetstrokecolor{\pgfkeysvalueof{/tikz/pen~colour}}
  \pgfusepath{stroke}

}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_taper_aux:}
% Auxiliary macro to avoid unnecessary code duplication.
%    \begin{macrocode}
\cs_new_nopar:Npn \@@_taper_aux:
{
  \tl_clear:N \l_@@_tmpb_tl
  \tl_put_right:NV \l_@@_tmpb_tl \g__spath_moveto_tl

  \fp_set:Nn \l_@@_tmpa_fp
  {
    \l_@@_tmpd_dim - \l_@@_tmpb_dim
  }
  \fp_set:Nn \l_@@_tmpb_fp
  {
    \l_@@_tmpa_dim - \l_@@_tmpc_dim
  }
  \fp_set:Nn \l_@@_tmpe_fp
  {
    (\l_@@_tmpa_fp^2 + \l_@@_tmpb_fp^2)^.5
  }
  
  \fp_set:Nn \l_@@_tmpa_fp {.5*\l_@@_taper_width_dim *     \l_@@_tmpa_fp / \l_@@_tmpe_fp}
  \fp_set:Nn \l_@@_tmpb_fp {.5*\l_@@_taper_width_dim *     \l_@@_tmpb_fp / \l_@@_tmpe_fp}

  \fp_set:Nn \l_@@_tmpc_fp
  {
    \l_@@_tmph_dim - \l_@@_tmpf_dim
  }
  \fp_set:Nn \l_@@_tmpd_fp
  {
    \l_@@_tmpe_dim - \l_@@_tmpg_dim
  }
  \fp_set:Nn \l_@@_tmpe_fp
  {
    (\l_@@_tmpc_fp^2 + \l_@@_tmpd_fp^2)^.5
  }

  \fp_set:Nn \l_@@_tmpc_fp {.5*\l_@@_line_width_dim * \l_@@_tmpc_fp / \l_@@_tmpe_fp}
  \fp_set:Nn \l_@@_tmpd_fp {.5*\l_@@_line_width_dim * \l_@@_tmpd_fp / \l_@@_tmpe_fp}

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpa_dim}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpb_fp +             \l_@@_tmpb_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \g__spath_curvetoa_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpc_dim}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpb_fp + \l_@@_tmpd_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \g__spath_curvetob_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpc_fp + \l_@@_tmpe_dim}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpd_fp + \l_@@_tmpf_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \g__spath_curveto_tl
  
  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpc_fp + \l_@@_tmpg_dim}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpd_fp + \l_@@_tmph_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \g__spath_curvetoa_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpc_fp + \l_@@_tmpg_dim - \fp_to_dim:n{ 1.32 * \l_@@_tmpd_fp}}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpd_fp + \l_@@_tmph_dim + \fp_to_dim:n {1.32* \l_@@_tmpc_fp}}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \g__spath_curvetob_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpc_fp + \l_@@_tmpg_dim - \fp_to_dim:n {1.32 * \l_@@_tmpd_fp}}}
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpd_fp + \l_@@_tmph_dim + \fp_to_dim:n {1.32 * \l_@@_tmpc_fp}}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \g__spath_curveto_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpc_fp + \l_@@_tmpg_dim}}
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpd_fp + \l_@@_tmph_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \g__spath_curvetoa_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpc_fp + \l_@@_tmpe_dim}}
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpd_fp + \l_@@_tmpf_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \g__spath_curvetob_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpc_dim}}
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpb_fp + \l_@@_tmpd_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \g__spath_curveto_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpa_dim}}
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpb_fp + \l_@@_tmpb_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \g__spath_curvetoa_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpa_dim + \fp_to_dim:n{ 1.32 * \l_@@_tmpb_fp}}}
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpb_fp + \l_@@_tmpb_dim - \fp_to_dim:n {1.32* \l_@@_tmpa_fp}}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \g__spath_curvetob_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpa_dim + \fp_to_dim:n {1.32 * \l_@@_tmpb_fp}}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpb_fp + \l_@@_tmpb_dim - \fp_to_dim:n {1.32 * \l_@@_tmpa_fp}}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \g__spath_curveto_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpa_dim}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpb_fp +             \l_@@_tmpb_dim}}
  }

  \pgfsyssoftpath@setcurrentpath\l_@@_tmpb_tl
  \pgfsetfillcolor{\pgfkeysvalueof{/tikz/pen~colour}}
  \pgfusepath{fill}
}
%    \end{macrocode}
% \end{macro}
%
% Defines a copperplate pen.
%    \begin{macrocode}
\tl_set:Nn \l_@@_tmpa_tl {\pgfsyssoftpath@movetotoken{0pt}{0pt}}
\spath_map_path_components_into_list:NN \l_@@_tmpa_tl \l_@@_pen_copperplate
\tl_map_inline:Nn \l_@@_pen_copperplate
{
  \spath_generate_all:n {#1}
}
%    \end{macrocode}
%
% \begin{macro}{\CopperplatePath}
% This is used in the decorations section to convert a path to a copperplate path.
%    \begin{macrocode}
\DeclareDocumentCommand \CopperplatePath { m }
{
  \spath_map_path_components_into_list:NN #1 \l_@@_spath_list
  \tl_map_inline:cn {l_@@_spath_list}
  {
    \spath_open_path:n {##1}
    \spath_generate_all:n {##1}
  }
  \cal_path_create:Nc \l_@@_spath_list {l_@@_pen_copperplate}
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
%
% \subsection{Decorations}
%
% If a decoration library is loaded we define some decorations that use the calligraphy library, specifically the copperplate pen with its tapering.
%
% First, a brace decoration.
%    \begin{macrocode}
\expandafter\ifx\csname pgfdeclaredecoration\endcsname\relax
\else
\pgfdeclaredecoration{calligraphic brace}{brace}
{
  \state{brace}[width=+\pgfdecoratedremainingdistance,next state=final]
  {
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}
    \pgfpathmoveto{\pgfpointorigin}
    \pgfpathcurveto
    {\pgfqpoint{.15\pgfdecorationsegmentamplitude}{.3\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
    {
      \pgftransformxshift{+\pgfdecorationsegmentaspect\pgfdecoratedremainingdistance}
      \pgfpathlineto{\pgfqpoint{-\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{-.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{-.15\pgfdecorationsegmentamplitude}{.7\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{0\pgfdecorationsegmentamplitude}{1\pgfdecorationsegmentamplitude}}
      \pgfpathmoveto{\pgfqpoint{0\pgfdecorationsegmentamplitude}{1\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{.15\pgfdecorationsegmentamplitude}{.7\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
    }
    {
      \pgftransformxshift{+\pgfdecoratedremainingdistance}
      \pgfpathlineto{\pgfqpoint{-\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{-.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{-.15\pgfdecorationsegmentamplitude}{.3\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{0pt}{0pt}}
    }
    \tikzset{
      taper width=.5\pgflinewidth,
      taper
    }%
    \pgfsyssoftpath@getcurrentpath\cal@tmp@path
    \CopperplatePath{\cal@tmp@path}
  }
  \state{final}{}
}
%    \end{macrocode}
%
% The second is a straightened parenthesis (so that when very large it doesn't bow out too far).
%    \begin{macrocode}
\pgfdeclaredecoration{calligraphic straight parenthesis}{brace}
{
  \state{brace}[width=+\pgfdecoratedremainingdistance,next state=final]
  {
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}
    \pgfpathmoveto{\pgfpointorigin}
    \pgfpathcurveto
    {\pgfqpoint{.76604\pgfdecorationsegmentamplitude}{.64279\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{2.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{3.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
    {
      \pgftransformxshift{+\pgfdecoratedremainingdistance}
      \pgfpathlineto{\pgfqpoint{-3.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{-2.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{-.76604\pgfdecorationsegmentamplitude}{.64279\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{0pt}{0pt}}
    }
    \tikzset{
      taper width=.5\pgflinewidth,
      taper
    }%
    \pgfsyssoftpath@getcurrentpath\cal@tmp@path
    \CopperplatePath{\cal@tmp@path}
  }
  \state{final}{}%
}
%    \end{macrocode}
%
% The third is a curved parenthesis.
%    \begin{macrocode}
\pgfdeclaredecoration{calligraphic curved parenthesis}{brace}
{
  \state{brace}[width=+\pgfdecoratedremainingdistance,next state=final]
  {
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}
    \pgfpathmoveto{\pgfpointorigin}
    \pgf@xa=\pgfdecoratedremainingdistance\relax
    \advance\pgf@xa by -1.5890\pgfdecorationsegmentamplitude\relax
    \edef\cgrphy@xa{\the\pgf@xa}
    \pgfpathcurveto
    {\pgfqpoint{1.5890\pgfdecorationsegmentamplitude}{1.3333\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{\cgrphy@xa}{1.3333\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{\pgfdecoratedremainingdistance}{0pt}}
    \tikzset{
      taper width=.5\pgflinewidth,
      taper
    }%
    \pgfsyssoftpath@getcurrentpath\cal@tmp@path
    \CopperplatePath{\cal@tmp@path}
  }
  \state{final}{}%
}
%    \end{macrocode}
% End the conditional for if pgfdecoration module is loaded
%    \begin{macrocode}
\fi
%    \end{macrocode}
% \iffalse
%</calligraphy>
% \fi
% 
%
% \iffalse
%<*knots>
% \fi
%%
% \section{Drawing Knots}
%
%    \begin{macrocode}
%<@@=knot>
%    \end{macrocode}
%
% \subsection{Initialisation}
%
% We load the \Verb+spath3+ library and the \Verb+intersections+ TikZ library.
% Then we get going.
%    \begin{macrocode}
\RequirePackage{spath3}
\usetikzlibrary{intersections,spath3}

\ExplSyntaxOn

\tl_new:N \l__knot_tmpa_tl
\tl_new:N \l__knot_tmpb_tl
\tl_new:N \l__knot_tmpc_tl
\tl_new:N \l__knot_tmpd_tl
\tl_new:N \l__knot_tmpe_tl
\tl_new:N \l__knot_tmpf_tl
\tl_new:N \l__knot_tmpg_tl
\tl_new:N \l__knot_redraws_tl
\tl_new:N \l__knot_clip_width_tl
\tl_new:N \l__knot_name_tl
\tl_new:N \l__knot_node_tl
\tl_new:N \l__knot_aux_tl
\tl_new:N \l__knot_auxa_tl

\int_new:N \l__knot_tmpa_int
\int_new:N \l__knot_strands_int
\int_new:N \l__knot_intersections_int
\int_new:N \l__knot_filaments_int
\int_new:N \l__knot_component_start_int

\dim_new:N \l__knot_tmpa_dim
\dim_new:N \l__knot_tmpb_dim
\dim_new:N \l__knot_tmpc_dim
\dim_new:N \l__knot_tolerance_dim
\dim_new:N \l__knot_clip_bg_radius_dim
\dim_new:N \l__knot_clip_draw_radius_dim

\bool_new:N \l__knot_draft_bool
\bool_new:N \l__knot_ignore_ends_bool
\bool_new:N \l__knot_self_intersections_bool
\bool_new:N \l__knot_splits_bool
\bool_new:N \l__knot_super_draft_bool

\bool_new:N \l__knot_prepend_prev_bool
\bool_new:N \l__knot_append_next_bool
\bool_new:N \l__knot_skip_bool
\bool_new:N \l__knot_save_bool

\seq_new:N \g__knot_nodes_seq

\bool_set_true:N \l__knot_ignore_ends_bool
%    \end{macrocode}
%
% Configuration is via TikZ keys and styles.
%    \begin{macrocode}
\tikzset{
  knot/.code={
    \tl_if_eq:nnTF {#1} {none}
    {
      \tikz@addmode{\tikz@mode@doublefalse}
    }
    {
      \tikz@addmode{\tikz@mode@doubletrue}
      \tl_if_eq:nnTF {\pgfkeysnovalue} {#1}
      {
        \tikz@addoption{\pgfsetinnerstrokecolor{.}}
      }
      {
        \pgfsetinnerstrokecolor{#1}
      }
      \tikz@addoption{
        \pgfsetstrokecolor{knotbg}
      }
      \tl_set:Nn \tikz@double@setup{
        \pgfsetinnerlinewidth{\pgflinewidth}
        \pgfsetlinewidth{\dim_eval:n {\tl_use:N \l__knot_gap_tl \pgflinewidth}}
      }
    }
  },
  knot~ gap/.store~ in=\l__knot_gap_tl,
  knot~ gap=3,
  knot~ diagram/.is~family,
  knot~ diagram/.unknown/.code={
    \tl_set_eq:NN \l__knot_tmpa_tl \pgfkeyscurrentname
    \pgfkeysalso{
      /tikz/\l__knot_tmpa_tl=#1
    }
  },
  background~ colour/.code={%
    \colorlet{knotbg}{#1}%
  },
  background~ color/.code={%
    \colorlet{knotbg}{#1}%
  },
  background~ colour=white,
  knot~ diagram,
  name/.store~ in=\l__knot_name_tl,
  name={knot},
  save~ intersections/.is~ choice,
  save~ intersections/.default=true,
  save~ intersections/true/.code={
    \bool_set_true:N \l__knot_save_bool
  },
  save~ intersections/false/.code={
    \bool_set_false:N \l__knot_save_bool
  },
  every~ strand/.style={draw},
  ignore~ endpoint~ intersections/.code={
    \tl_if_eq:nnTF {#1} {true}
    {
      \bool_set_true:N \l__knot_ignore_ends_bool
    }
    {
      \bool_set_false:N \l__knot_ignore_ends_bool
    }
  },
  ignore~ endpoint~ intersections/.default=true,
  consider~ self~ intersections/.is~choice,
  consider~ self~ intersections/true/.code={
    \bool_set_true:N \l__knot_self_intersections_bool
    \bool_set_true:N \l__knot_splits_bool
  },
  consider~ self~ intersections/false/.code={
    \bool_set_false:N \l__knot_self_intersections_bool
    \bool_set_false:N \l__knot_splits_bool
  },
  consider~ self~ intersections/no~ splits/.code={
    \bool_set_true:N \l__knot_self_intersections_bool
    \bool_set_false:N \l__knot_splits_bool
  },
  consider~ self~ intersections/.default={true},
  clip~ radius/.code={
    \dim_set:Nn \l__knot_clip_bg_radius_dim {#1}
    \dim_set:Nn \l__knot_clip_draw_radius_dim {#1+2pt}
  },
  clip~ draw~ radius/.code={
    \dim_set:Nn \l__knot_clip_draw_radius_dim {#1}
  },
  clip~ background~ radius/.code={
    \dim_set:Nn \l__knot_clip_bg_radius_dim {#1}
  },
  clip~ radius=10pt,
  end~ tolerance/.code={
    \dim_set:Nn \l__knot_tolerance_dim {#1}
  },
  end~ tolerance=14pt,
  clip/.style={
    clip
  },
  background~ clip/.style={
    clip
  },
  clip~ width/.code={
    \tl_set:Nn \l__knot_clip_width_tl {#1}
  },
  clip~ width=3,
  flip~ crossing/.code={%
    \tl_clear_new:c {l__knot_crossing_#1}
    \tl_set:cn {l__knot_crossing_#1} {x}
  },
  ignore~ crossing/.code={%
    \tl_clear_new:c {l__knot_ignore_crossing_#1}
    \tl_set:cn {l__knot_ignore_crossing_#1} {x}
  },
  draft~ mode/.is~ choice,
  draft~ mode/off/.code={%
    \bool_set_false:N \l__knot_draft_bool
    \bool_set_false:N \l__knot_super_draft_bool
  },
  draft~ mode/crossings/.code={%
    \bool_set_true:N \l__knot_draft_bool
    \bool_set_false:N \l__knot_super_draft_bool
  },
  draft~ mode/strands/.code={%
    \bool_set_true:N \l__knot_draft_bool
    \bool_set_true:N \l__knot_super_draft_bool
  },
  draft/.is~ family,
  draft,
  crossing~ label/.style={
    overlay,
    fill=white,
    fill~ opacity=.5,
    text~ opacity=1,
    text=blue,
    pin~ edge={blue,<-}
  },
  strand~ label/.style={
    overlay,
    circle,
    draw=purple,
    fill=white,
    fill~ opacity=.5,
    text~ opacity=1,
    text=purple,
    inner~ sep=0pt
  },
}
%    \end{macrocode}
%
% Wrapper around \Verb+\tikzset+ for applying keys from a token list, checking for if the given token list exists.
%    \begin{macrocode}
\cs_new_nopar:Npn \knot_apply_style:N #1
{
  \tl_if_exist:NT #1 {
    \exp_args:NV \tikzset #1
  }
}
\cs_generate_variant:Nn \knot_apply_style:N {c}
%    \end{macrocode}
%
%\begin{macro}[internal]{\flipcrossings}
% The user can specify a comma separated list of crossings to flip.
%    \begin{macrocode}
\NewDocumentCommand \flipcrossings {m}
{
  \tikzset{knot~ diagram/flip~ crossing/.list={#1}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\strand}
% This is how the user specifies a strand of the knot.
%    \begin{macrocode}
\NewDocumentCommand \strand { O{} }
{
  \int_incr:N \l__knot_strands_int
  \tl_clear_new:c {l__knot_options_strand \int_use:N \l__knot_strands_int}
  \tl_set:cn {l__knot_options_strand \int_use:N \l__knot_strands_int} {#1}
  \path[#1,save~ spath=knot strand \int_use:N  \l__knot_strands_int]
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{knot}
% This is the wrapper environment that calls the knot generation code.
%    \begin{macrocode}
\NewDocumentEnvironment{knot} { O{} }
{
  \knot_initialise:n {#1}
}
{
  \knot_render:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_initialise:n}
% Set up some stuff before loading in the strands.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_initialise:n #1
{
  \tikzset{knot~ diagram/.cd,every~ knot~ diagram/.try,#1}
  \int_zero:N \l__knot_strands_int
  \tl_clear:N \l__knot_redraws_tl
  \seq_gclear:N \g__knot_nodes_seq
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_render:}
% This is the code that starts the work of rendering the knot.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_render:
{
%    \end{macrocode}
% Start a scope and reset the transformation (since all transformations have already been taken into account when defining the strands).
%    \begin{macrocode}
  \pgfscope
  \pgftransformreset
%    \end{macrocode}
% Loop through the strands drawing each one for the first time.
%    \begin{macrocode}
  \int_step_function:nnnN {1} {1} {\l__knot_strands_int} \knot_draw_strand:n
%    \end{macrocode}
% In super draft mode we don't do anything else.
%    \begin{macrocode} 
  \bool_if:NF \l__knot_super_draft_bool
  {
%    \end{macrocode}
% In draft mode we draw labels at the ends of the strands; this also handles splitting curves to avoid self-intersections of Bezier curves if that's requested.
%    \begin{macrocode}
    \int_step_function:nnnN {1} {1} {\l__knot_strands_int} \knot_draw_labels:n
%    \end{macrocode}
% If we're considering self intersections we need to split the strands into filaments.
%    \begin{macrocode}
    \bool_if:NTF \l__knot_self_intersections_bool
    {
      \knot_split_strands:
      \int_set_eq:NN \l__knot_tmpa_int \l__knot_filaments_int
      \tl_set:Nn \l__knot_prefix_tl {filament}
    }
    {
      \int_set_eq:NN \l__knot_tmpa_int \l__knot_strands_int
      \tl_set:Nn \l__knot_prefix_tl {strand}
    }
%    \end{macrocode}
% Initialise the intersection count.
%    \begin{macrocode}
    \int_gzero:N \l__knot_intersections_int
%    \end{macrocode}
% If in draft mode we label the intersections, otherwise we just stick a coordinate at each one.
%    \begin{macrocode}
    \tl_clear:N \l__knot_node_tl
    \bool_if:NT \l__knot_draft_bool
    {
      \tl_set:Nn \l__knot_node_tl {
        \exp_not:N \node[coordinate,
          pin={[node~ contents={\int_use:N \l__knot_intersections_int},knot~ diagram/draft/crossing~ label, knot~ diagram/draft/crossing~ \int_use:N \l__knot_intersections_int \c_space_tl label/.try]
            }]
      }
    }
%    \end{macrocode}
% This double loop steps through the pieces (strands or filaments) and computes the intersections and does stuff with those.
%    \begin{macrocode}
    \int_step_variable:nnnNn {1} {1} {\l__knot_tmpa_int - 1} \l__knot_tmpa_tl
    {
      \int_step_variable:nnnNn {\tl_use:N \l__knot_tmpa_tl + 1} {1}     {\l__knot_tmpa_int} \l__knot_tmpb_tl
      {
        \knot_intersections:VV \l__knot_tmpa_tl \l__knot_tmpb_tl
      }
    }
%    \end{macrocode}
% If any redraws were requested, do them here.
%    \begin{macrocode}
    \tl_use:N \l__knot_redraws_tl
%    \end{macrocode}
% Draw the crossing nodes
%    \begin{macrocode}
    \seq_use:Nn \g__knot_nodes_seq {}
  }
%    \end{macrocode}
% Close the scope
%    \begin{macrocode}
  \endpgfscope
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_draw_strand:n}
% This renders a strand using the options originally specified.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_draw_strand:n #1
{
  \pgfscope
  \group_begin:
  \spath_bake_round:n {knot strand #1}
  \tl_set:Nn \l_tmpa_tl {knot~ diagram/every~ strand/.try,}
  \tl_put_right:Nv \l_tmpa_tl {l__knot_options_strand #1}
  \tl_put_right:Nn \l_tmpa_tl {,knot~ diagram/only~ when~ rendering/.try,only~ when~ rendering/.try}
  \spath_tikz_path:Vn \l_tmpa_tl {knot strand #1}
  \group_end:
  \endpgfscope
}
\cs_generate_variant:Nn \tl_put_right:Nn {Nv}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_draw_labels:n}
% Draw a label at each end of each strand, if in draft mode.
% Also, if requested, split potentially self intersecting Bezier curves.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_draw_labels:n #1
{
  \bool_if:NT \l__knot_draft_bool
  {
    \spath_get:nnN {knot strand #1} {final point} \l__knot_tmpb_tl
    \dim_set:Nn \l__knot_tmpa_dim {\tl_item:Nn \l__knot_tmpb_tl {1}}
    \dim_set:Nn \l__knot_tmpb_dim {\tl_item:Nn \l__knot_tmpb_tl {2}}
    \node[knot~ diagram/draft/strand~label] at (\l__knot_tmpa_dim,\l__knot_tmpb_dim) {#1};
    \spath_get:nnN {knot strand #1} {initial point} \l__knot_tmpb_tl
    \dim_set:Nn \l__knot_tmpa_dim {\tl_item:Nn \l__knot_tmpb_tl {1}}
    \dim_set:Nn \l__knot_tmpb_dim {\tl_item:Nn \l__knot_tmpb_tl {2}}
    \node[knot~ diagram/draft/strand~label] at (\l__knot_tmpa_dim,\l__knot_tmpb_dim) {#1};
  }
  \bool_if:nT {
    \l__knot_self_intersections_bool
    &&
    \l__knot_splits_bool
  }
  {
    \tl_clear:N \l__knot_tmpa_tl
    \spath_map_segments_function:nN {knot strand #1} \knot_split_self_intersects:NN
    \spath_put:nnV {knot strand #1} {path} \l__knot_tmpa_tl
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_split_self_intersects:NN}
% This is the macro that does the split.
% Figuring out whether a Bezier cubic self intersects is apparently a difficult problem so we don't bother.
% We compute a point such that if there is an intersection then it lies on either side of the point.
% I don't recall where the formula came from!
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_split_self_intersects:NN #1#2
{
  \tl_case:NnF #1
  {
    \g__spath_curvetoa_tl
    {
      \fp_set:Nn \l_tmpa_fp
      {
        (\tl_item:Nn #2 {3} - 3 * \tl_item:Nn #2 {6} + 3 * \tl_item:Nn #2 {9} - \tl_item:Nn #2 {12})
        *
        (3 * \tl_item:Nn #2 {8} - 3 * \tl_item:Nn #2 {11})
        -
        (\tl_item:Nn #2 {2} - 3 * \tl_item:Nn #2 {5} + 3 * \tl_item:Nn #2 {8} - \tl_item:Nn #2 {11})
        *
        (3 * \tl_item:Nn #2 {9} - 3 * \tl_item:Nn #2 {12})
      }
      \fp_set:Nn \l_tmpb_fp
      {
        (\tl_item:Nn #2 {2} - 3 * \tl_item:Nn #2 {5} + 3 * \tl_item:Nn #2 {8} - \tl_item:Nn #2 {11})
        *
        (3 * \tl_item:Nn #2 {6} - 6 * \tl_item:Nn #2 {9} + 3 * \tl_item:Nn #2 {12})
        -
        (\tl_item:Nn #2 {3} - 3 * \tl_item:Nn #2 {6} + 3 * \tl_item:Nn #2 {9} - \tl_item:Nn #2 {12})
        *
        (3 * \tl_item:Nn #2 {5} - 6 * \tl_item:Nn #2 {8} + 3 * \tl_item:Nn #2 {11})
      }
      \fp_compare:nTF
      {
        \l_tmpb_fp != 0
      }
      {
        \fp_set:Nn \l_tmpa_fp {.5 * \l_tmpa_fp / \l_tmpb_fp}
        \fp_compare:nTF
        {
          0 < \l_tmpa_fp && \l_tmpa_fp < 1
        }
        {
          \spath_split_curve:VVNN \l_tmpa_fp #2 \l_tmpa_tl \l_tmpb_tl
          \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
          \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
          \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
          \tl_set:Nx \l_tmpb_tl {\tl_tail:N \l_tmpb_tl}
          \tl_set:Nx \l_tmpb_tl {\tl_tail:N \l_tmpb_tl}
          \tl_set:Nx \l_tmpb_tl {\tl_tail:N \l_tmpb_tl}
          \tl_put_right:NV \l__knot_tmpa_tl \l_tmpa_tl
          \tl_put_right:NV \l__knot_tmpa_tl \l_tmpb_tl
        }
        {
          \tl_set_eq:NN \l_tmpa_tl #2
          \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
          \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
          \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
          \tl_put_right:NV \l__knot_tmpa_tl \l_tmpa_tl
        }
      }
      {
        \tl_set_eq:NN \l_tmpa_tl #2
        \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
        \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
        \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
        \tl_put_right:NV \l__knot_tmpa_tl \l_tmpa_tl
      }
    }
    \g__spath_lineto_tl
    {
      \tl_set_eq:NN \l_tmpa_tl #2
      \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
      \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
      \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
      \tl_put_right:NV \l__knot_tmpa_tl \l_tmpa_tl
    }
  }
  {
    \tl_put_right:NV \l__knot_tmpa_tl #2
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_intersections:nn}
% This computes the intersections of two pieces and steps through them.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_intersections:nn #1#2
{
  \group_begin:
  \tl_set_eq:NN \l__knot_tmpa_tl \l__knot_prefix_tl
  \tl_put_right:Nn \l__knot_tmpa_tl {#1}
  \tl_set_eq:NN \l__knot_tmpb_tl \l__knot_prefix_tl
  \tl_put_right:Nn \l__knot_tmpb_tl {#2}
  \spath_get:nnN {knot \tl_use:N \l__knot_tmpa_tl} {path} \l__knot_tmpc_tl
  \spath_get:nnN {knot \tl_use:N \l__knot_tmpb_tl} {path} \l__knot_tmpd_tl

  \bool_if:nTF {
    \l__knot_save_bool
    &&
    \tl_if_exist_p:c {knot~ intersections~ \tl_use:N \l__knot_name_tl - \tl_use:N \l__knot_tmpa_tl -  \tl_use:N \l__knot_tmpb_tl}
  }
  {
    \tl_use:c {knot~ intersections~ \tl_use:N \l__knot_name_tl - \tl_use:N \l__knot_tmpa_tl -  \tl_use:N \l__knot_tmpb_tl}
  }
  {
\pgfintersectionofpaths{\pgfsetpath\l__knot_tmpc_tl}{\pgfsetpath\l__knot_tmpd_tl}

  }
  \int_compare:nT {\pgfintersectionsolutions > 0}
  {
    \int_step_function:nnnN {1} {1} {\pgfintersectionsolutions} \knot_do_intersection:n
  }
  \knot_save_intersections:VV \l__knot_tmpa_tl \l__knot_tmpb_tl
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_save_intersections:nn}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_save_intersections:nn #1#2
{
  \bool_if:NT \l__knot_save_bool
  {
    \tl_clear:N \l__knot_aux_tl
    \tl_put_right:Nn \l__knot_aux_tl
    {
      \def\pgfintersectionsolutions
    }
    \tl_put_right:Nx \l__knot_aux_tl
    {
      {\int_eval:n {\pgfintersectionsolutions}}
    }
    \int_compare:nT {\pgfintersectionsolutions > 0}
    {
      \int_step_inline:nnnn {1} {1} {\pgfintersectionsolutions}
      {
        \pgfpointintersectionsolution{##1}
        \dim_set:Nn \l__knot_tmpa_dim {\pgf@x}
        \dim_set:Nn \l__knot_tmpb_dim {\pgf@y}
        \tl_put_right:Nn \l__knot_aux_tl
        {
          \expandafter\def\csname pgfpoint@intersect@solution@##1\endcsname
        }
        \tl_put_right:Nx \l__knot_aux_tl
        {
          {\exp_not:N \pgf@x=\dim_use:N \l__knot_tmpa_dim\exp_not:N\relax\exp_not:N \pgf@y =\dim_use:N \l__knot_tmpb_dim\relax}
        }
      }
      \tl_set:Nn \l__knot_auxa_tl {\expandafter \gdef \csname knot~ intersections~}
      \tl_put_right:Nx \l__knot_auxa_tl {\tl_use:N \l__knot_name_tl - #1 - #2}
      \tl_put_right:Nn \l__knot_auxa_tl {\endcsname}
      \tl_put_right:Nx \l__knot_auxa_tl {{\tl_to_str:N \l__knot_aux_tl}}
      \protected@write\@auxout{}{\tl_to_str:N \l__knot_auxa_tl}
    }
  }
}
\cs_generate_variant:Nn \knot_save_intersections:nn {VV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_do_intersection:n}
% This handles a specific intersection.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_do_intersection:n #1
{
%    \end{macrocode}
% Get the intersection coordinates.
%    \begin{macrocode}
  \pgfpointintersectionsolution{#1}
  \dim_set:Nn \l__knot_tmpa_dim {\pgf@x}
  \dim_set:Nn \l__knot_tmpb_dim {\pgf@y}
%    \end{macrocode}
% If we're dealing with filaments, we can get false positives from the end points.
%    \begin{macrocode}
  \bool_set_false:N \l__knot_skip_bool
  \bool_if:NT \l__knot_self_intersections_bool
  {
%    \end{macrocode}
% If one filament preceded the other, test for the intersection being at the relevant end point.
%    \begin{macrocode}
    \tl_set:Nn \l_tmpa_tl {knot previous}
    \tl_put_right:NV \l_tmpa_tl \l__knot_tmpa_tl
    \tl_set:Nv \l_tmpa_tl \l_tmpa_tl
    \tl_if_eq:NNT \l_tmpa_tl \l__knot_tmpb_tl
    {
      \knot_test_endpoint:VnT \l__knot_tmpb_tl {final point}
      {
        \bool_set_true:N \l__knot_skip_bool
      }
    }

    \tl_set:Nn \l_tmpa_tl {knot previous}
    \tl_put_right:NV \l_tmpa_tl \l__knot_tmpb_tl
    \tl_set:Nv \l_tmpa_tl \l_tmpa_tl
    \tl_if_eq:NNT \l_tmpa_tl \l__knot_tmpa_tl
    {
      \knot_test_endpoint:VnT \l__knot_tmpa_tl {final point}
      {
        \bool_set_true:N \l__knot_skip_bool
      }
    }
  }
%    \end{macrocode}
% The user can also say that end points of filaments (or strands) should simply be ignored anyway.
%    \begin{macrocode}
  \bool_if:NT \l__knot_ignore_ends_bool
  {
    \knot_test_endpoint:VnT \l__knot_tmpa_tl {initial point}
    {
      \bool_set_true:N \l__knot_skip_bool
    }
    \knot_test_endpoint:VnT \l__knot_tmpa_tl {final point}
    {
      \bool_set_true:N \l__knot_skip_bool
    }
    \knot_test_endpoint:VnT \l__knot_tmpb_tl {initial point}
    {
      \bool_set_true:N \l__knot_skip_bool
    }
    \knot_test_endpoint:VnT \l__knot_tmpb_tl {final point}
    {
      \bool_set_true:N \l__knot_skip_bool
    }
  }
%    \end{macrocode}
% Assuming that we passed all the above tests, we render the crossing.
%    \begin{macrocode}
  \bool_if:NF \l__knot_skip_bool
  {

    \int_gincr:N \l__knot_intersections_int
%    \end{macrocode}
% This is the intersection test.
% If the intersection finder finds too many, it might be useful to ignore some.
%    \begin{macrocode}
    \bool_if:nF
    {
      \tl_if_exist_p:c {l__knot_ignore_crossing_ \int_use:N
        \l__knot_intersections_int}
      &&
      ! \tl_if_empty_p:c {l__knot_ignore_crossing_ \int_use:N
        \l__knot_intersections_int}
    }
    {
%    \end{macrocode}
% This is the flip test.
% We only render one of the paths.
% The ``flip'' swaps which one we render.
%    \begin{macrocode}
      \bool_if:nTF
      {
        \tl_if_exist_p:c {l__knot_crossing_ \int_use:N
          \l__knot_intersections_int}
        &&
        ! \tl_if_empty_p:c {l__knot_crossing_ \int_use:N
          \l__knot_intersections_int}
      }
      {
        \tl_set_eq:NN \l__knot_tmpg_tl \l__knot_tmpb_tl
      }
      {
        \tl_set_eq:NN \l__knot_tmpg_tl \l__knot_tmpa_tl
      }
%    \end{macrocode}
% Now we know which one we're rendering, we test to see if we should also render its predecessor or successor to ensure that we render a path through the entire crossing region.
%    \begin{macrocode} 
      \bool_if:NT \l__knot_self_intersections_bool
      {
        \knot_test_endpoint:VnT \l__knot_tmpg_tl {initial point}
        {
          \bool_set_true:N \l__knot_prepend_prev_bool
        }
        {
          \bool_set_false:N \l__knot_prepend_prev_bool
        }
        \knot_test_endpoint:VnT \l__knot_tmpg_tl {final point}
        {
          \bool_set_true:N \l__knot_append_next_bool
        }
        {
          \bool_set_false:N \l__knot_append_next_bool
        }
%    \end{macrocode}
% If either of those tests succeeded, do the appending or prepending.
%    \begin{macrocode}
        \bool_if:nT
        {
          \l__knot_prepend_prev_bool || \l__knot_append_next_bool
        }
        {
          \spath_clone:nn {knot \tl_use:N \l__knot_tmpg_tl}
          {knot \tl_use:N \l__knot_prefix_tl -1}

          \tl_set_eq:cc {l__knot_options_ \tl_use:N \l__knot_prefix_tl -1} {l__knot_options_ \tl_use:N \l__knot_tmpg_tl}

          \bool_if:nT
          {
            \l__knot_prepend_prev_bool
            &&
            \tl_if_exist_p:c {knot previous \tl_use:N \l__knot_tmpg_tl}
            &&
            !\tl_if_empty_p:c {knot previous \tl_use:N \l__knot_tmpg_tl}
          }
          {
            \spath_prepend_no_move:nn {knot \tl_use:N \l__knot_prefix_tl -1} {knot \tl_use:c {knot previous \tl_use:N \l__knot_tmpg_tl}}
%    \end{macrocode}
% If we split potentially self intersecting curves, we test to see if we should prepend yet another segment.
%    \begin{macrocode}
            \bool_if:nT
            {
              \l__knot_splits_bool
              &&
              \tl_if_exist_p:c {knot previous \tl_use:N \l__knot_tmpg_tl}
              &&
              !\tl_if_empty_p:c {knot previous \tl_use:N \l__knot_tmpg_tl}
            }
            {
              \knot_test_endpoint:vnT {knot previous \tl_use:N \l__knot_tmpg_tl} {initial point}
              {
                \spath_get:nnN {knot \tl_use:N \l__knot_prefix_tl -1} {path} \l_tmpa_tl
                \spath_prepend_no_move:nn {knot \tl_use:N \l__knot_prefix_tl -1} {knot \tl_use:c {knot previous \tl_use:c {knot previous \tl_use:N \l__knot_tmpg_tl}}}
                \spath_get:nnN {knot \tl_use:N \l__knot_prefix_tl -1} {path} \l_tmpa_tl
              
              }
            }
          }
%    \end{macrocode}
% Now the same for appending.
%    \begin{macrocode}
          \bool_if:nT
          {
            \l__knot_append_next_bool
            &&
            \tl_if_exist_p:c {knot next \tl_use:N \l__knot_tmpg_tl}
            &&
            !\tl_if_empty_p:c {knot previous \tl_use:N \l__knot_tmpg_tl}
          }
          {
            \spath_append_no_move:nn {knot \tl_use:N \l__knot_prefix_tl -1} {knot \tl_use:c {knot next \tl_use:N \l__knot_tmpg_tl}}
            \bool_if:nT
            {
              \l__knot_splits_bool
              &&
              \tl_if_exist_p:c {knot previous \tl_use:N
                \l__knot_tmpg_tl}
              &&
              !\tl_if_empty_p:c {knot previous \tl_use:N \l__knot_tmpg_tl}
            }
            {
              \knot_test_endpoint:vnT {knot previous \tl_use:N \l__knot_tmpg_tl} {final point}
              {
                \spath_append_no_move:nn {knot \tl_use:N \l__knot_prefix_tl -1} {knot \tl_use:c {knot next \tl_use:c {knot next \tl_use:N \l__knot_tmpg_tl}}}
                
              }
            }
          }

          \tl_set:Nn \l__knot_tmpg_tl {\tl_use:N \l__knot_prefix_tl -1}
        }
      }
%    \end{macrocode}
% Now we render the crossing.
%    \begin{macrocode}
      \pgfscope
      \group_begin:
      \tikzset{knot~ diagram/every~ intersection/.try, every~ intersection/.try, knot~ diagram/intersection~ \int_use:N \l__knot_intersections_int/.try}
      \knot_draw_crossing:nVV {\tl_use:N \l__knot_tmpg_tl} \l__knot_tmpa_dim \l__knot_tmpb_dim
      \coordinate (\l__knot_name_tl \c_space_tl \int_use:N \l__knot_intersections_int) at (\dim_use:N \l__knot_tmpa_dim, \dim_use:N \l__knot_tmpb_dim);
      \group_end:
      \endpgfscope
%    \end{macrocode}
% This ends the boolean as to whether to consider the intersection at all      
%    \begin{macrocode}
    }
%    \end{macrocode}
% And possibly stick a coordinate with a label at the crossing.
%    \begin{macrocode}
    \tl_if_empty:NF \l__knot_node_tl
    {
      \seq_gpush:Nx \g__knot_nodes_seq { \l__knot_node_tl at (\dim_use:N \l__knot_tmpa_dim, \dim_use:N \l__knot_tmpb_dim) {};}
    }
  }
}

\cs_generate_variant:Nn \knot_intersections:nn {VV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_test_endpoint:N}
% Test whether the point is near the intersection point.
%    \begin{macrocode}
\prg_new_conditional:Npnn \knot_test_endpoint:N #1 {p,T,F,TF}
{
  \dim_compare:nTF
  {
    \dim_abs:n { \l__knot_tmpa_dim - \tl_item:Nn #1 {1}}
    +
    \dim_abs:n { \l__knot_tmpb_dim - \tl_item:Nn #1 {2}}
    <
    \l__knot_tolerance_dim
  }
  {
    \prg_return_true:
  }
  {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_test_endpoint:nn}
% Wrapper around the above.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \knot_test_endpoint:nn #1#2 {T,F,TF}
{
  \spath_get:nnN {knot #1} {#2} \l__knot_tmpd_tl
  \knot_test_endpoint:NTF \l__knot_tmpd_tl
  {
    \prg_return_true:
  }
  {
    \prg_return_false:
  }
}

\cs_generate_variant:Nn \knot_test_endpoint:nnT {VnT,vnT}
\cs_generate_variant:Nn \knot_test_endpoint:nnF {VnF,vnF}
\cs_generate_variant:Nn \knot_test_endpoint:nnTF {VnTF,vnTF}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_draw_crossing:nnn}
% This is the code that actually renders a crossing.
%    \begin{macrocode}
\cs_new_nopar:Npn \knot_draw_crossing:nnn #1#2#3
{
  \group_begin:
  \pgfscope
  \path[knot~ diagram/background~ clip] (#2, #3) circle[radius=\l__knot_clip_bg_radius_dim];

  \tl_set:Nn \l_tmpa_tl {knot~ diagram/every~ strand/.try,}
  \tl_if_exist:cT {l__knot_options_ #1}
  {
  \tl_put_right:Nv \l_tmpa_tl {l__knot_options_ #1}
  }
  \tl_put_right:Nn \l_tmpa_tl {,knotbg,line~ width= \tl_use:N \l__knot_clip_width_tl * \pgflinewidth}
  \spath_tikz_path:Vn \l_tmpa_tl {knot #1}

  \endpgfscope

  \pgfscope
  \path[knot~ diagram/clip] (#2, #3) circle[radius=\l__knot_clip_draw_radius_dim];

  \tl_set:Nn \l_tmpa_tl {knot~ diagram/every~ strand/.try,}
  \tl_if_exist:cT {l__knot_options_ #1}
  {
  \tl_put_right:Nv \l_tmpa_tl {l__knot_options_ #1}
  }
  \tl_put_right:Nn \l_tmpa_tl {,knot~ diagram/only~ when~ rendering/.try,only~ when~ rendering/.try}
  \spath_tikz_path:Vn \l_tmpa_tl {knot #1}

  \endpgfscope
  \group_end:
}

\cs_generate_variant:Nn \knot_draw_crossing:nnn {nVV}

\cs_new_nopar:Npn \knot_draw_crossing:nn #1#2
{
  \tikz@scan@one@point\pgfutil@firstofone #2 \relax
  \knot_draw_crossing:nVV {#1} \pgf@x \pgf@y
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_split_strands:}
% This, and the following macros, are for splitting strands into filaments.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_split_strands:
{
  \int_gzero:N \l__knot_filaments_int
  \int_step_function:nnnN {1} {1} {\l__knot_strands_int} \knot_split_strand:n
  \int_step_function:nnnN {1} {1} {\l__knot_filaments_int} \knot_compute_nexts:n
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_compute_nexts:n}
% Each filament needs to know its predecessor and successor.
% We work out the predecessors as we go along, this fills in the successors.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_compute_nexts:n #1
{
  \tl_clear_new:c {knot next \tl_use:c {knot previous filament #1}}
  \tl_set:cn {knot next \tl_use:c {knot previous filament #1}} {filament #1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_split_strand:n}
% Sets up the split for a single strand.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_split_strand:n #1
{
  \int_set_eq:NN \l__knot_component_start_int \l__knot_filaments_int
  \int_incr:N \l__knot_component_start_int
  \tl_set_eq:Nc \l__knot_tmpa_tl {l__knot_options_strand #1}
  \spath_map_segments_function:nN {knot strand #1} \knot_save_filament:NN
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_save_filament:NN}
% Saves a filament as a new \Verb+spath+ object.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_save_filament:NN #1#2
{
  \tl_case:NnF #1
  {
    \g__spath_moveto_tl
    {
      \int_compare:nT {\l__knot_component_start_int < \l__knot_filaments_int}
      {
        \int_set_eq:NN \l__knot_component_start_int \l__knot_filaments_int
      }
    }
    \g__spath_lineto_tl
    {
      \int_gincr:N \l__knot_filaments_int
      \spath_clear_new:n {knot filament \int_use:N \l__knot_filaments_int}
      \spath_put:nnV {knot filament \int_use:N \l__knot_filaments_int} {path} #2
      \tl_set_eq:cN {l__knot_options_filament \int_use:N \l__knot_filaments_int} \l__knot_tmpa_tl

      \tl_clear_new:c {knot previous filament \int_use:N \l__knot_filaments_int}
      \int_compare:nF {\l__knot_component_start_int == \l__knot_filaments_int}
      {
        \tl_set:cx {knot previous filament \int_use:N \l__knot_filaments_int} {filament \int_eval:n {\l__knot_filaments_int - 1}}
      }
    }
    \g__spath_curvetoa_tl
    {
      \int_gincr:N \l__knot_filaments_int
      \spath_clear_new:n {knot filament \int_use:N \l__knot_filaments_int}
      \spath_put:nnV {knot filament \int_use:N \l__knot_filaments_int} {path} #2
      \tl_set_eq:cN {l__knot_options_filament \int_use:N \l__knot_filaments_int} \l__knot_tmpa_tl

      \tl_clear_new:c {knot previous filament \int_use:N \l__knot_filaments_int}
      \int_compare:nF {\l__knot_component_start_int == \l__knot_filaments_int}
      {
        \tl_set:cx {knot previous filament \int_use:N \l__knot_filaments_int} {filament \int_eval:n {\l__knot_filaments_int - 1}}
      }
    }
    \g__spath_closepath_tl
    {
      \int_gincr:N \l__knot_filaments_int
      \spath_clear_new:n {knot filament \int_use:N \l__knot_filaments_int}
      \tl_clear:N \l_tmpa_tl
      \tl_put_right:Nx {\tl_item:Nn #2 {1}\tl_item:Nn #2 {2}\tl_item:Nn #2 {3}}
      \tl_put_right:NV \l_tmpa_tl \g__spath_lineto_tl
      \tl_put_right:Nx {\tl_item:Nn #2 {5}\tl_item:Nn #2 {6}}

      \spath_put:nnV {knot filament \int_use:N \l__knot_filaments_int} {path} \l_tmpa_tl
      \tl_set_eq:cN {l__knot_options_filament \int_use:N \l__knot_filaments_int} \l__knot_tmpa_tl
      \tl_clear_new:c {knot previous filament \int_use:N \l__knot_filaments_int}
      \int_compare:nF {\l__knot_component_start_int == \l__knot_filaments_int}
      {
        \tl_set:cx {knot previous filament \int_use:N \l__knot_filaments_int} {filament \int_eval:n {\l__knot_filaments_int - 1}}
      }
      \tl_set:cx {knot previous filament \int_use:N \l__knot_component_start_int} {filament \int_use:N \l__knot_filaments_int}
    }
  }
  {
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\redraw}
% The user can redraw segments of the strands at specific locations.
%    \begin{macrocode}
\NewDocumentCommand \redraw { m m }
{
%  \tikz@scan@one@point\pgfutil@firstofone #2 \relax
  \tl_put_right:Nn \l__knot_redraws_tl {\knot_draw_crossing:nn}
  \tl_put_right:Nx \l__knot_redraws_tl {
    {strand #1} {#2}% {\dim_use:N \pgf@x} {\dim_use:N \pgf@y}
  }
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
%<@@=>
%
% \begin{macro}[internal]{\pgf@sh@@knotanchor}
% Add the extra anchors for the knot crossing nodes.
%    \begin{macrocode}
\def\pgf@sh@@knotanchor#1#2{%
  \anchor{#2 north west}{%
    \csname pgf@anchor@knot #1@north west\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 north east}{%
    \csname pgf@anchor@knot #1@north east\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 south west}{%
    \csname pgf@anchor@knot #1@south west\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 south east}{%
    \csname pgf@anchor@knot #1@south east\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 north}{%
    \csname pgf@anchor@knot #1@north\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 east}{%
    \csname pgf@anchor@knot #1@east\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 west}{%
    \csname pgf@anchor@knot #1@west\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 south}{%
    \csname pgf@anchor@knot #1@south\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{knot crossing}
%    \begin{macrocode}
\pgfdeclareshape{knot crossing}
{
  \inheritsavedanchors[from=circle] % this is nearly a circle
  \inheritanchorborder[from=circle]
  \inheritanchor[from=circle]{north}
  \inheritanchor[from=circle]{north west}
  \inheritanchor[from=circle]{north east}
  \inheritanchor[from=circle]{center}
  \inheritanchor[from=circle]{west}
  \inheritanchor[from=circle]{east}
  \inheritanchor[from=circle]{mid}
  \inheritanchor[from=circle]{mid west}
  \inheritanchor[from=circle]{mid east}
  \inheritanchor[from=circle]{base}
  \inheritanchor[from=circle]{base west}
  \inheritanchor[from=circle]{base east}
  \inheritanchor[from=circle]{south}
  \inheritanchor[from=circle]{south west}
  \inheritanchor[from=circle]{south east}
  \inheritanchorborder[from=circle]
  \pgf@sh@@knotanchor{crossing}{2}
  \pgf@sh@@knotanchor{crossing}{3}
  \pgf@sh@@knotanchor{crossing}{4}
  \pgf@sh@@knotanchor{crossing}{8}
  \pgf@sh@@knotanchor{crossing}{16}
  \pgf@sh@@knotanchor{crossing}{32}
  \backgroundpath{
    \pgfutil@tempdima=\radius%
    \pgfmathsetlength{\pgf@xb}{\pgfkeysvalueof{/pgf/outer xsep}}%  
    \pgfmathsetlength{\pgf@yb}{\pgfkeysvalueof{/pgf/outer ysep}}%  
    \ifdim\pgf@xb<\pgf@yb%
      \advance\pgfutil@tempdima by-\pgf@yb%
    \else%
      \advance\pgfutil@tempdima by-\pgf@xb%
    \fi%
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{knot over cross}
%    \begin{macrocode}
\pgfdeclareshape{knot over cross}
{
  \inheritsavedanchors[from=rectangle] % this is nearly a circle
  \inheritanchorborder[from=rectangle]
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{mid}
  \inheritanchor[from=rectangle]{mid west}
  \inheritanchor[from=rectangle]{mid east}
  \inheritanchor[from=rectangle]{base}
  \inheritanchor[from=rectangle]{base west}
  \inheritanchor[from=rectangle]{base east}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchorborder[from=rectangle]
  \backgroundpath{
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@yb}}
  }
  \foregroundpath{
% store lower right in xa/ya and upper right in xb/yb
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@ya}}
 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{knot under cross}
%    \begin{macrocode}
\pgfdeclareshape{knot under cross}
{
  \inheritsavedanchors[from=rectangle] % this is nearly a circle
  \inheritanchorborder[from=rectangle]
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{mid}
  \inheritanchor[from=rectangle]{mid west}
  \inheritanchor[from=rectangle]{mid east}
  \inheritanchor[from=rectangle]{base}
  \inheritanchor[from=rectangle]{base west}
  \inheritanchor[from=rectangle]{base east}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchorborder[from=rectangle]
  \backgroundpath{
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@ya}}
  }
  \foregroundpath{
% store lower right in xa/ya and upper right in xb/yb
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@yb}}
 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{knot vert}
%    \begin{macrocode}
\pgfdeclareshape{knot vert}
{
  \inheritsavedanchors[from=rectangle] % this is nearly a circle
  \inheritanchorborder[from=rectangle]
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{mid}
  \inheritanchor[from=rectangle]{mid west}
  \inheritanchor[from=rectangle]{mid east}
  \inheritanchor[from=rectangle]{base}
  \inheritanchor[from=rectangle]{base west}
  \inheritanchor[from=rectangle]{base east}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchorborder[from=rectangle]
  \backgroundpath{
% store lower right in xa/ya and upper right in xb/yb
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfqpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathmoveto{\pgfqpoint{\pgf@xb}{\pgf@yb}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@ya}}
 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{knot horiz}
%    \begin{macrocode}
\pgfdeclareshape{knot horiz}
{
  \inheritsavedanchors[from=rectangle] % this is nearly a circle
  \inheritanchorborder[from=rectangle]
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{mid}
  \inheritanchor[from=rectangle]{mid west}
  \inheritanchor[from=rectangle]{mid east}
  \inheritanchor[from=rectangle]{base}
  \inheritanchor[from=rectangle]{base west}
  \inheritanchor[from=rectangle]{base east}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchorborder[from=rectangle]
  \foregroundpath{
% store lower right in xa/ya and upper right in xb/yb
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@ya}}
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@yb}}
 }
}
%    \end{macrocode}
% \end{macro}
%
% \iffalse
%</knots>
% \fi
%\Finale
\endinput
