% \iffalse meta-comment
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
spath3 --- LaTeX3 functions for manipulating PGF soft paths
E-mail: loopspace@mathforge.org
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

This package defines some functions used to manipulate PGFs soft paths.
As applications of its use, included are a package for drawing calligraphic paths and a package for drawing knot diagrams.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input l3docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
spath3 --- Functions for manipulating PGF soft paths
E-mail: loopspace@mathforge.org
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2011-2019 by Andrew Stacey <loopspace@mathforge.org>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Andrew Stacey.

This work consists of the files  spath3.dtx
                                 calligraphy_doc.tex
                                 knots_doc.tex
and the derived files            spath3.ins,
                                 spath3_code.pdf,
                                 spath3.sty,
                                 tikzlibrarycalligraphy.code.tex
                                 tikzlibraryknots.code.tex
                                 tikzlibraryspath3.code.tex
                                 calligraphy.pdf
                                 knots.pdf
                                 README

\endpostamble
\usedir{tex/latex/spath3}
\generate{
  \file{spath3.sty}{\from{\jobname.dtx}{spath3}}
}
\generate{
  \file{tikzlibrarycalligraphy.code.tex}{\from{\jobname.dtx}{calligraphy}}
}
\generate{
  \file{tikzlibraryknots.code.tex}{\from{\jobname.dtx}{knots}}
}
\generate{
  \file{tikzlibraryspath3.code.tex}{\from{\jobname.dtx}{tikzspath3}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/spath3}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/demopkg}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
\documentclass[full]{l3doc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
%\usepackage{morefloats}
\usepackage{tikz}
\usepackage{trace}
\usepackage{spath3}
%\traceoff
%\usepackage[numbered]{hypdoc}
\definecolor{lstbgcolor}{rgb}{0.9,0.9,0.9} 
 
\usepackage{listings}
\lstloadlanguages{[LaTeX]TeX}
\lstset{
  breakatwhitespace=true,
  breaklines=true,
  language=[LaTeX]TeX,
  basicstyle=\small\ttfamily,
  keepspaces=true,
  columns=fullflexible
}
 
\usepackage{fancyvrb}

\newenvironment{example}
  {\VerbatimEnvironment
   \begin{VerbatimOut}[gobble=2]{example.out}}
  {\end{VerbatimOut}
   \begin{center}
%   \setlength{\parindent}{0pt}
   \fbox{\begin{minipage}{.9\linewidth}
     \lstinputlisting[]{example.out}
   \end{minipage}}
   \fbox{\begin{minipage}{.9\linewidth}
     \centering
     \input{example.out}
   \end{minipage}}
\end{center}
}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \CheckSum{6388}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{1.0}{2011/05/03}{Converted to DTX file}
% \changes{1.1}{2016/02/19}{Fixes due to changes in LaTeX3}
% \changes{1.2}{2019/02/12}{More fixes due to changes in LaTeX3}
% \changes{1.4}{2020/12/18}{A fair amount of code reimplementation and reorganisation, together with defining TikZ keys to make functions available for use.}
%
% \DoNotIndex{\newcommand,\newenvironment}
%
% \providecommand*{\url}{\texttt}
% \GetFileInfo{spath3.sty}
% \title{The \textsf{spath3} package: code}
% \author{Andrew Stacey \\ \url{loopspace@mathforge.org}}
% \date{\fileversion~from \filedate}
%
%
% \maketitle
%
% 
% \section{Introduction}
%
% The \Verb+spath3+ package is intended as a library for manipulating PGF's \emph{soft paths}.
% In between defining a path and using it, PGF stores a path as a \emph{soft path} where all the defining structure has been resolved into the basic operations but these have not yet been written to the output file.
% They can therefore still be manipulated by \TeX, and as they have a very rigid form (and limited vocabulary), they are relatively easy to modify.
% This package provides some methods for working with these paths.
% It was originally not really intended for use by end users but as a foundation on which other packages can be built.
% However, over the years I've found myself using it at ever higher levels and so a set of interfaces has been designed using TikZ keys.
%
% It also provides the engine that drives a few other packages, such as the  \Verb+calligraphy+, \Verb+knot+, and \Verb+penrose+ packages.
% The first two of these are subpackages of this one.
% The \Verb+calligraphy+ package simulates a calligraphic pen stroking a path.
% The \Verb+knots+ package can be used to draw knot (and similar) diagrams.
%
% For usage, see the documentation of the following packages (\Verb+texdoc <package>+):
%
% \begin{itemize}
% \item \Verb+calligraphy+
% \item \Verb+knots+
% \item \Verb+penrose+
% \item \Verb+spath3+ (\emph{this} document is the code, there's another which focusses on usage)
% \end{itemize}
%
% \section{Technical Details}
%
% The format of a soft path is a sequence of triples of the form \Verb+\macro {dimension}{dimension}+.
% The macro is one of a short list, the dimensions are coordinates in points.
% There are certain further restrictions, particularly that every path must begin with a \Verb+move to+, and B\'ezier curves consist of three triples.
%
% In the original implementation, I wrapped this token list in a \Verb+prop+ to store useful information along with the path.
% Over time, this additional structure has proved a little unwieldy and I've pared it back to working primarily with the original soft path as a token list.
% The \Verb+prop+ interface is preserved, for backwards compatibility, but now is primarily a wrapper around a more functional implementation.
%
% These are stored in a \LaTeX3 \Verb+prop+ along with potentially a slew of other information.
% This information is:
%
% \begin{itemize}
% \item The original soft path.
% \item A reversed copy of the path.
% \item The length, which is the number of actual triples in the path.
% \item The real length, which is the number of triples that actually draw something in the path.
% \item The number of components, which is the number of moves in the path.
% \item The initial point.
% \item The final point.
% \item The initial action, which is the first thing \emph{after} the initial move on the path.
% \item The final action.
% \item The lower left and upper right of the bounding box of the path.
% \end{itemize}
%
% The information isn't computed unless explicitly asked for to avoid unnecessary work.
% But the package tries to hide that requirement so that if you try to get a piece of information and it isn't already computed then it will be done and stored.
%
% A frequent use of this package is to break a path into pieces and do something with each of those pieces.
% To that end, there are various words that I use to describe the levels of the structure of a path.
%
% At the top level is the path itself.
% At the bottom level are the triples of the form \Verb+\macro{dim}{dim}+, as described above.
% In between these are the \emph{segments} and \emph{components}.
%
% A \emph{segment} is a minimal drawing piece.
% Thus it might be a straight line or a B\'ezier curve.
% When a path is broken into segments then each segment is a complete path so it isn't simply a selection of triples from the original path.
%
% A \emph{component} is a minimal connected section of the path.
% So every component starts with a move command and continues until the next move command.
% For ease of implementation (and to enable a copperplate pen in the calligraphy package!), an isolated move is considered as a component.
% Thus the following path consists of three components:
%
% \begin{Verbatim}
% \path (0,0) -- (1,0) (2,0) (3,0) to[out=0,in=90] (4,0);
% \end{Verbatim}
%
% \StopEventually{}
%
% \section{Implementation}
%
% \iffalse
%<*spath3>
% \fi
% \subsection{Initialisation}
%
%    \begin{macrocode}
%<@@=spath>
%    \end{macrocode}
%
% Load the \LaTeX3 foundation and register us as a \LaTeX3\ package.
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{expl3}
\RequirePackage{pgf}
\ProvidesExplPackage {spath3} {2020/12/18} {1.4} {Functions for
manipulating PGF soft paths}
\RequirePackage{xparse}
%    \end{macrocode}
%
% Utilities copied from https://github.com/loopspace/LaTeX3-Utilities
%    \begin{macrocode}
\cs_new_protected:Nn \@@_tl_put_right_braced:Nn
{
  \tl_put_right:Nn #1 { { #2 } }
}
\cs_generate_variant:Nn \@@_tl_put_right_braced:Nn { NV, cV, cv, Nx, cx }

\cs_new_protected:Nn \@@_tl_gput_right_braced:Nn
{
  \tl_gput_right:Nn #1 { { #2 } }
}
\cs_generate_variant:Nn \@@_tl_gput_right_braced:Nn { NV, cV, cv, Nx, cx }
\cs_new_protected:Nn \@@_tl_put_left_braced:Nn
{
  \tl_put_left:Nn #1 { { #2 } }
}
\cs_generate_variant:Nn \@@_tl_put_left_braced:Nn { NV, cV, cv, Nx, cx }

\cs_new_protected:Nn \@@_tl_gput_left_braced:Nn
{
  \tl_gput_left:Nn #1 { { #2 } }
}
\cs_generate_variant:Nn \@@_tl_gput_left_braced:Nn { NV, cV, cv, Nx, cx }
%    \end{macrocode}
%
% We need a slew of temporary variables.
%    \begin{macrocode}
\tl_new:N \l_@@_tmpa_tl
\tl_new:N \l_@@_tmpb_tl
\tl_new:N \l_@@_tmpc_tl
\tl_new:N \l_@@_tmpd_tl
\tl_new:N \l_@@_tmpe_tl

\seq_new:N \l_@@_tmpa_seq
\seq_new:N \l_@@_tmpb_seq
\seq_new:N \g_@@_tmpa_seq
\seq_new:N \g_@@_tmpb_seq

\tl_new:N \g_@@_smuggle_tl
\int_new:N \g_@@_smuggle_int
\seq_new:N \g_@@_smuggle_seq
\clist_new:N \g_@@_smuggle_clist

\dim_new:N \l_@@_tmpa_dim
\dim_new:N \l_@@_tmpb_dim
\dim_new:N \l_@@_move_x_dim
\dim_new:N \l_@@_move_y_dim
\fp_new:N \l_@@_tmpa_fp
\fp_new:N \l_@@_tmpb_fp
\int_new:N \l_@@_tmpa_int
\int_new:N \g_@@_map_int
\bool_new:N \l_@@_closed_bool
\clist_new:N \l_@@_tmpa_clist
%    \end{macrocode}
%
% We need to be able to compare against the macros that can occur in  a soft path so these token lists contain them.
% These are global constants so that they can be used in other packages.
%    \begin{macrocode}
\tl_new:N \c_spath_moveto_tl
\tl_new:N \c_spath_lineto_tl
\tl_new:N \c_spath_curveto_tl
\tl_new:N \c_spath_curvetoa_tl
\tl_new:N \c_spath_curvetob_tl
\tl_new:N \c_spath_closepath_tl
\tl_gset:Nn \c_spath_moveto_tl {\pgfsyssoftpath@movetotoken}
\tl_gset:Nn \c_spath_lineto_tl {\pgfsyssoftpath@linetotoken}
\tl_gset:Nn \c_spath_curveto_tl {\pgfsyssoftpath@curvetotoken}
\tl_gset:Nn \c_spath_curvetoa_tl {\pgfsyssoftpath@curvetosupportatoken}
\tl_gset:Nn \c_spath_curvetob_tl {\pgfsyssoftpath@curvetosupportbtoken}
\tl_gset:Nn \c_spath_closepath_tl {\pgfsyssoftpath@closepathtoken}
%    \end{macrocode}
%
%
% We will want to be able to use anonymous spaths internally, so we create a global counter that we can use to refer to them.
%    \begin{macrocode}
\int_new:N \g_@@_anon_int
\int_gzero:N \g_@@_anon_int
\tl_new:N \l_@@_anon_tl
%    \end{macrocode}
%
% Groups and iterations don't mix well and I haven't got a good scheme for protecting local calculations when iterating, so we do our best with iteration-specific variables.
%    \begin{macrocode}
\tl_new:N \l_@@_itera_tl
\tl_new:N \l_@@_iterb_tl
\tl_new:N \l_@@_iterc_tl
\tl_new:N \l_@@_iterd_tl
\tl_new:N \l_@@_iterp_tl
\tl_new:N \l_@@_iters_tl
\tl_new:N \l_@@_iterm_tl
\tl_new:N \l_@@_itere_tl
\dim_new:N \l_@@_itera_dim
\dim_new:N \l_@@_iterb_dim
\seq_new:N \l_@@_iter_seq
%    \end{macrocode}
%
% And some error messages
%    \begin{macrocode}
\msg_new:nnn { spath3 } { unknown path construction } { The~ path~ construction~ element~ #1~ is~ not~ currently~ supported.}
%    \end{macrocode}
%
%
% \subsection{Functional Implementation}
%
% In the functional approach, we start with a token list containing a soft path and do something to it (either calculate some information or manipulate it in some fashion).
% We then store that information, or the manipulated path, in an appropriate macro.
%
% \begin{macro}{\spath_segments_to_seq:Nn}
% Splits a soft path into \emph{segments}, storing the result in a sequence.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_segments_to_seq:Nn #1#2
{
  \group_begin:
  \tl_set:Nn \l_@@_itera_tl {#2}
  \tl_clear:N \l_@@_iterb_tl
  \seq_clear:N \l_@@_iter_seq
  \dim_zero:N \l_@@_itera_dim
  \dim_zero:N \l_@@_iterb_dim

  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_itera_tl
  }
  {
    \tl_set:Nx \l_@@_iterc_tl {\tl_head:N \l_@@_itera_tl}
    \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
    \tl_case:NnF \l_@@_iterc_tl
    {
      \c_spath_moveto_tl
      {
        \tl_set_eq:NN \l_@@_iterb_tl \c_spath_moveto_tl
        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_itera_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_iterb_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

        \tl_set:Nx \l_@@_iterd_tl {\tl_head:N \l_@@_itera_tl}
        \tl_if_eq:NNF \l_@@_iterd_tl \c_spath_moveto_tl
        {
          \tl_clear:N \l_@@_iterb_tl
        }

      }

      \c_spath_lineto_tl
      {
        \tl_set_eq:NN \l_@@_iterb_tl \c_spath_moveto_tl
        \tl_put_right:Nx \l_@@_iterb_tl
        {
          {\dim_use:N \l_@@_itera_dim}
          {\dim_use:N \l_@@_iterb_dim}
        }
        \tl_put_right:NV \l_@@_iterb_tl \c_spath_lineto_tl

        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_itera_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_iterb_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

      }

      \c_spath_curvetoa_tl
      {
        \tl_set_eq:NN \l_@@_iterb_tl \c_spath_moveto_tl
        \tl_put_right:Nx \l_@@_iterb_tl
        {
          {\dim_use:N \l_@@_itera_dim}
          {\dim_use:N \l_@@_iterb_dim}
        }
        \tl_put_right:NV \l_@@_iterb_tl \c_spath_curvetoa_tl

        \prg_replicate:nn {2} {
          \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
          \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
          \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N               \l_@@_itera_tl}}
          \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
          \tl_put_right:Nx \l_@@_iterb_tl {\tl_head:N             \l_@@_itera_tl}
          \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
        }

        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_itera_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_iterb_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

      }

      \c_spath_closepath_tl
      {
        \tl_set_eq:NN \l_@@_iterb_tl \c_spath_moveto_tl
        \tl_put_right:Nx \l_@@_iterb_tl
        {
          {\dim_use:N \l_@@_itera_dim}
          {\dim_use:N \l_@@_iterb_dim}
        }
        \tl_put_right:NV \l_@@_iterb_tl \c_spath_lineto_tl

        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_itera_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

        \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
        \dim_set:Nn \l_@@_iterb_dim {\tl_head:N \l_@@_itera_tl}
        \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

      }
      
    }    
    {

      \tl_set_eq:NN \l_@@_iterb_tl \l_@@_iterc_tl
      \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
      \dim_set:Nn \l_@@_itera_dim {\tl_head:N \l_@@_itera_tl}
      \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}

      \tl_put_right:Nx \l_@@_iterb_tl {{\tl_head:N \l_@@_itera_tl}}
      \dim_set:Nn \l_@@_iterb_dim {\tl_head:N \l_@@_itera_tl}
      \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
      
    }

    \tl_if_empty:NF \l_@@_iterb_tl
    {
      \seq_put_right:NV \l_@@_iter_seq \l_@@_iterb_tl
    }
    \tl_clear:N \l_@@_iterb_tl
  }

  \seq_gclear:N \g_@@_smuggle_seq
  \seq_gset_eq:NN \g_@@_smuggle_seq \l_@@_iter_seq
  \group_end:
  \seq_set_eq:NN #1 \g_@@_smuggle_seq
  \seq_gclear:N \g_@@_smuggle_seq
}
\cs_generate_variant:Nn \spath_segments_to_seq:Nn {NV, cn, cV, Nv, cv}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_components_to_seq:Nn}
% Splits a soft path into \emph{components}, storing the result in a sequence.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_components_to_seq:Nn #1#2
{
  \group_begin:
  \tl_set:Nn \l_@@_itera_tl {#2}
  \seq_clear:N \l_@@_iter_seq
  \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
  \tl_put_right:NV \l_@@_itera_tl \c_spath_moveto_tl
  \tl_set_eq:NN \l_@@_iterb_tl \c_spath_moveto_tl
  \bool_do_until:nn {
    \tl_if_empty_p:N \l_@@_itera_tl
  }
  {
    \tl_set:Nx \l_@@_iterc_tl {\tl_head:N \l_@@_itera_tl}
    \tl_if_eq:NNT \l_@@_iterc_tl \c_spath_moveto_tl
    {
      \seq_put_right:NV \l_@@_iter_seq \l_@@_iterb_tl
      \tl_clear:N \l_@@_iterb_tl
    }
    \tl_if_single:NTF \l_@@_iterc_tl
    {
      \tl_put_right:NV \l_@@_iterb_tl \l_@@_iterc_tl
    }
    {
      \tl_put_right:Nx \l_@@_iterb_tl {{\l_@@_iterc_tl}}
    }
    \tl_set:Nx \l_@@_itera_tl {\tl_tail:N \l_@@_itera_tl}
  }

  \seq_gclear:N \g_@@_smuggle_seq
  \seq_gset_eq:NN \g_@@_smuggle_seq \l_@@_iter_seq
  \group_end:
  \seq_clear_new:N #1
  \seq_set_eq:NN #1 \g_@@_smuggle_seq
  \seq_gclear:N \g_@@_smuggle_seq
}
\cs_generate_variant:Nn \spath_components_to_seq:Nn {NV, cn, cV, cv, Nv}
\cs_new_protected_nopar:Npn \spath_components_to_clist:Nn #1#2
{
  \group_begin:
  \spath_components_to_seq:Nn \l_@@_tmpa_seq {#2}
  \clist_gset_from_seq:NN \g_@@_smuggle_clist \l_@@_tmpa_seq
  \group_end:
  \clist_set_eq:NN #1 \g_@@_smuggle_clist
  \clist_gclear:N \g_@@_smuggle_clist
}
\cs_generate_variant:Nn \spath_components_to_clist:Nn {NV, cn, cV, cv, Nv}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[internal]{\spath_length:n}
% Counts the number of triples in the path.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_length:n #1
{
  \int_eval:n {\tl_count:n {#1} / 3}
}
\cs_generate_variant:Nn \spath_length:n {V}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_reallength:Nn}
% The real length of a path is the number of triples that actually draw something (that is, the number of lines, curves, and closepaths).
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_reallength:Nn #1#2
{
  \group_begin:
  \int_set:Nn \l_@@_tmpa_int {0}
  \tl_map_inline:nn {#2} {
    \tl_set:Nn \l_@@_tmpc_tl {##1}
    \tl_case:NnT \l_@@_tmpc_tl
    {
      \c_spath_lineto_tl {}
      \c_spath_curveto_tl {}
      \c_spath_closepath_tl {}
    }
    {
      \int_incr:N \l_@@_tmpa_int
    }
  }
  \int_gzero:N \g_@@_smuggle_int
  \int_gset_eq:NN \g_@@_smuggle_int \l_@@_tmpa_int
  \group_end:
  \int_set_eq:NN #1 \g_@@_smuggle_int
  \int_gzero:N \g_@@_smuggle_int
}
\cs_generate_variant:Nn \spath_reallength:Nn {NV, cn, cV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_numberofcomponents:Nn}
% A component is a continuous segment of the path, separated by moves.
% Successive moves are not collapsed, and zero length moves count.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_numberofcomponents:Nn #1#2
{
  \group_begin:
  \int_set:Nn \l_@@_tmpa_int {0}
  \tl_map_inline:nn {#1} {
    \tl_set:Nn \l_@@_tmpa_tl {##1}
    \tl_case:Nn \l_@@_tmpa_tl
    {
      \c_spath_moveto_tl
      {
        \int_incr:N \l_@@_tmpa_int
      }
    }
  }
  \int_gzero:N \g_@@_smuggle_int
  \int_gset_eq:NN \g_@@_smuggle_int \l_@@_tmpa_int
  \group_end:
  \int_set_eq:NN #2 \g_@@_smuggle_int
  \int_gzero:N \g_@@_smuggle_int
}
\cs_generate_variant:Nn \spath_numberofcomponents:Nn {NV, cn, cV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_initialpoint:Nn}
% The starting point of the path.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_initialpoint:Nn #1#2
{
  \group_begin:
  \tl_clear:N \l_@@_tmpb_tl
  \tl_set:Nx \l_@@_tmpb_tl
  {
    { \tl_item:nn {#2} {2} }
    { \tl_item:nn {#2} {3} }
  }
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_initialpoint:Nn {NV, cn, cV, Nv}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_finalpoint:Nn}
% The final point of the path.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_finalpoint:Nn #1#2
{
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#2}
  \tl_reverse:N \l_@@_tmpa_tl
  \tl_clear:N \l_@@_tmpb_tl
  \tl_set:Nx \l_@@_tmpb_tl
  {
    { \tl_item:Nn \l_@@_tmpa_tl {2} }
    { \tl_item:Nn \l_@@_tmpa_tl {1} }
  }
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_finalpoint:Nn {NV, cn, cV, Nv}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_reverse:Nn}
% This computes the reverse of the path.
% TODO: handle closed paths, possibly rectangles.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_reverse:Nn #1#2
{
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#2}

  \tl_clear:N \l_@@_tmpb_tl
  \tl_clear:N \l_@@_tmpd_tl
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  
  \tl_put_left:Nx \l_@@_tmpb_tl
  {
    {\dim_use:N \l_@@_tmpa_dim}
    {\dim_use:N \l_@@_tmpb_dim}
  }
  
  \bool_set_false:N \l_@@_closed_bool
  
  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_tmpa_tl
  }
  {
    \tl_set:Nx \l_@@_tmpc_tl {\tl_head:N \l_@@_tmpa_tl}

    \tl_case:NnTF \l_@@_tmpc_tl
    {
      \c_spath_moveto_tl {
        
        \bool_if:NT \l_@@_closed_bool
        {
          \tl_put_right:NV \l_@@_tmpd_tl \c_spath_closepath_tl
          \tl_set:Nx \l_@@_tmpe_tl {\tl_tail:N \l_@@_tmpd_tl}
          \tl_put_right:Nx \l_@@_tmpd_tl
          {
            { \tl_head:N \l_@@_tmpd_tl }
            { \tl_head:N \l_@@_tmpe_tl }
          }
        }
        \bool_set_false:N \l_@@_closed_bool
        \tl_put_left:NV \l_@@_tmpd_tl \c_spath_moveto_tl
        \tl_put_left:NV \l_@@_tmpb_tl \l_@@_tmpd_tl
        \tl_clear:N \l_@@_tmpd_tl
      }
      \c_spath_lineto_tl {
        \tl_put_left:NV \l_@@_tmpd_tl \c_spath_lineto_tl
      }
      \c_spath_curveto_tl {
        \tl_put_left:NV \l_@@_tmpd_tl \c_spath_curvetoa_tl
      }
      \c_spath_curvetoa_tl {
        \tl_put_left:NV \l_@@_tmpd_tl \c_spath_curveto_tl
      }
      \c_spath_curvetob_tl {
        \tl_put_left:NV \l_@@_tmpd_tl \c_spath_curvetob_tl
      }
    }
    {
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

      \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

      \tl_put_left:Nx \l_@@_tmpd_tl
      {
        {\dim_use:N \l_@@_tmpa_dim}
        {\dim_use:N \l_@@_tmpb_dim}
      }

    }
    {
      \tl_if_eq:NNTF \l_@@_tmpc_tl \c_spath_closepath_tl
      {
        \bool_set_true:N \l_@@_closed_bool
      }
      {
        \msg_warning:nnx { spath3 } { unknown path construction } {\l_@@_tmpc_tl }
      }

      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

    }
  }

  \bool_if:NT \l_@@_closed_bool
  {
    \tl_put_right:NV \l_@@_tmpd_tl \c_spath_closepath_tl
    \tl_set:Nx \l_@@_tmpe_tl {\tl_tail:N \l_@@_tmpd_tl}
    \tl_put_right:Nx \l_@@_tmpd_tl
    {
      { \tl_head:N \l_@@_tmpd_tl }
      { \tl_head:N \l_@@_tmpe_tl }
    }
  }

  \bool_set_false:N \l_@@_closed_bool
  \tl_put_left:NV \l_@@_tmpd_tl \c_spath_moveto_tl
  \tl_put_left:NV \l_@@_tmpb_tl \l_@@_tmpd_tl

  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_reverse:Nn {NV, cn, cV, Nv}
\cs_new_protected_nopar:Npn \spath_reverse:N #1
{
  \spath_reverse:NV #1#1
}
\cs_generate_variant:Nn \spath_reverse:N {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_initialaction:NN}
% This is the first thing that the path does (after the initial move).
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_initialaction:Nn #1#2
{
  \group_begin:
  \tl_clear:N \l_@@_tmpa_tl
  \int_compare:nT
  {
    \tl_count:n {#2} > 3
  }
  {
    \tl_set:Nx \l_@@_tmpa_tl
    {
      \tl_item:Nn {#2} {4}
    }
  }
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_initialaction:Nn {NV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_finalaction:Nn}
% This is the last thing that the path does.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_finalaction:Nn #1#2
{
  \group_begin:
  \tl_clear:N \l_@@_tmpb_tl
  \int_compare:nT
  {
    \tl_count:n {#2} > 3
  }
  {
    \tl_set:Nn \l_@@_tmpa_tl {#2}
    \tl_reverse:N \l_@@_tmpa_tl
    \tl_set:Nx \l_@@_tmpb_tl
    {
      \tl_item:Nn \l_@@_tmpa_tl {3}
    }
    \tl_if_eq:NNT \l_@@_tmpb_tl \c_spath_curvetoa_tl
    {
      \tl_set_eq:NN \l_@@_tmpb_tl \c_spath_curveto_tl
    }
  }
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_minbb:Nn}
% This computes the minimum (bottom left) of the bounding box of the path.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_minbb:Nn #1#2
{
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#2}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_tmpa_tl
  }
  {
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    \dim_set:Nn \l_@@_tmpa_dim {\dim_min:nn {\tl_head:N \l_@@_tmpa_tl} {\l_@@_tmpa_dim}}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    \dim_set:Nn \l_@@_tmpb_dim {\dim_min:nn {\tl_head:N \l_@@_tmpa_tl} {\l_@@_tmpb_dim}}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  }
  \tl_clear:N \l_@@_tmpb_tl
  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_use:N \l_@@_tmpa_dim}
    {\dim_use:N \l_@@_tmpb_dim}
  }
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_minbb:Nn {NV, cn, cV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_maxbb:Nn}
% This computes the maximum (top right) of the bounding box of the path.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_maxbb:Nn #1#2
{
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#2}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
  \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_tmpa_tl
  }
  {
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    \dim_set:Nn \l_@@_tmpa_dim {\dim_max:nn {\tl_head:N \l_@@_tmpa_tl} {\l_@@_tmpa_dim}}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    \dim_set:Nn \l_@@_tmpb_dim {\dim_max:nn {\tl_head:N \l_@@_tmpa_tl} {\l_@@_tmpb_dim}}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
  }
  \tl_clear:N \l_@@_tmpb_tl
  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_use:N \l_@@_tmpa_dim}
    {\dim_use:N \l_@@_tmpb_dim}
  }
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_maxbb:Nn {NV, cn, cV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_save_to_aux:Nn}
%    \begin{macrocode}
\int_set:Nn \l_tmpa_int {\char_value_catcode:n {`@}}
\char_set_catcode_letter:N @
\cs_new_protected_nopar:Npn \spath_save_to_aux:Nn #1#2 {
  \tl_if_empty:nF {#2}
  {
    \tl_clear:N \l_@@_tmpa_tl
    \tl_put_right:Nn \l_@@_tmpa_tl {
      \ExplSyntaxOn
      \tl_clear:N #1
      \tl_set:Nn #1 {#2}
      \ExplSyntaxOff
    }
    \protected@write\@auxout{}{
      \tl_to_str:N \l_@@_tmpa_tl
    }
  }
}
\char_set_catcode:nn {`@} {\l_tmpa_int}
\cs_generate_variant:Nn \spath_save_to_aux:Nn {cn, cV, NV}
\cs_new_protected_nopar:Npn \spath_save_to_aux:N #1
{
  \tl_if_exist:NT #1
  {
    \spath_save_to_aux:NV #1#1
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Path Manipulation}
%
% \begin{macro}[internal]{\spath_translate:Nnnn}
% Translates a path.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_translate:Nnnn #1#2#3#4
{
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#2}
  \tl_clear:N \l_@@_tmpb_tl
  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_tmpa_tl
  }
  {
    \tl_put_right:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    
    \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl + #3}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

    \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl + #4}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

    \tl_put_right:Nx \l_@@_tmpb_tl
    {
      {\dim_use:N \l_@@_tmpa_dim}
      {\dim_use:N \l_@@_tmpb_dim}
    }
  }
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_translate:Nnnn {NVxx, NVVV, NVnn}
\cs_new_protected_nopar:Npn \spath_translate:Nnn #1#2#3
{
  \spath_translate:NVnn #1#1{#2}{#3}
}
\cs_generate_variant:Nn \spath_translate:Nnn {NVV, cnn, cVV}
%    \end{macrocode}
%
% This variant allows for passing the coordinates as a single braced group as it strips off the outer braces of the second argument.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_translate:Nn #1#2
{
  \spath_translate:Nnn #1 #2
}
\cs_generate_variant:Nn \spath_translate:Nn {NV}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[internal]{\spath_scale:Nnnn}
% Scale a path.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_scale:Nnnn #1#2#3#4
{
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#2}
  \tl_clear:N \l_@@_tmpb_tl
  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_tmpa_tl
  }
  {
    \tl_put_right:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        
    \fp_set:Nn \l_@@_tmpa_fp {\tl_head:N \l_@@_tmpa_tl * #3}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

    \fp_set:Nn \l_@@_tmpb_fp {\tl_head:N \l_@@_tmpa_tl * #4}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

    \tl_put_right:Nx \l_@@_tmpb_tl
    {
      {\fp_to_dim:N \l_@@_tmpa_fp}
      {\fp_to_dim:N \l_@@_tmpb_fp}
    }
  }
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_scale:Nnnn {NVnn, Nnxx}
\cs_new_protected_nopar:Npn \spath_scale:Nnn #1#2#3
{
  \spath_scale:NVnn #1#1{#2}{#3}
}
\cs_generate_variant:Nn \spath_scale:Nnn {cnn, cVV, NVV}
%    \end{macrocode}
%
% This variant allows for passing the coordinates as a single braced group as it strips off the outer braces of the second argument.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_scale:Nn #1#2
{
  \spath_scale:Nnn #1 #2
}

\cs_generate_variant:Nn \spath_scale:Nn {NV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_transform:Nnnnnnnn}
% Applies an affine (matrix and vector) transformation to path.
% The matrix is specified in rows first.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_transform:Nnnnnnnn #1#2#3#4#5#6#7#8
{
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#2}
  \tl_clear:N \l_@@_tmpb_tl
  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_tmpa_tl
  }
  {
    \tl_put_right:Nx \l_@@_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    \tl_set:Nx \l_tmpa_tl {\tl_head:N \l_@@_tmpa_tl}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
    \tl_set:Nx \l_tmpb_tl {\tl_head:N \l_@@_tmpa_tl}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

    \fp_set:Nn \l_@@_tmpa_fp {\l_tmpa_tl * #3 + \l_tmpb_tl * #5 + #7}
    \fp_set:Nn \l_@@_tmpb_fp {\l_tmpa_tl * #4 + \l_tmpb_tl * #6 + #8}
    \tl_put_right:Nx \l_@@_tmpb_tl
    {
      {\fp_to_dim:N \l_@@_tmpa_fp}
      {\fp_to_dim:N \l_@@_tmpb_fp}
    }
  }

  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}

\cs_generate_variant:Nn \spath_transform:Nnnnnnnn {NVnnnnnn, Nnxxxxxx, cnnnnnnn}
\cs_new_protected_nopar:Npn \spath_transform:Nnnnnnn #1#2#3#4#5#6#7
{
  \spath_transform:NVnnnnnn #1#1{#2}{#3}{#4}{#5}{#6}{#7}
}
\cs_generate_variant:Nn \spath_transform:Nnnnnnn {cnnnnnn}
\cs_new_protected_nopar:Npn \spath_transform:Nnn #1#2#3
{
  \spath_transform:Nnnnnnnn #1{#2}#3
}
\cs_generate_variant:Nn \spath_transform:Nnn {cnn, cVn, NVn, NnV}
\cs_new_protected_nopar:Npn \spath_transform:Nn #1#2
{
  \spath_transform:NVnnnnnn #1#1#2
}
\cs_generate_variant:Nn \spath_transform:Nn {cn, cV, NV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_weld:Nnn}
% This welds one path to another, moving the second so that its initial point coincides with the first's final point.
% It is called a \emph{weld} because the initial move of the second path is removed.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_weld:Nnn #1#2#3
{
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#2}
  \tl_set:Nn \l_@@_tmpb_tl {#3}

  \spath_finalpoint:NV \l_@@_tmpc_tl \l_@@_tmpa_tl
  \spath_initialpoint:NV \l_@@_tmpd_tl \l_@@_tmpb_tl

  \dim_set:Nn \l_@@_tmpa_dim
  {
    \tl_item:Nn \l_@@_tmpc_tl {1}
    -
    \tl_item:Nn \l_@@_tmpd_tl {1}
  }
  \dim_set:Nn \l_@@_tmpb_dim
  {
    \tl_item:Nn \l_@@_tmpc_tl {2}
    -
    \tl_item:Nn \l_@@_tmpd_tl {2}
  }

  \spath_translate:NVV \l_@@_tmpb_tl \l_@@_tmpa_dim \l_@@_tmpb_dim

  \prg_replicate:nn {3}
  {
    \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
  }

  \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_weld:Nnn {NVV}
\cs_new_protected_nopar:Npn \spath_weld:Nn #1#2
{
  \spath_weld:NVV #1#1{#2}
}
\cs_generate_variant:Nn \spath_weld:Nn {NV, Nv, cV, cv}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[internal]{\spath_append_no_move:Nnn}
% Append the path from the second \Verb+spath+ to the first, removing
% the adjoining move.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_append_no_move:Nnn #1#2#3
{
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#2}
  \tl_set:Nn \l_@@_tmpb_tl {#3}
  \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
  \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
  \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
  
  \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_append_no_move:Nnn {NVV, NVn}
\cs_new_protected_nopar:Npn \spath_append_no_move:Nn #1#2
{
  \spath_append_no_move:NVn #1#1{#2}
}
\cs_generate_variant:Nn \spath_append_no_move:Nn {NV, cv}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_append:Nnn}
% Prepend the path from the second \Verb+spath+ to the first.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_append:Nnn #1#2#3
{
  \tl_set:Nn #1 {#2}
  \tl_put_right:Nn #1 {#3}
}
\cs_generate_variant:Nn \spath_append:Nnn {NVV, NVn}
\cs_new_protected_nopar:Npn \spath_append:Nn #1#2
{
  \spath_append:NVn #1#1{#2}
}
\cs_generate_variant:Nn \spath_append:Nn {NV, Nv}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[internal]{\spath_prepend_no_move:Nnn}
% Prepend the path from the second \Verb+spath+ to the first, removing
% the adjoining move.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_prepend_no_move:Nnn #1#2#3
{
  \spath_append_no_move:Nnn #1{#3}{#2}
}
\cs_generate_variant:Nn \spath_prepend_no_move:Nnn {NVV, NVn}
\cs_new_protected_nopar:Npn \spath_prepend_no_move:Nn #1#2
{
  \spath_prepend_no_move:NVn #1#1{#2}
}
\cs_generate_variant:Nn \spath_prepend_no_move:Nn {NV, cv}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_prepend:Nnn}
% Prepend the path from the second \Verb+spath+ to the first.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_prepend:Nnn #1#2#3
{
  \spath_append:Nnn #1{#3}{#2}
}
\cs_generate_variant:Nn \spath_prepend:Nnn {NVV, NVn}
\cs_new_protected_nopar:Npn \spath_prepend:Nn #1#2
{
  \spath_prepend:NVn #1#1{#2}
}
\cs_generate_variant:Nn \spath_prepend:Nn {NV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_bake_round:Nn}
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_bake_round:Nn #1#2
{
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#2}
  \pgf@@@@processround \l_@@_tmpa_tl\l_@@_tmpb_tl
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_bake_round:Nn {NV}
\cs_new_protected_nopar:Npn \spath_bake_round:N #1
{
  \spath_bake_round:NV #1#1
}
\cs_generate_variant:Nn \spath_bake_round:N {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_close:Nn}
% Appends a close path to the end of the path.
% For now, the point is the initial or final point (respectively).
% To be future proof, it ought to be the point of the adjacent move to.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_close:Nn #1#2
{
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#2}
  \spath_initialpoint:NV \l_@@_tmpb_tl \l_@@_tmpa_tl
  \tl_put_right:NV \l_@@_tmpa_tl \c_spath_closepath_tl
  \tl_put_right:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_close:Nn {NV}
\cs_new_protected_nopar:Npn \spath_close:N #1
{
  \spath_close:NV #1#1
}
\cs_generate_variant:Nn \spath_close:N {c}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[internal]{\spath_open:Nn}
% Removes all close paths from the path, replacing them by \Verb+lineto+ if they move any distance.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_open:Nn #1#2
{
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#2}
  \tl_clear:N \l_@@_tmpb_tl
  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_tmpa_tl
  }
  {
    \tl_set:Nx \l_@@_tmpc_tl {\tl_head:N \l_@@_tmpa_tl}
    \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

    \tl_case:NnF \l_@@_tmpc_tl
    {
      \c_spath_closepath_tl {

        \bool_if:nF
        {
          \dim_compare_p:n
          {
            \l_@@_move_x_dim == \l_@@_tmpa_dim
          }
          &&
          \dim_compare_p:n
          {
            \l_@@_move_y_dim == \l_@@_tmpb_dim
          }
        }
        {
          \tl_put_right:NV \l_@@_tmpb_tl \c_spath_lineto_tl
        
          \tl_put_right:Nx \l_@@_tmpb_tl {
            { \dim_use:N \l_@@_move_x_dim }
            { \dim_use:N \l_@@_move_y_dim }
          }
        }
        
        \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      }

      \c_spath_moveto_tl {
        \tl_put_right:NV \l_@@_tmpb_tl \l_@@_tmpc_tl
        
        \dim_set:Nn \l_@@_move_x_dim {\tl_head:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        \dim_set:Nn \l_@@_move_y_dim {\tl_head:N \l_@@_tmpa_tl}
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

        \tl_put_right:Nx \l_@@_tmpb_tl {
          { \dim_use:N \l_@@_move_x_dim }
          { \dim_use:N \l_@@_move_y_dim }
        }

        \dim_set_eq:NN \l_@@_tmpa_dim \l_@@_move_x_dim
        \dim_set_eq:NN \l_@@_tmpb_dim \l_@@_move_y_dim
      }
    }
    {
      \tl_put_right:NV \l_@@_tmpb_tl \l_@@_tmpc_tl
      
      \dim_set:Nn \l_@@_tmpa_dim {\tl_head:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      \dim_set:Nn \l_@@_tmpb_dim {\tl_head:N \l_@@_tmpa_tl}
      \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}

      \tl_put_right:Nx \l_@@_tmpb_tl {
        { \dim_use:N \l_@@_tmpa_dim }
        { \dim_use:N \l_@@_tmpb_dim }
      }
    }
  }
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpb_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_open:Nn {NV}
\cs_new_protected_nopar:Npn \spath_open:N #1
{
  \spath_open:NV #1#1
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_remove_empty_components:Nn #1#2}
% Remove any component that is simply a moveto
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_remove_empty_components:Nn #1#2
{
  \group_begin:
  \spath_components_to_seq:Nn \l_@@_tmpa_seq {#2}
  \tl_clear:N \l_@@_tmpa_tl
  \seq_map_inline:Nn \l_@@_tmpa_seq
  {
    \int_compare:nF
    {
      \tl_count:n {##1} == 3
    }
    {
      \tl_put_right:Nn \l_@@_tmpa_tl {##1}
    }
  }
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_remove_empty_components:Nn {NV}
\cs_new_protected_nopar:Npn \spath_remove_empty_components:N #1
{
  \spath_remove_empty_components:NV #1#1
}
\cs_generate_variant:Nn \spath_remove_empty_components:N {c}
%    \end{macrocode}
% \end{macro}

% \subsection{Splitting Commands}
%
% \begin{macro}[internal]{\spath_split_curve:NNnn}
% Splits a Bezier cubic into pieces, storing the pieces in the first two arguments.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_split_curve:NNnn #1#2#3#4
{
  \group_begin:
  \tl_set_eq:NN \l_@@_tmpa_tl \c_spath_moveto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl {
    {\tl_item:nn {#4} {2}}
    {\tl_item:nn {#4} {3}}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \c_spath_curvetoa_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
    {
      (1 - #3) * \tl_item:nn {#4} {2} + (#3) * \tl_item:nn {#4} {5}
    }}
    {\fp_to_dim:n
    {
      (1 - #3) * \tl_item:nn {#4} {3} + (#3) * \tl_item:nn {#4} {6}
    }}
  }

  \tl_put_right:NV \l_@@_tmpa_tl \c_spath_curvetob_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
    {
      (1 - #3)^2 * \tl_item:nn {#4} {2} + 2 * (1 - #3) * (#3) * \tl_item:nn {#4} {5} + (#3)^2 * \tl_item:nn {#4} {8}
    }}
    {\fp_to_dim:n
    {
      (1 - #3)^2 * \tl_item:nn {#4} {3} + 2 * (1 - #3) * (#3) * \tl_item:nn {#4} {6} + (#3)^2 * \tl_item:nn {#4} {9}
    }}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \c_spath_curveto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
      {
      (1 - #3)^3 * \tl_item:nn {#4} {2} + 3 * (1 - #3)^2 * (#3) * \tl_item:nn {#4} {5} + 3 * (1 - #3) * (#3)^2 * \tl_item:nn {#4} {8} + (#3)^3 * \tl_item:nn {#4} {11}
    }}
    {\fp_to_dim:n
    {
      (1 - #3)^3 * \tl_item:nn {#4} {3} + 3 * (1 - #3)^2 * (#3) * \tl_item:nn {#4} {6} + 3 * (1 - #3) * (#3)^2 * \tl_item:nn {#4} {9} + (#3)^3 * \tl_item:nn {#4} {12}
    }}
  }
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \group_begin:
  \tl_set_eq:NN \l_@@_tmpa_tl \c_spath_moveto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
      {
      (1 - #3)^3 * \tl_item:nn {#4} {2} + 3 * (1 - #3)^2 * (#3) * \tl_item:nn {#4} {5} + 3 * (1 - #3) * (#3)^2 * \tl_item:nn {#4} {8} + (#3)^3 * \tl_item:nn {#4} {11}
    }}
    {\fp_to_dim:n
    {
      (1 - #3)^3 * \tl_item:nn {#4} {3} + 3 * (1 - #3)^2 * (#3) * \tl_item:nn {#4} {6} + 3 * (1 - #3) * (#3)^2 * \tl_item:nn {#4} {9} + (#3)^3 * \tl_item:nn {#4} {12}
    }}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \c_spath_curvetoa_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
    {
      (1 - #3)^2 * \tl_item:nn {#4} {5} + 2 * (1 - #3) * (#3) * \tl_item:nn {#4} {8} + (#3)^2 * \tl_item:nn {#4} {11}
    }}
    {\fp_to_dim:n
    {
      (1 - #3)^2 * \tl_item:nn {#4} {6} + 2 * (1 - #3) * (#3) * \tl_item:nn {#4} {9} + (#3)^2 * \tl_item:nn {#4} {12}
    }}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \c_spath_curvetob_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
    {
      (1 - #3) * \tl_item:nn {#4} {8} + (#3) * \tl_item:nn {#4} {11}
    }}
    {\fp_to_dim:n
    {
      (1 - #3) * \tl_item:nn {#4} {9} + (#3) * \tl_item:nn {#4} {12}
    }}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \c_spath_curveto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl {
    {\tl_item:nn {#4} {11}}
    {\tl_item:nn {#4} {12}}
  }
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #2 \g_@@_smuggle_tl
}

\cs_generate_variant:Nn \spath_split_curve:NNnn {NNnV, NNVn, NNVV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_split_line:NNnn}
% Splits a line segment.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_split_line:NNnn #1#2#3#4
{
  \group_begin:
  \tl_set_eq:NN \l_@@_tmpa_tl \c_spath_moveto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl {
    {\tl_item:nn {#4} {2}}
    {\tl_item:nn {#4} {3}}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \c_spath_lineto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
    {
      (1 - #3) * \tl_item:nn {#4} {2} + (#3) * \tl_item:nn {#4} {5}
    }}
    {\fp_to_dim:n
    {
      (1 - #3) * \tl_item:nn {#4} {3} + (#3) * \tl_item:nn {#4} {6}
    }}
  }
  \tl_gclear:N \g_@@_smuggle_tl
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \group_begin:
  \tl_set_eq:NN \l_@@_tmpa_tl \c_spath_moveto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    {\fp_to_dim:n
    {
      (1 - #3) * \tl_item:nn {#4} {2} + (#3) * \tl_item:nn {#4} {5}
    }}
    {\fp_to_dim:n
    {
      (1 - #3) * \tl_item:nn {#4} {3} + (#3) * \tl_item:nn {#4} {6}
    }}
  }
  \tl_put_right:NV \l_@@_tmpa_tl \c_spath_lineto_tl
  \tl_put_right:Nx \l_@@_tmpa_tl {
    {\tl_item:nn {#4} {5}}
    {\tl_item:nn {#4} {6}}
  }
  \tl_gclear:N \g_@@_smuggle_tl
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #2 \g_@@_smuggle_tl
}

\cs_generate_variant:Nn \spath_split_line:NNnn {NNnV, NNVn, NNVV}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\int_new:N \l_@@_split_int
\int_new:N \l_@@_splitat_int
\fp_new:N \l_@@_split_fp
\bool_new:N \l_@@_split_bool
\tl_new:N \l_@@_split_path_tl
\tl_new:N \l_@@_split_patha_tl
\tl_new:N \l_@@_split_pathb_tl
\tl_new:N \l_@@_split_intoa_tl
\tl_new:N \l_@@_split_intob_tl
\dim_new:N \l_@@_splitx_dim
\dim_new:N \l_@@_splity_dim
%    \end{macrocode}
%
% \begin{macro}[internal]{\spath_split_at:NNnn}
% Split a path according to the parameter generated by the intersection routine.
% Arguments:
% 1. Macro to hold initial segment
% 2. Macro to hold final segment
% 3. Path to split
% 4. Position to split at
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_split_at:NNnn #1#2#3#4
{
  \group_begin:
  \int_set:Nn \l_@@_splitat_int {\fp_to_int:n {floor(#4) + 1}}
  \fp_set:Nn \l_@@_split_fp {#4 - floor(#4)}

  % Is split point near one end or other of a component?
  \fp_compare:nT
  {
    \l_@@_split_fp < 0.01
  }
  {
    % Near the start, so we'll place it at the start
    \fp_set:Nn \l_@@_split_fp {0}
  }
  \fp_compare:nT
  {
    \l_@@_split_fp > 0.99
  }
  {
    % Near the end, so we'll place it at the end
    \fp_set:Nn \l_@@_split_fp {0}
    \int_incr:N \l_@@_splitat_int
  }
  
  \int_zero:N \l_@@_split_int
  \bool_set_true:N \l_@@_split_bool

  \tl_set:Nn \l_@@_split_path_tl {#3}
  \tl_clear:N \l_@@_split_patha_tl

  \dim_zero:N \l_@@_splitx_dim
  \dim_zero:N \l_@@_splity_dim

  \bool_until_do:nn {
    \tl_if_empty_p:N \l_@@_split_path_tl
    ||
    \int_compare_p:n { \l_@@_splitat_int == \l_@@_split_int  }
  }
  {
    \tl_set:Nx \l_@@_tmpc_tl {\tl_head:N \l_@@_split_path_tl}
    \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
    \tl_case:Nn \l_@@_tmpc_tl
    {
      \c_spath_lineto_tl
      {
        \int_incr:N \l_@@_split_int
      }
      \c_spath_curvetoa_tl
      {
        \int_incr:N \l_@@_split_int
      }
    }
    \int_compare:nT { \l_@@_split_int < \l_@@_splitat_int  }
    {
      \tl_put_right:NV \l_@@_split_patha_tl \l_@@_tmpc_tl
      
      \tl_put_right:Nx \l_@@_split_patha_tl
      {{ \tl_head:N \l_@@_split_path_tl }}
      \dim_set:Nn \l_@@_splitx_dim {\tl_head:N \l_@@_split_path_tl}
      \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      
      \tl_put_right:Nx \l_@@_split_patha_tl
      {{ \tl_head:N \l_@@_split_path_tl }}
      \dim_set:Nn \l_@@_splity_dim {\tl_head:N \l_@@_split_path_tl}
      \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      
    }
  }

  \tl_clear:N \l_@@_split_pathb_tl
  \tl_put_right:NV \l_@@_split_pathb_tl \c_spath_moveto_tl
  \tl_put_right:Nx \l_@@_split_pathb_tl
  {
    {\dim_use:N \l_@@_splitx_dim}
    {\dim_use:N \l_@@_splity_dim}
  }

  \fp_compare:nTF
  {
    \l_@@_split_fp == 0
  }
  {
    \tl_set_eq:NN \l_@@_split_intob_tl \l_@@_split_pathb_tl
    \tl_if_empty:NF \l_@@_split_path_tl
    {
      \tl_put_right:NV \l_@@_split_intob_tl \l_@@_tmpc_tl
      \tl_put_right:NV \l_@@_split_intob_tl \l_@@_split_path_tl
    }
  }
  {

    \tl_case:Nn \l_@@_tmpc_tl
    {
      \c_spath_lineto_tl
      {
        \tl_put_right:NV \l_@@_split_pathb_tl \l_@@_tmpc_tl
        \tl_put_right:Nx \l_@@_split_pathb_tl
        {{ \tl_head:N \l_@@_split_path_tl }}
        \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      
        \tl_put_right:Nx \l_@@_split_pathb_tl
        {{ \tl_head:N \l_@@_split_path_tl }}
        \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }

        \spath_split_line:NNVV
        \l_@@_split_intoa_tl
        \l_@@_split_intob_tl
        \l_@@_split_fp \l_@@_split_pathb_tl

        \prg_replicate:nn {3} {
          \tl_set:Nx \l_@@_split_intoa_tl {\tl_tail:N \l_@@_split_intoa_tl}
        }

        \tl_put_right:NV \l_@@_split_patha_tl \l_@@_split_intoa_tl
        \tl_put_right:NV \l_@@_split_intob_tl \l_@@_split_path_tl
      }
      \c_spath_curvetoa_tl
      {
        \tl_put_right:NV \l_@@_split_pathb_tl \l_@@_tmpc_tl
        \tl_put_right:Nx \l_@@_split_pathb_tl
        {{ \tl_head:N \l_@@_split_path_tl }}
        \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      
        \tl_put_right:Nx \l_@@_split_pathb_tl
        {{ \tl_head:N \l_@@_split_path_tl }}
        \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      
        \prg_replicate:nn {2} {
        
          \tl_put_right:Nx \l_@@_split_pathb_tl
          { \tl_head:N \l_@@_split_path_tl }
          \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
        
          \tl_put_right:Nx \l_@@_split_pathb_tl
          {{ \tl_head:N \l_@@_split_path_tl }}
          \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
      
          \tl_put_right:Nx \l_@@_split_pathb_tl
          {{ \tl_head:N \l_@@_split_path_tl }}
          \tl_set:Nx \l_@@_split_path_tl {\tl_tail:N \l_@@_split_path_tl }
        }

        \spath_split_curve:NNVV
        \l_@@_split_intoa_tl
        \l_@@_split_intob_tl
        \l_@@_split_fp \l_@@_split_pathb_tl

        \prg_replicate:nn {3} {
          \tl_set:Nx \l_@@_split_intoa_tl {\tl_tail:N \l_@@_split_intoa_tl}
        }

        \tl_put_right:NV \l_@@_split_patha_tl \l_@@_split_intoa_tl
        \tl_put_right:NV \l_@@_split_intob_tl \l_@@_split_path_tl
      }
    }
  }

  \tl_gclear:N \g_@@_smuggle_tl
  \tl_gput_right:Nn \g_@@_smuggle_tl
  {
    \tl_set:Nn #1
  }
  \@@_tl_gput_right_braced:NV \g_@@_smuggle_tl \l_@@_split_patha_tl
  \tl_gput_right:Nn \g_@@_smuggle_tl
  {
    \tl_set:Nn #2
  }
  \@@_tl_gput_right_braced:NV \g_@@_smuggle_tl \l_@@_split_intob_tl
  \group_end:
  \tl_use:N \g_@@_smuggle_tl
}

\cs_generate_variant:Nn \spath_split_at:NNnn {NNVn, NNVV, NNnV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_split_at:Nnn}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_split_at:Nnn #1#2#3
{
  \group_begin:
  \spath_split_at:NNnn \l_@@_tmpa_tl \l_@@_tmpb_tl {#2}{#3}
  \spath_append:NV \l_@@_tmpa_tl \l_@@_tmpb_tl
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_split_at:Nnn {NVn, NVV}
\cs_new_protected_nopar:Npn \spath_split_at:Nn #1#2
{
  \spath_split_at:NVn #1#1{#2}
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Shortening Paths}
%
% This code relates to shortening paths
%
%    \begin{macrocode}
\tl_new:N \l_@@_shorten_fa_tl
\tl_new:N \l_@@_shorten_path_tl
\tl_new:N \l_@@_shorten_last_tl
\int_new:N \l_@@_shorten_int
\fp_new:N \l_@@_shorten_x_fp
\fp_new:N \l_@@_shorten_y_fp
%    \end{macrocode}
%
% \begin{macro}[internal]{\spath_shorten_at_end:Nnn}
% This macro shortens a path from the end by a dimension.
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_shorten_at_end:Nnn #1#2#3
{
  \int_compare:nT
  {
    \tl_count:n {#2} > 3
  }
  {
  \group_begin:
  \tl_set:Nn \l_@@_shorten_path_tl {#2}
  \tl_reverse:N \l_@@_shorten_path_tl

  \tl_set:Nx \l_@@_shorten_fa_tl {\tl_item:Nn \l_@@_shorten_path_tl {3}}

  \tl_clear:N \l_@@_shorten_last_tl
  \tl_if_eq:NNTF \l_@@_shorten_fa_tl \c_spath_curveto_tl
  {
    \int_set:Nn \l_@@_shorten_int {3}
  }
  {
    \int_set:Nn \l_@@_shorten_int {1}
  }

  \prg_replicate:nn { \l_@@_shorten_int }
  {
    \tl_put_right:Nx \l_@@_shorten_last_tl
    {
      {\tl_head:N \l_@@_shorten_path_tl}
    }
    \tl_set:Nx \l_@@_shorten_path_tl {\tl_tail:N \l_@@_shorten_path_tl}
    \tl_put_right:Nx \l_@@_shorten_last_tl
    {
      {\tl_head:N \l_@@_shorten_path_tl}
    }
    \tl_set:Nx \l_@@_shorten_path_tl {\tl_tail:N \l_@@_shorten_path_tl}
    \tl_put_right:Nx \l_@@_shorten_last_tl
    {
      \tl_head:N \l_@@_shorten_path_tl
    }
    \tl_set:Nx \l_@@_shorten_path_tl {\tl_tail:N \l_@@_shorten_path_tl}
  }

  \tl_put_right:Nx \l_@@_shorten_last_tl
  {
    {\tl_item:Nn \l_@@_shorten_path_tl {1}}
    {\tl_item:Nn \l_@@_shorten_path_tl {2}}
  }
  \tl_put_right:NV \l_@@_shorten_last_tl \c_spath_moveto_tl
  
  \tl_reverse:N \l_@@_shorten_path_tl

  \fp_set:Nn \l_@@_shorten_x_fp
  {
    \dim_to_fp:n {\tl_item:Nn \l_@@_shorten_last_tl {4}}
    -
    \dim_to_fp:n {\tl_item:Nn \l_@@_shorten_last_tl {1}}
  }
  
  \fp_set:Nn \l_@@_shorten_y_fp
  {
    \dim_to_fp:n {\tl_item:Nn \l_@@_shorten_last_tl {5}}
    -
    \dim_to_fp:n {\tl_item:Nn \l_@@_shorten_last_tl {2}}
  }

  \fp_set:Nn \l_@@_shorten_len_fp
  {
    sqrt( \l_@@_shorten_x_fp * \l_@@_shorten_x_fp +  \l_@@_shorten_y_fp *  \l_@@_shorten_y_fp )
  }

  \fp_compare:nTF
  {
    \l_@@_shorten_len_fp > #3
  }
  {
  
    \fp_set:Nn \l_@@_shorten_len_fp
    {
      (\l_@@_shorten_len_fp - #3)/ \l_@@_shorten_len_fp
    }

    \tl_reverse:N \l_@@_shorten_last_tl

    \tl_if_eq:NNTF \l_@@_shorten_fa_tl \c_spath_curveto_tl
    {
      \fp_set:Nn \l_@@_shorten_len_fp
      {
        1 - (1 -\l_@@_shorten_len_fp)/3
      }
      \spath_split_curve:NNVV
      \l_@@_shorten_lasta_tl
      \l_@@_shorten_lastb_tl
      \l_@@_shorten_len_fp \l_@@_shorten_last_tl
    }
    {
      \spath_split_line:NNVV
      \l_@@_shorten_lasta_tl
      \l_@@_shorten_lastb_tl
      \l_@@_shorten_len_fp \l_@@_shorten_last_tl
    }

    \prg_replicate:nn {3}
    {
      \tl_set:Nx \l_@@_shorten_lasta_tl {\tl_tail:N \l_@@_shorten_lasta_tl}
    }

    \tl_put_right:NV \l_@@_shorten_path_tl \l_@@_shorten_lasta_tl

  }
  {

    \int_compare:nT
    {
      \tl_count:N \l_@@_shorten_path_tl > 3
    }
    {
      \dim_set:Nn \l_@@_tmpa_dim {\fp_to_dim:n {#3 - \l_@@_shorten_len_fp } }
      \spath_shorten_at_end:NV \l_@@_shorten_path_tl \l_@@_tmpa_dim
    }
  }

  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_shorten_path_tl
  \group_end:
  
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  }
}
\cs_generate_variant:Nn \spath_shorten_at_end:Nnn {NVV, cnn, cVV, NVn}
\cs_new_protected_nopar:Npn \spath_shorten_at_end:Nn #1#2
{
  \spath_shorten_at_end:NVn #1#1{#2}
}
\cs_generate_variant:Nn \spath_shorten_at_end:Nn {cn, cV, NV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_shorten_at_start:Nnn}
% This macro shortens a path from the start by a dimension.
%
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_shorten_at_start:Nnn #1#2#3
{
  \int_compare:nT
  {
    \tl_count:n {#2} > 3
  }
  {
  \group_begin:
  \tl_set:Nn \l_@@_shorten_path_tl {#2}

  \tl_set:Nx \l_@@_shorten_fa_tl {\tl_item:Nn \l_@@_shorten_path_tl {4}}

    \tl_clear:N \l_@@_shorten_last_tl

  \tl_if_eq:NNTF \l_@@_shorten_fa_tl \c_spath_curvetoa_tl
  {
    \int_set:Nn \l_@@_shorten_int {3}
  }
  {
    \int_set:Nn \l_@@_shorten_int {1}
  }

  \tl_set_eq:NN \l_@@_shorten_last_tl \c_spath_moveto_tl
  \tl_set:Nx \l_@@_shorten_path_tl {\tl_tail:N \l_@@_shorten_path_tl }

  \prg_replicate:nn { \l_@@_shorten_int }
  {
    \@@_tl_put_right_braced:Nx \l_@@_shorten_last_tl {\tl_item:Nn \l_@@_shorten_path_tl {1}}
    \@@_tl_put_right_braced:Nx \l_@@_shorten_last_tl {\tl_item:Nn \l_@@_shorten_path_tl {2}}
    \tl_put_right:Nx \l_@@_shorten_last_tl {\tl_item:Nn \l_@@_shorten_path_tl {3}}

    \prg_replicate:nn {3}
    {
      \tl_set:Nx \l_@@_shorten_path_tl {\tl_tail:N \l_@@_shorten_path_tl }
    }
  }
  \@@_tl_put_right_braced:Nx \l_@@_shorten_last_tl {\tl_item:Nn \l_@@_shorten_path_tl {1}}
  \@@_tl_put_right_braced:Nx \l_@@_shorten_last_tl {\tl_item:Nn \l_@@_shorten_path_tl {2}}

  \fp_set:Nn \l_@@_shorten_x_fp
  {
    \dim_to_fp:n {\tl_item:Nn \l_@@_shorten_last_tl {5}}
    -
    \dim_to_fp:n {\tl_item:Nn \l_@@_shorten_last_tl {2}}
  }
  
  \fp_set:Nn \l_@@_shorten_y_fp
  {
    \dim_to_fp:n {\tl_item:Nn \l_@@_shorten_last_tl {6}}
    -
    \dim_to_fp:n {\tl_item:Nn \l_@@_shorten_last_tl {3}}
  }

  \fp_set:Nn \l_@@_shorten_len_fp
  {
    sqrt( \l_@@_shorten_x_fp * \l_@@_shorten_x_fp +  \l_@@_shorten_y_fp *  \l_@@_shorten_y_fp )
  }

  \fp_compare:nTF
  {
    \l_@@_shorten_len_fp > #3
  }
  {
  
    \fp_set:Nn \l_@@_shorten_len_fp
    {
      #3/ \l_@@_shorten_len_fp
    }

    \tl_if_eq:NNTF \l_@@_shorten_fa_tl \c_spath_curvetoa_tl
    {
      \fp_set:Nn \l_@@_shorten_len_fp
      {
        \l_@@_shorten_len_fp/3
      }
      \spath_split_curve:NNVV
      \l_@@_shorten_lasta_tl
      \l_@@_shorten_lastb_tl
      \l_@@_shorten_len_fp \l_@@_shorten_last_tl
    }
    {
      \spath_split_line:NNVV
      \l_@@_shorten_lasta_tl
      \l_@@_shorten_lastb_tl
      \l_@@_shorten_len_fp \l_@@_shorten_last_tl
    }

    \prg_replicate:nn {2}
    {
      \tl_set:Nx \l_@@_shorten_path_tl {\tl_tail:N \l_@@_shorten_path_tl}
    }

    \tl_put_left:NV \l_@@_shorten_path_tl \l_@@_shorten_lastb_tl

  }
  {

    \tl_put_left:NV \l_@@_shorten_path_tl \c_spath_moveto_tl
    
    \int_compare:nT
    {
      \tl_count:N \l_@@_shorten_path_tl > 3
    }
    {
      \dim_set:Nn \l_@@_tmpa_dim {\fp_to_dim:n {#3 - \l_@@_shorten_len_fp } }
      \spath_shorten_at_start:NV \l_@@_shorten_path_tl \l_@@_tmpa_dim
    }
  }

  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_shorten_path_tl
  \group_end:

  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  }
}
\cs_generate_variant:Nn \spath_shorten_at_start:Nnn {NVV, cnn, cVV, NVn}
\cs_new_protected_nopar:Npn \spath_shorten_at_start:Nn #1#2
{
  \spath_shorten_at_start:NVn #1#1{#2}
}
\cs_generate_variant:Nn \spath_shorten_at_start:Nn {cn, cV, NV}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Points on a Path}
%
% \begin{macro}[internal]{\spath_get_point_at:Nnn}
% Get the location of a point on a path, using the same location specification as the intersection library.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_get_point_at:Nnn #1#2#3
{
  \group_begin:
  \int_set:Nn \l_@@_tmpa_int {\fp_to_int:n {floor(#3) + 1}}
  \fp_set:Nn \l_@@_tmpa_fp {#3 - floor(#3)}

  \spath_segments_to_seq:Nn \l_@@_tmpa_seq {#2}

  \int_compare:nTF
  {
    \l_@@_tmpa_int < 1
  }
  {
    \spath_initialpoint:Nn \l_@@_tmpc_tl {#2}
  }
  {
    \int_compare:nTF
    {
      \l_@@_tmpa_int > \seq_count:N \l_@@_tmpa_seq
    }
    {
      \spath_finalpoint:Nn \l_@@_tmpc_tl {#2}
    }
    {
  
      \tl_set:Nx \l_@@_tmpa_tl {\seq_item:Nn \l_@@_tmpa_seq { \l_@@_tmpa_int} }

      \int_compare:nTF
      {
        \tl_count:N \l_@@_tmpa_tl > 3
      }
      {
        \tl_set:Nx \l_@@_tmpb_tl {\tl_item:Nn \l_@@_tmpa_tl {4}}
      }
      {
        \tl_set:Nx \l_@@_tmpb_tl {\tl_item:Nn \l_@@_tmpa_tl {1}}
      }

      \tl_clear:N \l_@@_tmpc_tl
  
      \tl_case:Nn \l_@@_tmpb_tl
      {
        \c_spath_moveto_tl
        {
          \tl_set:Nx \l_@@_tmpc_tl
          {
            {
              \tl_item:Nn \l_@@_tmpa_tl {2}
            }
            {
              \tl_item:Nn \l_@@_tmpa_tl {3}
            }
          }
        }
        
        \c_spath_lineto_tl
        {
          \tl_set:Nx \l_@@_tmpc_tl
          {
            {\fp_to_dim:n
              {
                (1 - \l_@@_tmpa_fp) * ( \tl_item:Nn \l_@@_tmpa_tl {2} )
                +
                \l_@@_tmpa_fp * ( \tl_item:Nn \l_@@_tmpa_tl {5} )
              }
            }
            {\fp_to_dim:n
              {
                (1 - \l_@@_tmpa_fp) * ( \tl_item:Nn \l_@@_tmpa_tl {3} )
                +
                \l_@@_tmpa_fp * ( \tl_item:Nn \l_@@_tmpa_tl {6} )
              }
            }
          }
        }

        \c_spath_closepath_tl
        {
          \tl_set:Nx \l_@@_tmpc_tl
          {
            {\fp_to_dim:n
              {
                (1 - \l_@@_tmpa_fp) * ( \tl_item:Nn \l_@@_tmpa_tl {2} )
                +
                \l_@@_tmpa_fp * ( \tl_item:Nn \l_@@_tmpa_tl {5} )
              }
            }
            {\fp_to_dim:n
              {
                (1 - \l_@@_tmpa_fp) * ( \tl_item:Nn \l_@@_tmpa_tl {3} )
                +
                \l_@@_tmpa_fp * ( \tl_item:Nn \l_@@_tmpa_tl {6} )
              }
            }
          }
        }
    
        \c_spath_curvetoa_tl
        {
          \tl_set:Nx \l_@@_tmpc_tl
          {
            {\fp_to_dim:n
              {
                (1 - \l_@@_tmpa_fp)^3 * \tl_item:Nn \l_@@_tmpa_tl {2} + 3 * (1 - \l_@@_tmpa_fp)^2 * (\l_@@_tmpa_fp) * \tl_item:Nn \l_@@_tmpa_tl {5} + 3 * (1 - \l_@@_tmpa_fp) * (\l_@@_tmpa_fp)^2 * \tl_item:Nn \l_@@_tmpa_tl {8} + (\l_@@_tmpa_fp)^3 * \tl_item:Nn \l_@@_tmpa_tl {11}
            }}
            {\fp_to_dim:n
              {
                (1 - \l_@@_tmpa_fp)^3 * \tl_item:Nn \l_@@_tmpa_tl {3} + 3 * (1 - \l_@@_tmpa_fp)^2 * (\l_@@_tmpa_fp) * \tl_item:Nn \l_@@_tmpa_tl {6} + 3 * (1 - \l_@@_tmpa_fp) * (\l_@@_tmpa_fp)^2 * \tl_item:Nn \l_@@_tmpa_tl {9} + (\l_@@_tmpa_fp)^3 * \tl_item:Nn \l_@@_tmpa_tl {12}
            }}
          }
        }
      }
    }
  }

  \tl_gclear:N \g_@@_smuggle_tl
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpc_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
}

\cs_generate_variant:Nn \spath_get_point_at:Nnn {NVn, NVV, NnV}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Intersection Routines}
%
% Note: I'm not consistent with number schemes.
% The intersection library is 0-based, but the user interface is 1-based (since if we ``count'' in a \Verb+\foreach+ then it starts at 1).
% This should be more consistent.
%
%    \begin{macrocode}
\tl_new:N \l_@@_split_path_a_tl
\tl_new:N \l_@@_split_path_b_tl
\tl_new:N \l_@@_split_path_a_start_tl
\tl_new:N \l_@@_split_path_b_start_tl
\tl_new:N \l_@@_split_path_a_end_tl
\tl_new:N \l_@@_split_path_b_end_tl
\tl_new:N \l_@@_split_path_a_final_tl
\tl_new:N \l_@@_split_path_b_final_tl

\tl_new:N \l_@@_split_path_a_src_tl
\tl_new:N \l_@@_split_path_b_src_tl

\tl_new:N \l_@@_split_prev_first_tl
\tl_new:N \l_@@_split_prev_second_tl

\seq_new:N \l_@@_split_first_seq
\seq_new:N \l_@@_split_second_seq

\int_new:N \l_@@_split_segment_int
%    \end{macrocode}
%
% \begin{macro}[internal]{\spath_intersect:NN}
% Pass two spaths to pgf's intersection routine.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_intersect:NN #1#2
{
  \pgfintersectionofpaths%
  {%
    \pgfsetpath #1
  }{%
    \pgfsetpath #2
  }
}
\tl_new:N \l_@@_intersecta_tl
\tl_new:N \l_@@_intersectb_tl
\cs_new_protected_nopar:Npn \spath_intersect:nn #1#2
{
  \tl_set:Nn \l_@@_intersecta_tl {#1}
  \tl_set:Nn \l_@@_intersectb_tl {#2}
  \spath_intersect:NN \l_@@_intersecta_tl \l_@@_intersectb_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_split_at_intersections:NNnn}
% Given two paths, split them at points where they intersect and store them in the macros.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_split_at_intersections:NNnn #1#2#3#4
{
  \group_begin:

  % Clear some token lists and sequences
  \tl_clear:N \l_@@_split_path_a_final_tl
  \tl_clear:N \l_@@_split_path_b_final_tl
  \seq_clear:N \l_@@_split_first_seq
  \seq_clear:N \l_@@_split_second_seq
  
  \pgfintersectionsortbyfirstpath
  % Find the intersections of these segments
  \tl_set:Nn \l_@@_split_path_a_tl {#3}
  \tl_set:Nn \l_@@_split_path_b_tl {#4}
  % Remove empty components
%  \spath_path_remove_empty_components:N \l_@@_split_path_a_tl
%  \spath_path_remove_empty_components:N \l_@@_split_path_b_tl

  \spath_intersect:NN \l_@@_split_path_a_tl \l_@@_split_path_b_tl
  
  % If we get intersections
  \int_compare:nT {\pgfintersectionsolutions > 0}
  {
    % Find the times of the intersections on each path
    \int_step_inline:nnnn {1} {1} {\pgfintersectionsolutions}
    {
    \pgfintersectiongetsolutiontimes{##1}{\l_@@_split_first_tl}{\l_@@_split_second_tl}
      \seq_put_left:NV \l_@@_split_first_seq \l_@@_split_first_tl
    }
  }

  \spath_intersect:NN \l_@@_split_path_b_tl \l_@@_split_path_a_tl
  
  % If we get intersections
  \int_compare:nT {\pgfintersectionsolutions > 0}
  {
    % Find the times of the intersections on each path
    \int_step_inline:nnnn {1} {1} {\pgfintersectionsolutions}
    {
    \pgfintersectiongetsolutiontimes{##1}{\l_@@_split_first_tl}{\l_@@_split_second_tl}
      \seq_put_left:NV \l_@@_split_second_seq \l_@@_split_first_tl
    }
  }

  \tl_set:Nn \l_@@_split_prev_first_tl {-1}

  \seq_map_inline:Nn \l_@@_split_first_seq
  {
    \tl_set:Nn \l_@@_split_first_tl {##1}
    
    \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_split_first_tl
    \int_compare:nT
    {
      \fp_to_int:n {floor( \l_@@_split_first_tl) }
      =
      \fp_to_int:n {floor( \l_@@_split_prev_first_tl) }
    }
    {
      \tl_set:Nx \l_@@_split_first_tl
      {
        \fp_eval:n {
          floor( \l_@@_split_first_tl )
          +
          ( \l_@@_split_first_tl - floor( \l_@@_split_first_tl) )
          /
          ( \l_@@_split_prev_first_tl - floor( \l_@@_split_prev_first_tl) )
        }
      }
    }
    \tl_set_eq:NN \l_@@_split_prev_first_tl \l_@@_tmpa_tl
    
    \spath_split_at:NNVV \l_@@_split_path_a_start_tl \l_@@_split_path_a_end_tl  \l_@@_split_path_a_tl \l_@@_split_first_tl
    
    \tl_put_left:NV \l_@@_split_path_a_final_tl \l_@@_split_path_a_end_tl
    \tl_set_eq:NN \l_@@_split_path_a_tl \l_@@_split_path_a_start_tl
    
  }
    
  \tl_set:Nn \l_@@_split_prev_second_tl {-1}

  \seq_map_inline:Nn \l_@@_split_second_seq
  {
    \tl_set:Nn \l_@@_split_second_tl {##1}
    
    \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_split_second_tl
    \int_compare:nT
    {
      \fp_to_int:n {floor( \l_@@_split_second_tl) }
      =
      \fp_to_int:n {floor( \l_@@_split_prev_second_tl) }
    }
    {
      \tl_set:Nx \l_@@_split_second_tl
      {
        \fp_eval:n {
          floor( \l_@@_split_second_tl )
          +
          ( \l_@@_split_second_tl - floor( \l_@@_split_second_tl) )
          /
          ( \l_@@_split_prev_second_tl - floor( \l_@@_split_prev_second_tl) )
        }
      }
    }
    \tl_set_eq:NN \l_@@_split_prev_second_tl \l_@@_tmpa_tl

    \spath_split_at:NNVV \l_@@_split_path_b_start_tl \l_@@_split_path_b_end_tl  \l_@@_split_path_b_tl\l_@@_split_second_tl
      
    \tl_put_left:NV \l_@@_split_path_b_final_tl \l_@@_split_path_b_end_tl
    \tl_set_eq:NN \l_@@_split_path_b_tl \l_@@_split_path_b_start_tl
    
  }

  \tl_put_left:NV \l_@@_split_path_a_final_tl \l_@@_split_path_a_tl
  \tl_put_left:NV \l_@@_split_path_b_final_tl \l_@@_split_path_b_tl

  \tl_if_empty:NT \l_@@_split_path_a_final_tl
  {
    \tl_set_eq:NN \l_@@_split_path_a_final_tl \l_@@_split_path_a_tl
  }
  \tl_if_empty:NT \l_@@_split_path_b_final_tl
  {
    \tl_set_eq:NN \l_@@_split_path_b_final_tl \l_@@_split_path_b_tl
  }
  
  \spath_remove_empty_components:N \l_@@_split_path_a_final_tl
  \spath_remove_empty_components:N \l_@@_split_path_b_final_tl
  
  \tl_gclear:N \g_@@_smuggle_tl
  \tl_gset:Nn \g_@@_smuggle_tl
  {
    \tl_set:Nn #1
  }
  \@@_tl_gput_right_braced:NV \g_@@_smuggle_tl \l_@@_split_path_a_final_tl
  \tl_gput_right:Nn \g_@@_smuggle_tl
  {
    \tl_set:Nn #2
  }
  \@@_tl_gput_right_braced:NV \g_@@_smuggle_tl \l_@@_split_path_b_final_tl
  \group_end:
  \tl_use:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_split_at_intersections:NNnn {NNVV, ccVV, ccvv}
\cs_new_protected_nopar:Npn \spath_split_at_intersections:NN #1#2
{
  \spath_split_at_intersections:NNVV #1#2#1#2
}
\cs_generate_variant:Nn \spath_split_at_intersections:NN {cc}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_split_at_self_intersections:Nn}
% Given a path, split it at points where it self-intersects and store in the given macro.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_split_at_self_intersections:Nn #1#2
{
  \group_begin:
  
  % Copy the path
  \tl_set:Nn \l_@@_split_path_b_tl {#2}

  % Open the path
  \spath_open:N \l_@@_split_path_b_tl
  % Remove empty components
  \spath_remove_empty_components:N \l_@@_split_path_b_tl
  % Make a copy for later
  \tl_set_eq:NN \l_@@_split_path_b_final_tl \l_@@_split_path_b_tl
  
  % Clear some token lists and sequences
  \tl_clear:N \l_@@_split_path_a_tl
  \seq_clear:N \l_@@_split_first_seq
  \int_zero:N \l_@@_split_segment_int

  \pgfintersectionsortbyfirstpath

  \bool_do_until:nn
  {
    \int_compare_p:n
    {
      \tl_count:N \l_@@_split_path_b_tl < 4
    }
  }
  {
    \tl_clear:N \l_@@_split_path_a_tl
    \tl_put_right:Nx \l_@@_split_path_a_tl
    {
      \tl_item:Nn \l_@@_split_path_b_tl {1}
      {\tl_item:Nn \l_@@_split_path_b_tl {2}}
      {\tl_item:Nn \l_@@_split_path_b_tl {3}}
    }

    \tl_set:Nx \l_@@_tmpa_tl { \tl_item:Nn \l_@@_split_path_b_tl {4} }

    \tl_set:Nx \l_@@_split_path_b_tl {\tl_tail:N \l_@@_split_path_b_tl}

    \int_zero:N \l_@@_tmpa_int
    
    \tl_case:Nn \l_@@_tmpa_tl
    {
      \c_spath_moveto_tl
      {
        \tl_clear:N \l_@@_split_path_a_tl
        \tl_set:Nx \l_@@_split_path_b_tl {\tl_tail:N \l_@@_split_path_b_tl}
        \tl_set:Nx \l_@@_split_path_b_tl {\tl_tail:N \l_@@_split_path_b_tl}
        \tl_set:Nx \l_@@_split_path_b_tl {\tl_tail:N \l_@@_split_path_b_tl}
      }
      \c_spath_lineto_tl
      {
        \int_set:Nn \l_@@_tmpa_int {1}
      }
      \c_spath_curvetoa_tl
      {
        \int_set:Nn \l_@@_tmpa_int {3}
      }
    }

    \prg_replicate:nn { \l_@@_tmpa_int }
    {
      \tl_set:Nx \l_@@_split_path_b_tl {\tl_tail:N \l_@@_split_path_b_tl}
      \tl_set:Nx \l_@@_split_path_b_tl {\tl_tail:N \l_@@_split_path_b_tl}
      
      \tl_put_right:Nx \l_@@_split_path_a_tl
      {
        \tl_item:Nn \l_@@_split_path_b_tl {1}
        {\tl_item:Nn \l_@@_split_path_b_tl {2}}
        {\tl_item:Nn \l_@@_split_path_b_tl {3}}
      }

      \tl_set:Nx \l_@@_split_path_b_tl {\tl_tail:N \l_@@_split_path_b_tl}
    }
    
    \tl_put_left:NV \l_@@_split_path_b_tl \c_spath_moveto_tl

    \tl_if_empty:NF \l_@@_split_path_a_tl
    {
      % Intersect the current segment with the rest of the path
      \spath_intersect:NN \l_@@_split_path_a_tl \l_@@_split_path_b_tl


      % If we get intersections
      \int_compare:nT {\pgfintersectionsolutions > 0}
      {
        % Find the times of the intersections on each path
        \int_step_inline:nnnn {1} {1} {\pgfintersectionsolutions}
        {
          \pgfintersectiongetsolutiontimes{##1}{\l_@@_split_first_tl}{\l_@@_split_second_tl}
          \fp_compare:nT
          {
            \l_@@_split_first_tl < .99
          }
          {
            \tl_set:Nx \l_@@_tmpa_tl {\fp_to_decimal:n {\l_@@_split_first_tl +  \l_@@_split_segment_int}}
            \seq_put_right:NV \l_@@_split_first_seq \l_@@_tmpa_tl
          }
        }
      }

      \spath_intersect:NN \l_@@_split_path_b_tl \l_@@_split_path_a_tl

      % If we get intersections
      \int_compare:nT {\pgfintersectionsolutions > 0}
      {
        % Find the times of the intersections on each path
        \int_step_inline:nnnn {1} {1} {\pgfintersectionsolutions}
        {
          \pgfintersectiongetsolutiontimes{##1}{\l_@@_split_first_tl}{\l_@@_split_second_tl}
          \fp_compare:nT
          {
            \l_@@_split_first_tl > .01
          }
          {
            \tl_set:Nx \l_@@_tmpa_tl {\fp_to_decimal:n {\l_@@_split_first_tl +  \l_@@_split_segment_int + 1}}
            \seq_put_right:NV \l_@@_split_first_seq \l_@@_tmpa_tl
          }
        }
      }
      
    }
    % Increment the segment counter
    \int_incr:N \l_@@_split_segment_int
  }

  % Sort the sequence by reverse order along the path
  \seq_sort:Nn \l_@@_split_first_seq
  {
    \fp_compare:nNnTF { ##1 } < { ##2 }
    { \sort_return_swapped: }
    { \sort_return_same: }
  }

  % Restore the original copy of the path
  \tl_set_eq:NN \l_@@_split_path_b_tl \l_@@_split_path_b_final_tl

  % Clear the token lists
  \tl_clear:N \l_@@_split_path_b_start_tl
  \tl_clear:N \l_@@_split_path_b_end_tl
  \tl_clear:N \l_@@_split_path_b_final_tl

  \tl_set:Nn \l_@@_split_prev_first_tl {-1}

  \seq_map_inline:Nn \l_@@_split_first_seq
  {
    \tl_set:Nn \l_@@_split_first_tl {##1}
    \tl_set_eq:NN \l_@@_tmpa_tl \l_@@_split_first_tl
    \int_compare:nT
    {
      \fp_to_int:n {floor( \l_@@_split_first_tl ) }
      =
      \fp_to_int:n {floor( \l_@@_split_prev_first_tl) }
    }
    {
      \tl_set:Nx \l_@@_split_first_tl
      {
        \fp_eval:n {
          floor( \l_@@_split_first_tl )
          +
          ( \l_@@_split_first_tl - floor( \l_@@_split_first_tl) )
          /
          ( \l_@@_split_prev_first_tl - floor( \l_@@_split_prev_first_tl) )
        }
      }
    }
    \tl_set_eq:NN \l_@@_split_prev_first_tl \l_@@_tmpa_tl

    \spath_split_at:NNVV \l_@@_split_path_b_start_tl \l_@@_split_path_b_end_tl  \l_@@_split_path_b_tl \l_@@_split_first_tl
      
    \tl_put_left:NV \l_@@_split_path_b_final_tl \l_@@_split_path_b_end_tl
    \tl_set_eq:NN \l_@@_split_path_b_tl \l_@@_split_path_b_start_tl

  }

  \tl_put_left:NV \l_@@_split_path_b_final_tl \l_@@_split_path_b_tl

  \tl_if_empty:NT \l_@@_split_path_b_final_tl
  {
    \tl_set_eq:NN \l_@@_split_path_b_final_tl \l_@@_split_path_b_tl
  }

  \spath_remove_empty_components:N \l_@@_split_path_b_final_tl
  
  \tl_gclear:N \g_@@_smuggle_tl
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_split_path_b_final_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_split_at_self_intersections:Nn {NV}
\cs_new_protected_nopar:Npn \spath_split_at_self_intersections:N #1
{
  \spath_split_at_self_intersections:NV #1#1
}
\cs_generate_variant:Nn \spath_split_at_self_intersections:N {c}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[internal]{\spath_join_component:Nnn #1#2#3}
% Join the specified component of the spath to its predecessor
%    \begin{macrocode}
\tl_new:N \l_@@_tmpj_tl
\cs_new_protected_nopar:Npn \spath_join_component:Nnn #1#2#3
{
  \group_begin:
  \spath_components_to_seq:Nn \l_@@_tmpa_seq {#2}
  \int_compare:nT
  {
    #3 == 1
  }
  {
    \tl_clear:N \l_@@_tmpj_tl
    \seq_pop_left:NN \l_@@_tmpa_seq \l_@@_tmpj_tl
    
    \prg_replicate:nn {3}
    {
      \tl_set:Nx \l_@@_tmpj_tl {\tl_tail:N \l_@@_tmpj_tl}
    }

    \seq_put_right:NV \l_@@_tmpb_seq \l_@@_tmpj_tl
  }
  \bool_if:nT
  {
    \int_compare_p:n
    {
      #3 > 1
    }
    &&
    \int_compare_p:n
    {
      #3 <= \seq_count:N \l_@@_tmpa_seq
    }
  }
  {

    \seq_clear:N \l_@@_tmpb_seq
    \seq_map_indexed_inline:Nn \l_@@_tmpa_seq
    {
      \tl_set:Nn \l_@@_tmpj_tl {##2}
      \int_compare:nT {##1 = #3}
      {
        \prg_replicate:nn {3}
        {
          \tl_set:Nx \l_@@_tmpj_tl {\tl_tail:N \l_@@_tmpj_tl}
        }
      }
      \seq_put_right:NV \l_@@_tmpb_seq \l_@@_tmpj_tl
    }

    \seq_set_eq:NN \l_@@_tmpa_seq \l_@@_tmpb_seq
  }

  \tl_gset:Nx \g_@@_smuggle_tl {\seq_use:Nn \l_@@_tmpa_seq {} }
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_join_component:Nnn {NVn, NVV}
\cs_new_protected_nopar:Npn \spath_join_component:Nn #1#2
{
  \spath_join_component:NVn #1#1{#2}
}
\cs_generate_variant:Nn \spath_join_component:Nn {cn, NV, cV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_spot_weld_components:Nn #1#2}
% Weld together any components where the last point of one is at the start point of the next.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_spot_weld_components:Nn #1#2
{
  \group_begin:
  \dim_zero:N \l_@@_move_x_dim
  \dim_zero:N \l_@@_move_y_dim

  \spath_components_to_seq:Nn \l_@@_tmpa_seq {#2}
  \seq_clear:N \l_@@_tmpb_seq
  \dim_set:Nn \l_@@_move_x_dim {\tl_item:nn {#2} {2} + 10 pt}
  \dim_set:Nn \l_@@_move_y_dim {\tl_item:nn {#2} {3} + 10 pt}

  \int_set:Nn \l_@@_tmpa_int {\seq_count:N \l_@@_tmpa_seq}
  
  \seq_map_inline:Nn \l_@@_tmpa_seq
  {
    \tl_set:Nn \l_@@_tmpa_tl {##1}
    \bool_if:nT
    {
      \dim_compare_p:n
      {
        \dim_abs:n {\l_@@_move_x_dim - \tl_item:Nn \l_@@_tmpa_tl {2} } < 0.01pt
      }
      &&
      \dim_compare_p:n
      {
        \dim_abs:n {\l_@@_move_y_dim - \tl_item:Nn \l_@@_tmpa_tl {3} } < 0.01pt
      }
    }
    {
      \prg_replicate:nn {3}
      {
        \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
      }
      \int_decr:N \l_@@_tmpa_int
    }
    \tl_reverse:N \l_@@_tmpa_tl
    \dim_set:Nn \l_@@_move_x_dim {\tl_item:Nn \l_@@_tmpa_tl {2}}
    \dim_set:Nn \l_@@_move_y_dim {\tl_item:Nn \l_@@_tmpa_tl {1}}
    \tl_reverse:N \l_@@_tmpa_tl
    \seq_put_right:NV \l_@@_tmpb_seq \l_@@_tmpa_tl
  }

  \tl_set:Nx \l_@@_tmpa_tl {\seq_use:Nn \l_@@_tmpb_seq {} }
  \spath_components_to_seq:NV \l_@@_tmpb_seq \l_@@_tmpa_tl
  
  \spath_initialpoint:Nn \l_@@_tmpa_tl {#2}
  \spath_finalpoint:Nn \l_@@_tmpb_tl {#2}

  \bool_if:nT
  {
    \dim_compare_p:n
    {
      \dim_abs:n {\tl_item:Nn \l_@@_tmpa_tl {1} - \tl_item:Nn \l_@@_tmpb_tl {1} } < 0.01pt
    }
    &&
    \dim_compare_p:n
    {
      \dim_abs:n {\tl_item:Nn \l_@@_tmpa_tl {2} - \tl_item:Nn \l_@@_tmpb_tl {2} } < 0.01pt
    }
  }
  {
    \int_compare:nTF
    {
      \seq_count:N \l_@@_tmpb_seq > 1
    }
    {
      \seq_pop_left:NN \l_@@_tmpb_seq \l_@@_tmpb_tl

      \prg_replicate:nn {3}
      {
        \tl_set:Nx \l_@@_tmpb_tl {\tl_tail:N \l_@@_tmpb_tl}
      }
      \seq_put_right:NV \l_@@_tmpb_seq \l_@@_tmpb_tl
    }
    {
      \tl_set:NV \l_@@_tmpb_tl \c_spath_closepath_tl
      \tl_put_right:Nx \l_@@_tmpb_tl
      {
        { \tl_item:Nn \l_@@_tmpa_tl {1} }
        { \tl_item:Nn \l_@@_tmpa_tl {2} }
      }
      \seq_put_right:NV \l_@@_tmpb_seq \l_@@_tmpb_tl
    }
  }

  \tl_gset:Nx \g_@@_smuggle_tl {\seq_use:Nn \l_@@_tmpb_seq {}}
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
\cs_generate_variant:Nn \spath_spot_weld_components:Nn {NV, cV, cn}
\cs_new_protected_nopar:Npn \spath_spot_weld_components:N #1
{
  \spath_spot_weld_components:NV #1#1
}
\cs_generate_variant:Nn \spath_spot_weld_components:N {c}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Exporting Commands}
%
% \begin{macro}{\spath_convert_to_svg:Nn #1#2}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_convert_to_svg:Nn #1#2
{
  \group_begin:
  \tl_clear:N \l_@@_tmpa_tl
  \tl_put_right:Nn \l_@@_tmpa_tl
  {
    <?xml~ version="1.0"~ standalone="no"?>
    \iow_newline:
    <!DOCTYPE~ svg~ PUBLIC~ "-//W3C//DTD SVG 1.1//EN"~
    "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
    \iow_newline:
    <svg~ xmlns="http://www.w3.org/2000/svg"~ version="1.1"~viewBox="
  }

  \spath_minbb:NN #1 \l_@@_tmpb_tl
  \spath_maxbb:NN #1 \l_@@_tmpc_tl
  \tl_put_right:Nx \l_@@_tmpa_tl
  {
    \dim_to_decimal:n
    {
      \tl_item:Nn \l_@@_tmpb_tl {1} - 10pt
    }
    \exp_not:n {~}
    \dim_to_decimal:n
    {
      \tl_item:Nn \l_@@_tmpb_tl {2} - 10pt
    }
    \exp_not:n {~}
    \dim_to_decimal:n
    {
      \tl_item:Nn \l_@@_tmpc_tl {1}
      -
      \tl_item:Nn \l_@@_tmpb_tl {1}
      + 20pt
    }
    \exp_not:n {~}
    \dim_to_decimal:n
    {
      \tl_item:Nn \l_@@_tmpc_tl {2}
      -
      \tl_item:Nn \l_@@_tmpb_tl {2}
      + 20pt
    }
  }
  
  \tl_put_right:Nn \l_@@_tmpa_tl
  {
    ">
    \iow_newline:
    <path~ d="
  }
  \tl_set:Nn \l_@@_tmpc_tl {use:n}
  \tl_map_inline:Nn #2
  {
    \tl_set:Nn \l_@@_tmpb_tl {##1}
    \tl_case:NnF \l_@@_tmpb_tl
    {
      \c_spath_moveto_tl
      {
        \tl_put_right:Nn \l_@@_tmpa_tl {M~}
        \tl_set:Nn \l_@@_tmpc_tl {use:n}
      }
      \c_spath_lineto_tl
      {
        \tl_put_right:Nn \l_@@_tmpa_tl {L~}
        \tl_set:Nn \l_@@_tmpc_tl {use:n}
      }
      \c_spath_closepath_tl
      {
        \tl_put_right:Nn \l_@@_tmpa_tl {Z~}
        \tl_set:Nn \l_@@_tmpc_tl {use_none:n}
      }
      \c_spath_curvetoa_tl
      {
        \tl_put_right:Nn \l_@@_tmpa_tl {C~}
        \tl_set:Nn \l_@@_tmpc_tl {use:n}
      }
      \c_spath_curvetob_tl {
        \tl_set:Nn \l_@@_tmpc_tl {use:n}
      }
      \c_spath_curveto_tl {
        \tl_set:Nn \l_@@_tmpc_tl {use:n}
      }
    }
    {
      \tl_put_right:Nx \l_@@_tmpa_tl {\use:c { \l_@@_tmpc_tl } {\dim_to_decimal:n {##1}} ~}
    }
  }
  \tl_put_right:Nn \l_@@_tmpa_tl
  {
    "~ fill="none"~ stroke="black"~ />
    \iow_newline:
    </svg>
    \iow_newline:
  }
  \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpa_tl
  \group_end:
  \tl_set_eq:NN #1 \g_@@_smuggle_tl
  \tl_gclear:N \g_@@_smuggle_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\spath_export_to_svg:nn #1#2}
%    \begin{macrocode}
\iow_new:N \g_@@_stream
\cs_new_protected_nopar:Npn \spath_export_to_svg:nn #1#2
{
  \spath_convert_path_to_svg:Nn \l_@@_iterp_tl {#2}
  \iow_open:Nn \g_@@_stream {#1 .svg}
  \iow_now:Nx \g_@@_stream
  {
    \tl_use:N \l_@@_iterp_tl
  }
  \iow_close:N \g_@@_stream
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{PGF and TikZ Interface Functions}
%
% Spaths come from PGF so we need some functions that get and set spaths from the pgf system.
%
% \begin{macro}[internal]{\spath_get_current_path:N}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_get_current_path:N #1
{
  \pgfsyssoftpath@getcurrentpath #1
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_gget_current_path:N}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_gget_current_path:N #1
{
  \pgfsyssoftpath@getcurrentpath #1
  \tl_gset_eq:NN #1 #1
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_protocol_path:n}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_protocol_path:n #1
{
  \spath_minbb:Nn \l_@@_tmpa_tl {#1}
  \exp_last_unbraced:NV \pgf@protocolsizes\l_@@_tmpa_tl

  \spath_maxbb:Nn \l_@@_tmpa_tl {#1}
  \exp_last_unbraced:NV \pgf@protocolsizes\l_@@_tmpa_tl
}
\cs_generate_variant:Nn \spath_protocol_path:n {V}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_set_current_path:n}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_set_current_path:n #1
{
  \spath_protocol_path:n {#1}
  \tl_set:Nn \l_@@_tmpa_tl {#1}
  \pgfsyssoftpath@setcurrentpath\l_@@_tmpa_tl
}
\cs_new_protected_nopar:Npn \spath_set_current_path:N #1
{
  \spath_protocol_path:V #1
  \pgfsyssoftpath@setcurrentpath #1
}
\cs_generate_variant:Nn \spath_set_current_path:N {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_use_path:nn}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_use_path:nn #1#2
{
  \spath_set_current_path:n {#1}
  \pgfusepath{#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_tikz_path:nn}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_tikz_path:nn #1#2
{
  \path[#1] \pgfextra{
    \spath_set_current_path:n {#2}
    \tl_put_right:Nn \tikz@preactions {\def\tikz@actions@path{#2}}
  };
}
\cs_generate_variant:Nn \spath_tikz_path:nn {Vn, VV, nv, Vv, nV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\spath_set_tikz_coords:n}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \spath_set_tikz_coords:n #1
{
  \spath_finalpoint:Nn \l_@@_tmpa_tl {#1}
  \tl_set:Nx \l_@@_tmpa_tl
  {
    \exp_not:c {tikz@lastx}=\tl_item:Nn \l_@@_tmpa_tl {1}
    \exp_not:c {tikz@lasty}=\tl_item:Nn \l_@@_tmpa_tl {2}
    \exp_not:c {tikz@lastxsaved}=\tl_item:Nn \l_@@_tmpa_tl {1}
    \exp_not:c {tikz@lastysaved}=\tl_item:Nn \l_@@_tmpa_tl {2}
  }
  \tl_use:N \l_@@_tmpa_tl
}
\cs_generate_variant:Nn \spath_set_tikz_coords:n {V, v}
%    \end{macrocode}
% \end{macro}
%
% \iffalse
%</spath3>
% \fi
%
% \section{The TikZ interface}
%
% \iffalse
%<*tikzspath3>
% \fi
% Interfaces via TikZ keys.
%
%
%     \begin{macrocode}
\RequirePackage{spath3}
\RequirePackage{expl3}
\ExplSyntaxOn

\tl_new:N \l_@@_current_tl
\tl_new:N \l_@@_reverse_tl
\tl_new:N \l_@@_prefix_tl
\tl_new:N \l_@@_suffix_tl

\tl_set:Nn \l_@@_prefix_tl {tikz@intersect@path@name@}
\tl_set:Nn \l_@@_suffix_tl {}

\tl_new:N \g_@@_tikzfinish_tl
\cs_new_protected_nopar:Npn \spath_at_end_of_path:
{
  \tl_use:N \g_@@_tikzfinish_tl
  \tl_gclear:N \g_@@_tikzfinish_tl
}
\tl_put_right:Nn \tikz@finish {\spath_at_end_of_path:}

\cs_new_protected_nopar:Npn \spath_save_path:Nn #1#2
{
  \tl_gput_right:Nn \g_@@_tikzfinish_tl
  {
    \tl_set:Nn #1 {#2}
  }
}
\cs_generate_variant:Nn \spath_save_path:Nn {cn, NV, cV}

\cs_new_protected_nopar:Npn \spath_gsave_path:Nn #1#2
{
  \tl_gput_right:Nn \g_@@_tikzfinish_tl
  {
    \tl_gset:Nn #1 {#2}
  }
}
\cs_generate_variant:Nn \spath_gsave_path:Nn {cn, NV, cV}

\tikzset{
  spath/.is~family,
  spath/.cd,
  set~ prefix/.store~ in=\l_@@_prefix_tl,
  prefix/.is~choice,
  prefix/default/.style={
    /tikz/spath/set~ prefix=tikz@intersect@path@name@
  },
  set~ suffix/.store~ in=\l_@@_suffix_tl,
  suffix/.is~choice,
  suffix/default/.style={
    /tikz/spath/set~ suffix={}
  },
  set~ name/.style={
    /tikz/spath/prefix=#1,
    /tikz/spath/suffix=#1
  },
  save/.code={
    \tikz@addmode{
      \spath_get_current_path:N \l_@@_tmpa_tl
      \spath_bake_round:NV \l_@@_tmpa_tl \l_@@_tmpa_tl
      \spath_save_path:cV {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl} \l_@@_tmpa_tl
    }
  },
  clone/.code~ 2~ args={
    \tl_set_eq:cc {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl} {\tl_use:N \l_@@_prefix_tl #2 \tl_use:N \l_@@_suffix_tl}
  },
  save~ global/.code={
    \tikz@addmode{
      \spath_get_current_path:N \l_@@_tmpa_tl
      \spath_bake_round:NV \l_@@_tmpa_tl \l_@@_tmpa_tl
      \spath_gsave_path:cV {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl} \l_@@_tmpa_tl
    }
  },
  save~ to~ aux/.code={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \spath_save_to_aux:c {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    }
  },
  restore/.code={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \spath_set_current_path:c {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
      \spath_set_tikz_coords:v {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    }
  },
  show/.code={
    \tikz@addmode{
      \pgfsyssoftpath@getcurrentpath\l_@@_tmpa_tl
      \tl_show:N \l_@@_tmpa_tl
    }
  },
  append/.code={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \spath_get_current_path:N \l_@@_current_tl
      \spath_weld:Nv \l_@@_current_tl {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
      \spath_set_current_path:N \l_@@_current_tl
      \spath_set_tikz_coords:V \l_@@_current_tl
    }
  },
  join~ with/.code~ 2~ args={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #2 \tl_use:N \l_@@_suffix_tl}
      {
        \spath_append:cv {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl} {\tl_use:N \l_@@_prefix_tl #2 \tl_use:N \l_@@_suffix_tl}
      }
    }
  },
  spot~ weld/.code={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \spath_spot_weld_components:c {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    }
  },
  reverse/.code={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \spath_reverse:c {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    }
  },
  append~ reverse/.code={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \spath_reverse:Nv \l_@@_reverse_tl {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
      \spath_get_current_path:N \l_@@_current_tl
      \spath_weld:NV \l_@@_current_tl \l_@@_reverse_tl
      \spath_set_current_path:N \l_@@_current_tl
      \spath_set_tikz_coords:V \l_@@_current_tl
    }
  },    
  insert/.code={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \spath_get_current_path:N \l_@@_current_tl
      \spath_append:Nv \l_@@_current_tl {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
      \spath_set_current_path:N \l_@@_current_tl
      \spath_set_tikz_coords:V \l_@@_current_tl
    }
  },
  insert~ reverse/.code={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \spath_reverse:Nv \l_@@_reverse_tl {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
      \spath_get_current_path:N \l_@@_current_tl
      \spath_append:NV \l_@@_current_tl \l_@@_reverse_tl
      \spath_set_current_path:N \l_@@_current_tl
      \spath_set_tikz_coords:V \l_@@_current_tl
    }
  },
  shorten~ at~ end/.code~ 2~ args={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \spath_shorten_at_end:cn {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl} {#2}
    }
  },
  shorten~ at~ start/.code~ 2~ args ={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \spath_shorten_at_start:cn {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl} {#2}
    }
  },
  shorten~ at~ both~ ends/.code~ 2~ args={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \spath_shorten_at_end:cn {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl} {#2}
      \spath_shorten_at_start:cn {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl} {#2}
    }
  },
  translate/.code~ n~ args={3}{
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \spath_translate:cnn {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}{#2}{#3}
    }
  },
  export~ to~ svg/.code={
    \spath_export_to_svg:c {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
  },
  transform/.code~ 2~ args={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \group_begin:
      \pgftransformreset
      \tikzset{#2}
      \pgfgettransform \l_@@_tmpa_tl
      \tl_gset:Nn \g_@@_smuggle_tl
      {
        \spath_transform:cnnnnnn {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
      }
      \tl_gput_right:NV \g_@@_smuggle_tl \l_@@_tmpa_tl
      \group_end:
      \tl_use:N \g_@@_smuggle_tl
    }
  },
  split~ at~ intersections/.code~ n~ args={2}{
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #2 \tl_use:N \l_@@_suffix_tl}
      {
        \spath_split_at_intersections:cc {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}  {\tl_use:N \l_@@_prefix_tl #2 \tl_use:N \l_@@_suffix_tl}
      }
    }
  },
  split~ at~ self~ intersections/.code={
    \tl_if_exist:cT {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    {
      \spath_split_at_self_intersections:c {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    }
  },
  get~ components~ of/.code~ 2~ args={
    \clist_clear_new:N #2
    \spath_components_to_seq:Nv \l_@@_tmpa_seq {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    \seq_map_inline:Nn \l_@@_tmpa_seq
    {
      \tl_set:cn {\tl_use:N \l_@@_prefix_tl anonymous_\int_use:N \g_@@_anon_int \tl_use:N \l_@@_suffix_tl} {##1}
      \clist_put_right:Nx #2 {anonymous_\int_use:N \g_@@_anon_int}
      \int_gincr:N \g_@@_anon_int
    }
  },
  render~ components/.code={
    \group_begin:
    \spath_components_to_seq:Nv \l_@@_tmpa_seq {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    \seq_map_indexed_inline:Nn \l_@@_tmpa_seq
    {
      \spath_tikz_path:nn
      {
        spath~ components/.try,
        spath ~component~ ##1/.try,
        spath ~component/.try={##1},
        #1~ components/.try,
        every~ #1~ component/.try,
        #1 ~component~ ##1/.try,
        #1 ~component/.try={##1},
      }
      {
        ##2
      }
    }
    \group_end:
  },
  insert~ gaps~ after~ components/.code~ n~ args={3}{
    \group_begin:
    \seq_gclear:N \g_@@_tmpa_seq
    \seq_gclear:N \g_@@_tmpb_seq
    \foreach \l_@@_tmpa_tl in {#3}
    {
      \seq_gput_right:NV \g_@@_tmpa_seq \l_@@_tmpa_tl
      \seq_gput_right:Nx \g_@@_tmpb_seq {\int_eval:n { \l_@@_tmpa_tl + 1 }}
    }
    \spath_components_to_seq:Nv \l_@@_tmpa_seq {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
    \seq_clear:N \l_@@_tmpb_seq
    \seq_map_indexed_inline:Nn \l_@@_tmpa_seq
    {
      \tl_set:Nn \l_@@_tmpa_tl {##2}
      \seq_if_in:NnT \g_@@_tmpa_seq {##1}
      {
        \spath_shorten_at_end:Nn \l_@@_tmpa_tl {#2/2}
      }
      \seq_if_in:NnT \g_@@_tmpb_seq {##1}
      {
        \spath_shorten_at_start:Nn \l_@@_tmpa_tl {#2/2}
      }
      \seq_put_right:NV \l_@@_tmpb_seq \l_@@_tmpa_tl
    }
    \tl_gset:Nx \g_@@_smuggle_tl {\seq_use:Nn \l_@@_tmpb_seq {} }
    \group_end:
    \tl_set_eq:cN  {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl} \g_@@_smuggle_tl
    \tl_gclear:N \g_@@_smuggle_tl
  },
  join~ components/.code~ 2~ args={
    \seq_gclear:N \g_@@_tmpa_seq
    \foreach \l_@@_tmpa_tl in {#2}
    {
      \seq_gput_right:NV \g_@@_tmpa_seq \l_@@_tmpa_tl
    }
    \seq_sort:Nn \g_@@_tmpa_seq
    {
      \int_compare:nNnTF {##1} > {##2}
      { \sort_return_same: }
      { \sort_return_swapped: }
    }
    \seq_map_inline:Nn \g_@@_tmpa_seq
    {
      \spath_join_component:cn {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}{##1}
    }
  },
  remove~ empty~ components/.code={
    \spath_remove_empty_components:c {\tl_use:N \l_@@_prefix_tl #1 \tl_use:N \l_@@_suffix_tl}
  }
}

\tikzdeclarecoordinatesystem{spath}{%
  \group_begin:
  \tl_set:Nn \l_@@_tmpa_tl {#1}
  \tl_trim_spaces:N \l_@@_tmpa_tl

  \seq_set_split:NnV \l_@@_tmpa_seq {~} \l_@@_tmpa_tl
  \seq_pop_right:NN \l_@@_tmpa_seq \l_@@_tmpb_tl

  \tl_set:Nx \l_@@_tmpa_tl { \seq_use:Nn \l_@@_tmpa_seq {~} }
  \tl_set_eq:Nc \l_@@_tmpa_tl {\tl_use:N \l_@@_prefix_tl \tl_use:N \l_@@_tmpa_tl \tl_use:N \l_@@_suffix_tl }

  \tl_if_empty:NTF \l_@@_tmpa_tl
  {
    \tl_gset_eq:NN \g_@@_smuggle_tl \pgfpointorigin
  }
  {
    \spath_reallength:NV \l_@@_tmpa_int \l_@@_tmpa_tl
    \tl_set:Nx \l_@@_tmpb_tl {\fp_to_decimal:n {(\l_@@_tmpb_tl) * (\l_@@_tmpa_int)}}
    \spath_get_point_at:NVV \l_@@_tmpc_tl \l_@@_tmpa_tl \l_@@_tmpb_tl

    \tl_clear:N \l_@@_tmpd_tl
    \tl_put_right:Nn \l_@@_tmpd_tl {\pgf@x=}
    \tl_put_right:Nx \l_@@_tmpd_tl {\tl_item:Nn \l_@@_tmpc_tl {1}}
    \tl_put_right:Nn \l_@@_tmpd_tl {\relax}
    \tl_put_right:Nn \l_@@_tmpd_tl {\pgf@y=}
    \tl_put_right:Nx \l_@@_tmpd_tl {\tl_item:Nn \l_@@_tmpc_tl {2}}
    \tl_put_right:Nn \l_@@_tmpd_tl {\relax}
    \tl_gset_eq:NN \g_@@_smuggle_tl \l_@@_tmpd_tl
  }
  \group_end:
  \tl_use:N \g_@@_smuggle_tl
}

\ExplSyntaxOff
%    \end{macrocode}
% \iffalse
%</tikzspath3>
% \fi
%
% \iffalse
%<*calligraphy>
% \fi
%
% \section{The Calligraphy Package}
%
%    \begin{macrocode}
%<@@=cal>
%    \end{macrocode}
%
% \subsection{Initialisation}
%    \begin{macrocode}
\RequirePackage{spath3}
\ExplSyntaxOn

\tl_new:N \l_@@_tmpa_tl
\tl_new:N \l_@@_tmpb_tl
\tl_new:N \l_@@_tmpc_tl
\tl_new:N \l_@@_tmpd_tl
\tl_new:N \l_@@_tmp_path_tl
\tl_new:N \l_@@_tmp_rpath_tl
\tl_new:N \l_@@_tmp_patha_tl
\seq_new:N \l_@@_tmpa_seq
\int_new:N \l_@@_tmpa_int
\int_new:N \l_@@_tmpb_int
\int_new:N \g_@@_path_component_int
\int_new:N \l_@@_label_int
\dim_new:N \l_@@_tmpa_dim
\dim_new:N \l_@@_tmpb_dim
\dim_new:N \l_@@_tmpc_dim
\dim_new:N \l_@@_tmpd_dim
\dim_new:N \l_@@_tmpe_dim
\dim_new:N \l_@@_tmpf_dim
\dim_new:N \l_@@_tmpg_dim
\dim_new:N \l_@@_tmph_dim
\bool_new:N \l_@@_annotate_bool
\bool_new:N \l_@@_taper_start_bool
\bool_new:N \l_@@_taper_end_bool
\bool_new:N \l_@@_taperable_bool
\dim_new:N \l_@@_taper_width_dim
\dim_new:N \l_@@_line_width_dim

\bool_set_true:N \l_@@_taper_start_bool
\bool_set_true:N \l_@@_taper_end_bool

\cs_generate_variant:Nn \tl_put_right:Nn {Nv}

\msg_new:nnn { calligraphy } { undefined pen } { The~ pen~ "#1"~ is~ not~ defined. }
%    \end{macrocode}
%
% \subsection{TikZ Keys}
%
% The public interface to this package is through TikZ keys and styles.
%    \begin{macrocode}
\tikzset{
  define~pen/.code={
    \tikzset{pen~name=#1}
    \pgf@relevantforpicturesizefalse
    \tikz@addmode{
      \pgfsyssoftpath@getcurrentpath\l_@@_tmpa_tl
      \spath_components_to_seq:NV \l_@@_tmpa_seq \l_@@_tmpa_tl
      \seq_gset_eq:cN {g_@@_pen_\pgfkeysvalueof{/tikz/pen~name}_seq} \l_@@_tmpa_seq
      \pgfusepath{discard}%
    }
  },
  define~pen/.default={default},
  use~pen/.code={
    \tikzset{pen~name=#1}
    \int_gzero:N \g_@@_path_component_int
    \cs_set_eq:NN \pgfpathmoveto \cal_moveto:n
    \tikz@addmode{
      \pgfsyssoftpath@getcurrentpath\l_@@_tmpa_tl
      \spath_components_to_seq:NV \l_@@_tmpa_seq \l_@@_tmpa_tl
      \tl_if_exist:cTF {g_@@_pen_\pgfkeysvalueof{/tikz/pen~name}_seq}
      {
        \cal_path_create:Nc \l_@@_tmpa_seq {g_@@_pen_\pgfkeysvalueof{/tikz/pen~name}_seq}
      }
      {
        \msg_warning:nnx { calligraphy } { undefined pen } { \pgfkeysvalueof{/tikz/pen~name} }
      }
    }
  },
  use~pen/.default={default},
  pen~name/.initial={default},
  copperplate/.style={pen~name=copperplate},
  pen~colour/.initial={black},
  weight/.is~choice,
  weight/heavy/.style={
    line~width=\pgfkeysvalueof{/tikz/heavy~line~width},
    taper~width=\pgfkeysvalueof{/tikz/light~line~width},
  },
  weight/light/.style={
    line~width=\pgfkeysvalueof{/tikz/light~line~width},
    taper~width=0pt,
  },
  heavy/.style={
    weight=heavy
  },
  light/.style={
    weight=light
  },
  heavy~line~width/.initial=2pt,
  light~line~width/.initial=1pt,
  taper/.is~choice,
  taper/.default=both,
  taper/none/.style={
    taper~start=false,
    taper~end=false,
  },
  taper/both/.style={
    taper~start=true,
    taper~end=true,
  },
  taper/start/.style={
    taper~start=true,
    taper~end=false,
  },
  taper/end/.style={
    taper~start=false,
    taper~end=true,
  },
  taper~start/.code={
    \tl_if_eq:nnTF {#1} {true}
    {
      \bool_set_true:N \l_@@_taper_start_bool
    }
    {
      \bool_set_false:N \l_@@_taper_start_bool
    }
  },
  taper~start/.default={true},
  taper~end/.code={
    \tl_if_eq:nnTF {#1} {true}
    {
      \bool_set_true:N \l_@@_taper_end_bool
    }
    {
      \bool_set_false:N \l_@@_taper_end_bool
    }
  },
  taper~end/.default={true},
  taper~width/.code={\dim_set:Nn \l_@@_taper_width_dim {#1}},
  nib~style/.code~2~args={
    \tl_clear_new:c {l_@@_nib_style_#1}
    \tl_set:cn {l_@@_nib_style_#1} {#2}
  },
  stroke~style/.code~2~args={
    \tl_clear_new:c {l_@@_stroke_style_#1}
    \tl_set:cn {l_@@_stroke_style_#1} {#2}
  },
  this~stroke~style/.code={
    \tl_clear_new:c {l_@@_stroke_inline_style_ \int_use:N \g_@@_path_component_int}
    \tl_set:cn {l_@@_stroke_inline_style_ \int_use:N \g_@@_path_component_int} {#1}
  },
  annotate/.style={
    annotate~if,
    annotate~reset,
    annotation~style/.update~value={#1},
  },
  annotate~if/.default={true},
  annotate~if/.code={
    \tl_if_eq:nnTF {#1} {true}
    {
      \bool_set_true:N \l_@@_annotate_bool
    }
    {
      \bool_set_false:N \l_@@_annotate_bool
    }
  },
  annotate~reset/.code={
    \int_gzero:N \l_@@_label_int
  },
  annotation~style/.initial={draw,->},
  annotation~shift/.initial={(0,1ex)},
  every~annotation~node/.initial={anchor=south~west},
  annotation~node~style/.code~2~args={
    \tl_set:cn {l_@@_annotation_style_ #1 _tl}{#2}
  },
  tl~use:N/.code={
    \exp_args:NV \pgfkeysalso #1
  },
  tl~use:c/.code={
    \tl_if_exist:cT {#1}
    {
      \exp_args:Nv \pgfkeysalso {#1}
    }
  },
  /handlers/.update~style/.code={
    \tl_if_eq:nnF {#1} {\pgfkeysnovalue}
    {
      \pgfkeys{\pgfkeyscurrentpath/.code=\pgfkeysalso{#1}}
    }
  },
  /handlers/.update~value/.code={
    \tl_if_eq:nnF {#1} {\pgfkeysnovalue}
    {
      \pgfkeyssetvalue{\pgfkeyscurrentpath}{#1}
    }
  },
}
%    \end{macrocode}
%
% Some wrappers around the TikZ keys.
%    \begin{macrocode}
\NewDocumentCommand \pen { O{} }
{
  \path[define~ pen,every~ calligraphy~ pen/.try,#1]
}

\NewDocumentCommand \definepen { O{} }
{
  \tikz \path[define~ pen,every~ calligraphy~ pen/.try,#1]
}

\NewDocumentCommand \calligraphy { O{} }
{
  \path[use~ pen,every~ calligraphy/.try,#1]
}
%    \end{macrocode}
%
% \subsection{The Path Creation}
%
% \begin{macro}[internal]{\cal_path_create:NN}
% This is the main command for creating the calligraphic paths.
% First argument is the given path
% Second argument is the pen path
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \cal_path_create:NN #1#2
{
  \int_zero:N \l_@@_tmpa_int
  \seq_map_inline:Nn #1
  {
    \int_compare:nT {\tl_count:n {##1} > 3}
    {
      
      \int_incr:N \l_@@_tmpa_int
      \int_zero:N \l_@@_tmpb_int

      \tl_set:Nn \l_@@_tmp_path_tl {##1}
      \spath_open:N \l_@@_tmp_path_tl
      \spath_reverse:NV \l_@@_tmp_rpath_tl \l_@@_tmp_path_tl 

      \seq_map_inline:Nn #2
      {
        \int_incr:N \l_@@_tmpb_int
        \group_begin:
        \pgfsys@beginscope
        \cal_apply_style:c {l_@@_stroke_style_ \int_use:N \l_@@_tmpa_int}
        \cal_apply_style:c {l_@@_stroke_inline_style_ \int_use:N \l_@@_tmpa_int}
        \cal_apply_style:c {l_@@_nib_style_ \int_use:N \l_@@_tmpb_int}

        \spath_initialpoint:Nn \l_@@_tmpa_tl {####1}
        \tl_set_eq:NN \l_@@_tmp_patha_tl \l_@@_tmp_path_tl
        \spath_translate:NV \l_@@_tmp_patha_tl \l_@@_tmpa_tl

        \int_compare:nTF {\tl_count:n {####1} == 3}
        {
          \cal_at_least_three:N \l_@@_tmp_patha_tl
          \spath_protocol_path:V \l_@@_tmp_patha_tl

          \tikz@options
          \dim_set:Nn \l_@@_line_width_dim {\pgflinewidth}
          \cal_maybe_taper:N \l_@@_tmp_patha_tl
        }
        {
          \spath_weld:Nn \l_@@_tmp_patha_tl {####1}
          \spath_weld:NV \l_@@_tmp_patha_tl \l_@@_tmp_rpath_tl
          \spath_reverse:Nn \l_@@_tmp_rpathb_tl {####1}
          \spath_weld:NV \l_@@_tmp_patha_tl \l_@@_tmp_rpathb_tl

          \tl_clear:N \l_@@_tmpa_tl
          \tl_set:Nn \l_@@_tmpa_tl {fill=\pgfkeysvalueof{/tikz/pen~colour},draw=none}
          \tl_if_exist:cT  {l_@@_stroke_style_ \int_use:N \l_@@_tmpa_int}
          {
            \tl_put_right:Nv \l_@@_tmpa_tl {l_@@_stroke_style_ \int_use:N \l_@@_tmpa_int}
          }
          \tl_if_exist:cT  {l_@@_stroke_inline_style_ \int_use:N \l_@@_tmpa_int}
          {
            \tl_put_right:Nn \l_@@_tmpa_tl {,}
            \tl_put_right:Nv \l_@@_tmpa_tl {l_@@_stroke_inline_style_ \int_use:N \l_@@_tmpa_int}
          }
          \tl_if_exist:cT  {l_@@_nib_style_ \int_use:N \l_@@_tmpb_int}
          {
            \tl_put_right:Nn \l_@@_tmpa_tl {,}
            \tl_put_right:Nv \l_@@_tmpa_tl {l_@@_nib_style_ \int_use:N \l_@@_tmpb_int}
          }
          \spath_tikz_path:VV \l_@@_tmpa_tl \l_@@_tmp_patha_tl

        }
        \pgfsys@endscope
        \group_end:
      }

      \bool_if:NT \l_@@_annotate_bool
      {
        \seq_get_right:NN #2 \l_@@_tmpa_tl
        \spath_finalpoint:NV \l_@@_tmpa_tl \l_@@_tmpa_tl
        \spath_translate:NV \l_@@_tmp_path_tl \l_@@_tmpa_tl
        \tikz@scan@one@point\pgfutil@firstofone\pgfkeysvalueof{/tikz/annotation~shift}

        \spath_translate:Nnn \l_@@_tmp_path_tl {\pgf@x} {\pgf@y}
      
        \pgfkeysgetvalue{/tikz/annotation~style}{\l_@@_tmpa_tl}
        \spath_tikz_path:VV \l_@@_tmpa_tl \l_@@_tmp_path_tl

        \spath_finalpoint:NV \l_@@_tmpa_tl \l_@@_tmp_path_tl

        \exp_last_unbraced:NV \pgfqpoint \l_@@_tmpa_tl
        \begin{scope}[reset~ cm]
        \node[every~annotation~node/.try,tl~use:c =  {l_@@_annotation_style_ \int_use:N \l_@@_tmpa_int _tl}] at (\pgf@x,\pgf@y) {\int_use:N \l_@@_tmpa_int};
        \end{scope}
      }
    }
  }
}
\cs_generate_variant:Nn \cal_path_create:NN {Nc}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\cal_moveto:n}
% When creating the path, we need to keep track of the number of components so that we can apply styles accordingly.
%    \begin{macrocode}
\cs_new_eq:NN \cal_orig_moveto:n \pgfpathmoveto
\cs_new_nopar:Npn \cal_moveto:n #1
{
  \int_gincr:N \g_@@_path_component_int
  \cal_orig_moveto:n {#1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\cal_apply_style:N}
% Interface for applying \Verb+\tikzset+ to a token list.
%    \begin{macrocode}
\cs_new_nopar:Npn \cal_apply_style:N #1
{
  \tl_if_exist:NT #1 {
    \exp_args:NV \tikzset #1
  }
}
\cs_generate_variant:Nn \cal_apply_style:N {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\cal_at_least_three:Nn}
% A tapered path has to have at least three components.
% This figures out if it is necessary and sets up the splitting.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \cal_at_least_three:Nn #1#2
{
  \spath_reallength:Nn \l_@@_tmpa_int {#2}
  \tl_clear:N \l_@@_tmpb_tl
  \tl_set:Nn \l_@@_tmpb_tl {#2}
  \int_compare:nTF {\l_@@_tmpa_int = 1}
  {
    \spath_split_at:Nn \l_@@_tmpb_tl {2/3}
    \spath_split_at:Nn \l_@@_tmpb_tl {1/2}
  }
  {
    \int_compare:nT {\l_@@_tmpa_int = 2}
    {
      \spath_split_at:Nn \l_@@_tmpb_tl {1.5}
      \spath_split_at:Nn \l_@@_tmpb_tl {.5}
    }
  }
  \tl_set_eq:NN #1 \l_@@_tmpb_tl
}
\cs_generate_variant:Nn \cal_at_least_three:Nn {NV}
\cs_new_protected_nopar:Npn \cal_at_least_three:N #1
{
  \cal_at_least_three:NV #1#1
}
\cs_generate_variant:Nn \cal_at_least_three:N {c}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\cal_maybe_taper:N}
% Possibly tapers the path, depending on the booleans.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \cal_maybe_taper:N #1
{
  \tl_set_eq:NN \l_@@_tmpa_tl #1

  \bool_if:NT \l_@@_taper_start_bool
  {

    \dim_set:Nn \l_@@_tmpa_dim {\tl_item:Nn \l_@@_tmpa_tl {2}}
    \dim_set:Nn \l_@@_tmpb_dim {\tl_item:Nn \l_@@_tmpa_tl {3}}
    \tl_set:Nx \l_@@_tmpb_tl {\tl_item:Nn \l_@@_tmpa_tl {4}}

    \tl_case:NnF \l_@@_tmpb_tl
    {
      \c_spath_lineto_tl
      {

        \bool_set_true:N \l_@@_taperable_bool
        \dim_set:Nn \l_@@_tmpg_dim {\tl_item:Nn \l_@@_tmpa_tl {5}}
        \dim_set:Nn \l_@@_tmph_dim {\tl_item:Nn \l_@@_tmpa_tl {6}}
        \dim_set:Nn \l_@@_tmpc_dim {(2\l_@@_tmpa_dim + \l_@@_tmpg_dim)/3}
        \dim_set:Nn \l_@@_tmpd_dim {(2\l_@@_tmpb_dim + \l_@@_tmph_dim)/3}
        \dim_set:Nn \l_@@_tmpe_dim {(\l_@@_tmpa_dim + 2\l_@@_tmpg_dim)/3}
        \dim_set:Nn \l_@@_tmpf_dim {(\l_@@_tmpb_dim + 2\l_@@_tmph_dim)/3}
        \prg_replicate:nn {4}
        {
          \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        }
        \tl_put_left:NV \l_@@_tmpa_tl \c_spath_moveto_tl
      }
      \c_spath_curvetoa_tl
      {
        \bool_set_true:N \l_@@_taperable_bool
        \dim_set:Nn \l_@@_tmpc_dim {\tl_item:Nn \l_@@_tmpa_tl {5}}
        \dim_set:Nn \l_@@_tmpd_dim {\tl_item:Nn \l_@@_tmpa_tl {6}}
        \dim_set:Nn \l_@@_tmpe_dim {\tl_item:Nn \l_@@_tmpa_tl {8}}
        \dim_set:Nn \l_@@_tmpf_dim {\tl_item:Nn \l_@@_tmpa_tl {9}}
        \dim_set:Nn \l_@@_tmpg_dim {\tl_item:Nn \l_@@_tmpa_tl {11}}
        \dim_set:Nn \l_@@_tmph_dim {\tl_item:Nn \l_@@_tmpa_tl {12}}
        \prg_replicate:nn {10}
        {
          \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        }
        \tl_put_left:NV \l_@@_tmpa_tl \c_spath_moveto_tl
      }
    }
    {
      \bool_set_false:N \l_@@_taperable_bool
    }
    
    \bool_if:NT \l_@@_taperable_bool
    {
      \@@_taper_aux:
    }
    
  }

  \bool_if:NT \l_@@_taper_end_bool
  {

    \dim_set:Nn \l_@@_tmpa_dim {\tl_item:Nn \l_@@_tmpa_tl {-2}}
    \dim_set:Nn \l_@@_tmpb_dim {\tl_item:Nn \l_@@_tmpa_tl {-1}}
    \tl_set:Nx \l_@@_tmpb_tl {\tl_item:Nn \l_@@_tmpa_tl {-3}}

    \tl_case:NnF \l_@@_tmpb_tl
    {
      \c_spath_lineto_tl
      {

        \bool_set_true:N \l_@@_taperable_bool
        \dim_set:Nn \l_@@_tmpg_dim {\tl_item:Nn \l_@@_tmpa_tl {-5}}
        \dim_set:Nn \l_@@_tmph_dim {\tl_item:Nn \l_@@_tmpa_tl {-4}}
        \dim_set:Nn \l_@@_tmpc_dim {(2\l_@@_tmpa_dim + \l_@@_tmpg_dim)/3}
        \dim_set:Nn \l_@@_tmpd_dim {(2\l_@@_tmpb_dim + \l_@@_tmph_dim)/3}
        \dim_set:Nn \l_@@_tmpe_dim {(\l_@@_tmpa_dim + 2\l_@@_tmpg_dim)/3}
        \dim_set:Nn \l_@@_tmpf_dim {(\l_@@_tmpb_dim + 2\l_@@_tmph_dim)/3}
        \tl_reverse:N \l_@@_tmpa_tl
        \prg_replicate:nn {3}
        {
          \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        }
        \tl_reverse:N \l_@@_tmpa_tl
      }
      \c_spath_curveto_tl
      {
        \bool_set_true:N \l_@@_taperable_bool
        \dim_set:Nn \l_@@_tmpc_dim {\tl_item:Nn \l_@@_tmpa_tl {-5}}
        \dim_set:Nn \l_@@_tmpd_dim {\tl_item:Nn \l_@@_tmpa_tl {-4}}
        \dim_set:Nn \l_@@_tmpe_dim {\tl_item:Nn \l_@@_tmpa_tl {-8}}
        \dim_set:Nn \l_@@_tmpf_dim {\tl_item:Nn \l_@@_tmpa_tl {-7}}
        \dim_set:Nn \l_@@_tmpg_dim {\tl_item:Nn \l_@@_tmpa_tl {-11}}
        \dim_set:Nn \l_@@_tmph_dim {\tl_item:Nn \l_@@_tmpa_tl {-10}}
        \tl_reverse:N \l_@@_tmpa_tl
        \prg_replicate:nn {9}
        {
          \tl_set:Nx \l_@@_tmpa_tl {\tl_tail:N \l_@@_tmpa_tl}
        }
        \tl_reverse:N \l_@@_tmpa_tl
      }
    }
    {
      \bool_set_false:N \l_@@_taperable_bool
    }
    
    \bool_if:NT \l_@@_taperable_bool
    {
      \@@_taper_aux:
    }
    
  }

  \pgfsyssoftpath@setcurrentpath\l_@@_tmpa_tl
  \pgfsetstrokecolor{\pgfkeysvalueof{/tikz/pen~colour}}
  \pgfusepath{stroke}

}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\@@_taper_aux:}
% Auxiliary macro to avoid unnecessary code duplication.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_taper_aux:
{
  \tl_clear:N \l_@@_tmpb_tl
  \tl_put_right:NV \l_@@_tmpb_tl \c_spath_moveto_tl

  \fp_set:Nn \l_@@_tmpa_fp
  {
    \l_@@_tmpd_dim - \l_@@_tmpb_dim
  }
  \fp_set:Nn \l_@@_tmpb_fp
  {
    \l_@@_tmpa_dim - \l_@@_tmpc_dim
  }
  \fp_set:Nn \l_@@_tmpe_fp
  {
    (\l_@@_tmpa_fp^2 + \l_@@_tmpb_fp^2)^.5
  }
  
  \fp_set:Nn \l_@@_tmpa_fp {.5*\l_@@_taper_width_dim *     \l_@@_tmpa_fp / \l_@@_tmpe_fp}
  \fp_set:Nn \l_@@_tmpb_fp {.5*\l_@@_taper_width_dim *     \l_@@_tmpb_fp / \l_@@_tmpe_fp}

  \fp_set:Nn \l_@@_tmpc_fp
  {
    \l_@@_tmph_dim - \l_@@_tmpf_dim
  }
  \fp_set:Nn \l_@@_tmpd_fp
  {
    \l_@@_tmpe_dim - \l_@@_tmpg_dim
  }
  \fp_set:Nn \l_@@_tmpe_fp
  {
    (\l_@@_tmpc_fp^2 + \l_@@_tmpd_fp^2)^.5
  }

  \fp_set:Nn \l_@@_tmpc_fp {.5*\l_@@_line_width_dim * \l_@@_tmpc_fp / \l_@@_tmpe_fp}
  \fp_set:Nn \l_@@_tmpd_fp {.5*\l_@@_line_width_dim * \l_@@_tmpd_fp / \l_@@_tmpe_fp}

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpa_dim}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpb_fp +             \l_@@_tmpb_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \c_spath_curvetoa_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpc_dim}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpb_fp + \l_@@_tmpd_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \c_spath_curvetob_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpc_fp + \l_@@_tmpe_dim}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpd_fp + \l_@@_tmpf_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \c_spath_curveto_tl
  
  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpc_fp + \l_@@_tmpg_dim}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpd_fp + \l_@@_tmph_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \c_spath_curvetoa_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpc_fp + \l_@@_tmpg_dim - \fp_to_dim:n{ 1.32 * \l_@@_tmpd_fp}}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpd_fp + \l_@@_tmph_dim + \fp_to_dim:n {1.32* \l_@@_tmpc_fp}}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \c_spath_curvetob_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpc_fp + \l_@@_tmpg_dim - \fp_to_dim:n {1.32 * \l_@@_tmpd_fp}}}
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpd_fp + \l_@@_tmph_dim + \fp_to_dim:n {1.32 * \l_@@_tmpc_fp}}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \c_spath_curveto_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpc_fp + \l_@@_tmpg_dim}}
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpd_fp + \l_@@_tmph_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \c_spath_curvetoa_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpc_fp + \l_@@_tmpe_dim}}
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpd_fp + \l_@@_tmpf_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \c_spath_curvetob_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpc_dim}}
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpb_fp + \l_@@_tmpd_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \c_spath_curveto_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpa_dim}}
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpb_fp + \l_@@_tmpb_dim}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \c_spath_curvetoa_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpa_dim + \fp_to_dim:n{ 1.32 * \l_@@_tmpb_fp}}}
    {\dim_eval:n { -\fp_to_dim:N \l_@@_tmpb_fp + \l_@@_tmpb_dim - \fp_to_dim:n {1.32* \l_@@_tmpa_fp}}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \c_spath_curvetob_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpa_dim + \fp_to_dim:n {1.32 * \l_@@_tmpb_fp}}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpb_fp + \l_@@_tmpb_dim - \fp_to_dim:n {1.32 * \l_@@_tmpa_fp}}}
  }

  \tl_put_right:NV \l_@@_tmpb_tl \c_spath_curveto_tl

  \tl_put_right:Nx \l_@@_tmpb_tl
  {
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpa_fp + \l_@@_tmpa_dim}}
    {\dim_eval:n { \fp_to_dim:N \l_@@_tmpb_fp +             \l_@@_tmpb_dim}}
  }

  \pgfsyssoftpath@setcurrentpath\l_@@_tmpb_tl
  \pgfsetfillcolor{\pgfkeysvalueof{/tikz/pen~colour}}
  \pgfusepath{fill}
}
%    \end{macrocode}
% \end{macro}
%
% Defines a copperplate pen.
%    \begin{macrocode}
\tl_set:Nn \l_@@_tmpa_tl {\pgfsyssoftpath@movetotoken{0pt}{0pt}}
\spath_components_to_seq:NV \g_@@_pen_copperplate_seq \l_@@_tmpa_tl
%    \end{macrocode}
%
% \begin{macro}{\CopperplatePath}
% This is used in the decorations section to convert a path to a copperplate path.
%    \begin{macrocode}
\DeclareDocumentCommand \CopperplatePath { m }
{
  \spath_components_to_seq:NV \l_@@_tmpa_seq #1
  \cal_path_create:NN \l_@@_tmpa_seq \g_@@_pen_copperplate_seq
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
%
% \subsection{Decorations}
%
% If a decoration library is loaded we define some decorations that use the calligraphy library, specifically the copperplate pen with its tapering.
%
% First, a brace decoration.
%    \begin{macrocode}
\expandafter\ifx\csname pgfdeclaredecoration\endcsname\relax
\else
\pgfdeclaredecoration{calligraphic brace}{brace}
{
  \state{brace}[width=+\pgfdecoratedremainingdistance,next state=final]
  {
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}
    \pgfpathmoveto{\pgfpointorigin}
    \pgfpathcurveto
    {\pgfqpoint{.15\pgfdecorationsegmentamplitude}{.3\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
    {
      \pgftransformxshift{+\pgfdecorationsegmentaspect\pgfdecoratedremainingdistance}
      \pgfpathlineto{\pgfqpoint{-\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{-.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{-.15\pgfdecorationsegmentamplitude}{.7\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{0\pgfdecorationsegmentamplitude}{1\pgfdecorationsegmentamplitude}}
      \pgfpathmoveto{\pgfqpoint{0\pgfdecorationsegmentamplitude}{1\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{.15\pgfdecorationsegmentamplitude}{.7\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
    }
    {
      \pgftransformxshift{+\pgfdecoratedremainingdistance}
      \pgfpathlineto{\pgfqpoint{-\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{-.5\pgfdecorationsegmentamplitude}{.5\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{-.15\pgfdecorationsegmentamplitude}{.3\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{0pt}{0pt}}
    }
    \tikzset{
      taper width=.5\pgflinewidth,
      taper
    }%
    \pgfsyssoftpath@getcurrentpath\cal@tmp@path
    \CopperplatePath{\cal@tmp@path}
  }
  \state{final}{}
}
%    \end{macrocode}
%
% The second is a straightened parenthesis (so that when very large it doesn't bow out too far).
%    \begin{macrocode}
\pgfdeclaredecoration{calligraphic straight parenthesis}{brace}
{
  \state{brace}[width=+\pgfdecoratedremainingdistance,next state=final]
  {
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}
    \pgfpathmoveto{\pgfpointorigin}
    \pgfpathcurveto
    {\pgfqpoint{.76604\pgfdecorationsegmentamplitude}{.64279\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{2.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{3.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
    {
      \pgftransformxshift{+\pgfdecoratedremainingdistance}
      \pgfpathlineto{\pgfqpoint{-3.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
      \pgfpathcurveto
      {\pgfqpoint{-2.3333\pgfdecorationsegmentamplitude}{\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{-.76604\pgfdecorationsegmentamplitude}{.64279\pgfdecorationsegmentamplitude}}
      {\pgfqpoint{0pt}{0pt}}
    }
    \tikzset{
      taper width=.5\pgflinewidth,
      taper
    }%
    \pgfsyssoftpath@getcurrentpath\cal@tmp@path
    \CopperplatePath{\cal@tmp@path}
  }
  \state{final}{}%
}
%    \end{macrocode}
%
% The third is a curved parenthesis.
%    \begin{macrocode}
\pgfdeclaredecoration{calligraphic curved parenthesis}{brace}
{
  \state{brace}[width=+\pgfdecoratedremainingdistance,next state=final]
  {
    \pgfsyssoftpath@setcurrentpath{\pgfutil@empty}
    \pgfpathmoveto{\pgfpointorigin}
    \pgf@xa=\pgfdecoratedremainingdistance\relax
    \advance\pgf@xa by -1.5890\pgfdecorationsegmentamplitude\relax
    \edef\cgrphy@xa{\the\pgf@xa}
    \pgfpathcurveto
    {\pgfqpoint{1.5890\pgfdecorationsegmentamplitude}{1.3333\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{\cgrphy@xa}{1.3333\pgfdecorationsegmentamplitude}}
    {\pgfqpoint{\pgfdecoratedremainingdistance}{0pt}}
    \tikzset{
      taper width=.5\pgflinewidth,
      taper
    }%
    \pgfsyssoftpath@getcurrentpath\cal@tmp@path
    \CopperplatePath{\cal@tmp@path}
  }
  \state{final}{}%
}
%    \end{macrocode}
% End the conditional for if pgfdecoration module is loaded
%    \begin{macrocode}
\fi
%    \end{macrocode}
% \iffalse
%</calligraphy>
% \fi
% 
%
% \iffalse
%<*knots>
% \fi
%%
% \section{Drawing Knots}
%
%    \begin{macrocode}
%<@@=knot>
%    \end{macrocode}
%
% \subsection{Initialisation}
%
% We load the \Verb+spath3+ library and the \Verb+intersections+ TikZ library.
% Then we get going.
%    \begin{macrocode}
\RequirePackage{spath3}
\usetikzlibrary{intersections,spath3}

\ExplSyntaxOn

\tl_new:N \l__knot_tmpa_tl
\tl_new:N \l__knot_tmpb_tl
\tl_new:N \l__knot_tmpc_tl
\tl_new:N \l__knot_tmpd_tl
\tl_new:N \l__knot_tmpe_tl
\tl_new:N \l__knot_tmpf_tl
\tl_new:N \l__knot_tmpg_tl
\tl_new:N \l__knot_redraws_tl
\tl_new:N \l__knot_clip_width_tl
\tl_new:N \l__knot_name_tl
\tl_new:N \l__knot_node_tl
\tl_new:N \l__knot_aux_tl
\tl_new:N \l__knot_auxa_tl

\seq_new:N \l_@@_segments_seq

\int_new:N \l__knot_tmpa_int
\int_new:N \l__knot_strands_int
\int_new:N \l__knot_intersections_int
\int_new:N \l__knot_filaments_int
\int_new:N \l__knot_component_start_int

\dim_new:N \l__knot_tmpa_dim
\dim_new:N \l__knot_tmpb_dim
\dim_new:N \l__knot_tmpc_dim
\dim_new:N \l__knot_tolerance_dim
\dim_new:N \l__knot_clip_bg_radius_dim
\dim_new:N \l__knot_clip_draw_radius_dim

\bool_new:N \l__knot_draft_bool
\bool_new:N \l__knot_ignore_ends_bool
\bool_new:N \l__knot_self_intersections_bool
\bool_new:N \l__knot_splits_bool
\bool_new:N \l__knot_super_draft_bool

\bool_new:N \l__knot_prepend_prev_bool
\bool_new:N \l__knot_append_next_bool
\bool_new:N \l__knot_skip_bool
\bool_new:N \l__knot_save_bool

\seq_new:N \g__knot_nodes_seq

\bool_set_true:N \l__knot_ignore_ends_bool
%    \end{macrocode}
%
% Configuration is via TikZ keys and styles.
%    \begin{macrocode}
\tikzset{
  spath/prefix/knot/.style={
    spath/set~ prefix=knot strand,
  },
  spath/suffix/knot/.style={
    spath/set~ suffix={},
  },
  knot/.code={
    \tl_if_eq:nnTF {#1} {none}
    {
      \tikz@addmode{\tikz@mode@doublefalse}
    }
    {
      \tikz@addmode{\tikz@mode@doubletrue}
      \tl_if_eq:nnTF {\pgfkeysnovalue} {#1}
      {
        \tikz@addoption{\pgfsetinnerstrokecolor{.}}
      }
      {
        \pgfsetinnerstrokecolor{#1}
      }
      \tikz@addoption{
        \pgfsetstrokecolor{knotbg}
      }
      \tl_set:Nn \tikz@double@setup{
        \pgfsetinnerlinewidth{\pgflinewidth}
        \pgfsetlinewidth{\dim_eval:n {\tl_use:N \l__knot_gap_tl \pgflinewidth}}
      }
    }
  },
  knot~ gap/.store~ in=\l__knot_gap_tl,
  knot~ gap=3,
  knot~ diagram/.is~family,
  knot~ diagram/.unknown/.code={
    \tl_set_eq:NN \l__knot_tmpa_tl \pgfkeyscurrentname
    \pgfkeysalso{
      /tikz/\l__knot_tmpa_tl=#1
    }
  },
  background~ colour/.code={%
    \colorlet{knotbg}{#1}%
  },
  background~ color/.code={%
    \colorlet{knotbg}{#1}%
  },
  background~ colour=white,
  knot~ diagram,
  name/.store~ in=\l__knot_name_tl,
  name={knot},
  save~ intersections/.is~ choice,
  save~ intersections/.default=true,
  save~ intersections/true/.code={
    \bool_set_true:N \l__knot_save_bool
  },
  save~ intersections/false/.code={
    \bool_set_false:N \l__knot_save_bool
  },
  every~ strand/.style={draw},
  ignore~ endpoint~ intersections/.code={
    \tl_if_eq:nnTF {#1} {true}
    {
      \bool_set_true:N \l__knot_ignore_ends_bool
    }
    {
      \bool_set_false:N \l__knot_ignore_ends_bool
    }
  },
  ignore~ endpoint~ intersections/.default=true,
  consider~ self~ intersections/.is~choice,
  consider~ self~ intersections/true/.code={
    \bool_set_true:N \l__knot_self_intersections_bool
    \bool_set_true:N \l__knot_splits_bool
  },
  consider~ self~ intersections/false/.code={
    \bool_set_false:N \l__knot_self_intersections_bool
    \bool_set_false:N \l__knot_splits_bool
  },
  consider~ self~ intersections/no~ splits/.code={
    \bool_set_true:N \l__knot_self_intersections_bool
    \bool_set_false:N \l__knot_splits_bool
  },
  consider~ self~ intersections/.default={true},
  clip~ radius/.code={
    \dim_set:Nn \l__knot_clip_bg_radius_dim {#1}
    \dim_set:Nn \l__knot_clip_draw_radius_dim {#1+2pt}
  },
  clip~ draw~ radius/.code={
    \dim_set:Nn \l__knot_clip_draw_radius_dim {#1}
  },
  clip~ background~ radius/.code={
    \dim_set:Nn \l__knot_clip_bg_radius_dim {#1}
  },
  clip~ radius=10pt,
  end~ tolerance/.code={
    \dim_set:Nn \l__knot_tolerance_dim {#1}
  },
  end~ tolerance=14pt,
  clip/.style={
    clip
  },
  background~ clip/.style={
    clip
  },
  clip~ width/.code={
    \tl_set:Nn \l__knot_clip_width_tl {#1}
  },
  clip~ width=3,
  flip~ crossing/.code={%
    \tl_clear_new:c {l__knot_crossing_#1}
    \tl_set:cn {l__knot_crossing_#1} {x}
  },
  ignore~ crossing/.code={%
    \tl_clear_new:c {l__knot_ignore_crossing_#1}
    \tl_set:cn {l__knot_ignore_crossing_#1} {x}
  },
  draft~ mode/.is~ choice,
  draft~ mode/off/.code={%
    \bool_set_false:N \l__knot_draft_bool
    \bool_set_false:N \l__knot_super_draft_bool
  },
  draft~ mode/crossings/.code={%
    \bool_set_true:N \l__knot_draft_bool
    \bool_set_false:N \l__knot_super_draft_bool
  },
  draft~ mode/strands/.code={%
    \bool_set_true:N \l__knot_draft_bool
    \bool_set_true:N \l__knot_super_draft_bool
  },
  draft/.is~ family,
  draft,
  crossing~ label/.style={
    overlay,
    fill=white,
    fill~ opacity=.5,
    text~ opacity=1,
    text=blue,
    pin~ edge={blue,<-}
  },
  strand~ label/.style={
    overlay,
    circle,
    draw=purple,
    fill=white,
    fill~ opacity=.5,
    text~ opacity=1,
    text=purple,
    inner~ sep=0pt
  },
}
%    \end{macrocode}
%
% Wrapper around \Verb+\tikzset+ for applying keys from a token list, checking for if the given token list exists.
%    \begin{macrocode}
\cs_new_nopar:Npn \knot_apply_style:N #1
{
  \tl_if_exist:NT #1 {
    \exp_args:NV \tikzset #1
  }
}
\cs_generate_variant:Nn \knot_apply_style:N {c}
%    \end{macrocode}
%
%\begin{macro}[internal]{\flipcrossings}
% The user can specify a comma separated list of crossings to flip.
%    \begin{macrocode}
\NewDocumentCommand \flipcrossings {m}
{
  \tikzset{knot~ diagram/flip~ crossing/.list={#1}}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\strand}
% This is how the user specifies a strand of the knot.
%    \begin{macrocode}
\NewDocumentCommand \strand { O{} }
{
  \int_incr:N \l__knot_strands_int
  \tl_clear_new:c {l__knot_options_strand \int_use:N \l__knot_strands_int}
  \tl_set:cn {l__knot_options_strand \int_use:N \l__knot_strands_int} {#1}
  \path[#1,spath/set~ name=knot,spath/save=\int_use:N \l__knot_strands_int]
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{knot}
% This is the wrapper environment that calls the knot generation code.
%    \begin{macrocode}
\NewDocumentEnvironment{knot} { O{} }
{
  \knot_initialise:n {#1}
}
{
  \knot_render:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_initialise:n}
% Set up some stuff before loading in the strands.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_initialise:n #1
{
  \tikzset{knot~ diagram/.cd,every~ knot~ diagram/.try,#1}
  \int_zero:N \l__knot_strands_int
  \tl_clear:N \l__knot_redraws_tl
  \seq_gclear:N \g__knot_nodes_seq
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_render:}
% This is the code that starts the work of rendering the knot.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_render:
{
%    \end{macrocode}
% Start a scope and reset the transformation (since all transformations have already been taken into account when defining the strands).
%    \begin{macrocode}
  \pgfscope
  \pgftransformreset
%    \end{macrocode}
% Loop through the strands drawing each one for the first time.
%    \begin{macrocode}
  \int_step_function:nnnN {1} {1} {\l__knot_strands_int} \knot_draw_strand:n
%    \end{macrocode}
% In super draft mode we don't do anything else.
%    \begin{macrocode} 
  \bool_if:NF \l__knot_super_draft_bool
  {
%    \end{macrocode}
% In draft mode we draw labels at the ends of the strands; this also handles splitting curves to avoid self-intersections of Bezier curves if that's requested.
%    \begin{macrocode}
    \int_step_function:nnnN {1} {1} {\l__knot_strands_int} \knot_draw_labels:n
%    \end{macrocode}
% If we're considering self intersections we need to split the strands into filaments.
%    \begin{macrocode}
    \bool_if:NTF \l__knot_self_intersections_bool
    {
      \knot_split_strands:
      \int_set_eq:NN \l__knot_tmpa_int \l__knot_filaments_int
      \tl_set:Nn \l__knot_prefix_tl {filament}
    }
    {
      \int_set_eq:NN \l__knot_tmpa_int \l__knot_strands_int
      \tl_set:Nn \l__knot_prefix_tl {strand}
    }
%    \end{macrocode}
% Initialise the intersection count.
%    \begin{macrocode}
    \int_gzero:N \l__knot_intersections_int
%    \end{macrocode}
% If in draft mode we label the intersections, otherwise we just stick a coordinate at each one.
%    \begin{macrocode}
    \tl_clear:N \l__knot_node_tl
    \bool_if:NT \l__knot_draft_bool
    {
      \tl_set:Nn \l__knot_node_tl {
        \exp_not:N \node[coordinate,
          pin={[node~ contents={\int_use:N \l__knot_intersections_int},knot~ diagram/draft/crossing~ label, knot~ diagram/draft/crossing~ \int_use:N \l__knot_intersections_int \c_space_tl label/.try]
            }]
      }
    }
%    \end{macrocode}
% This double loop steps through the pieces (strands or filaments) and computes the intersections and does stuff with those.
%    \begin{macrocode}
    \int_step_variable:nnnNn {1} {1} {\l__knot_tmpa_int - 1} \l__knot_tmpa_tl
    {
      \int_step_variable:nnnNn {\tl_use:N \l__knot_tmpa_tl + 1} {1}     {\l__knot_tmpa_int} \l__knot_tmpb_tl
      {
        \knot_intersections:VV \l__knot_tmpa_tl \l__knot_tmpb_tl
      }
    }
%    \end{macrocode}
% If any redraws were requested, do them here.
%    \begin{macrocode}
    \tl_use:N \l__knot_redraws_tl
%    \end{macrocode}
% Draw the crossing nodes
%    \begin{macrocode}
    \seq_use:Nn \g__knot_nodes_seq {}
  }
%    \end{macrocode}
% Close the scope
%    \begin{macrocode}
  \endpgfscope
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_draw_strand:n}
% This renders a strand using the options originally specified.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_draw_strand:n #1
{
  \pgfscope
  \group_begin:
  \spath_bake_round:c {knot strand #1}
  \tl_set:Nn \l_tmpa_tl {knot~ diagram/every~ strand/.try,}
  \tl_put_right:Nv \l_tmpa_tl {l__knot_options_strand #1}
  \tl_put_right:Nn \l_tmpa_tl {,knot~ diagram/only~ when~ rendering/.try,only~ when~ rendering/.try}
  \spath_tikz_path:Vv \l_tmpa_tl {knot strand #1}
  \group_end:
  \endpgfscope
}
\cs_generate_variant:Nn \tl_put_right:Nn {Nv}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_draw_labels:n}
% Draw a label at each end of each strand, if in draft mode.
% Also, if requested, split potentially self intersecting Bezier curves.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_draw_labels:n #1
{
  \bool_if:NT \l__knot_draft_bool
  {
    \spath_finalpoint:Nv \l__knot_tmpb_tl {knot strand #1}
    \dim_set:Nn \l__knot_tmpa_dim {\tl_item:Nn \l__knot_tmpb_tl {1}}
    \dim_set:Nn \l__knot_tmpb_dim {\tl_item:Nn \l__knot_tmpb_tl {2}}
    \node[knot~ diagram/draft/strand~label] at (\l__knot_tmpa_dim,\l__knot_tmpb_dim) {#1};
    \spath_initialpoint:Nv \l__knot_tmpb_tl {knot strand #1}
    \dim_set:Nn \l__knot_tmpa_dim {\tl_item:Nn \l__knot_tmpb_tl {1}}
    \dim_set:Nn \l__knot_tmpb_dim {\tl_item:Nn \l__knot_tmpb_tl {2}}
    \node[knot~ diagram/draft/strand~label] at (\l__knot_tmpa_dim,\l__knot_tmpb_dim) {#1};
  }
  \bool_if:nT {
    \l__knot_self_intersections_bool
    &&
    \l__knot_splits_bool
  }
  {
    \tl_clear:N \l__knot_tmpa_tl
    \spath_segments_to_seq:Nv \l_@@_segments_seq {knot strand #1}
    \seq_map_function:NN \l_@@_segments_seq \knot_split_self_intersects:N
    \tl_set_eq:cN {knot strand #1} \l__knot_tmpa_tl
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_split_self_intersects:N}
% This is the macro that does the split.
% Figuring out whether a Bezier cubic self intersects is apparently a difficult problem so we don't bother.
% We compute a point such that if there is an intersection then it lies on either side of the point.
% I don't recall where the formula came from!
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_split_self_intersects:N #1
{
  \tl_set:Nx \l_@@_tmpc_tl {\tl_item:nn {#1} {4}}
  \tl_case:NnF \l_@@_tmpc_tl
  {
    \c_spath_curvetoa_tl
    {
      \fp_set:Nn \l_tmpa_fp
      {
        (\tl_item:nn {#1} {3} - 3 * \tl_item:nn {#1} {6} + 3 * \tl_item:nn {#1} {9} - \tl_item:nn {#1} {12})
        *
        (3 * \tl_item:nn {#1} {8} - 3 * \tl_item:nn {#1} {11})
        -
        (\tl_item:nn {#1} {2} - 3 * \tl_item:nn {#1} {5} + 3 * \tl_item:nn {#1} {8} - \tl_item:nn {#1} {11})
        *
        (3 * \tl_item:nn {#1} {9} - 3 * \tl_item:nn {#1} {12})
      }
      \fp_set:Nn \l_tmpb_fp
      {
        (\tl_item:nn {#1} {2} - 3 * \tl_item:nn {#1} {5} + 3 * \tl_item:nn {#1} {8} - \tl_item:nn {#1} {11})
        *
        (3 * \tl_item:nn {#1} {6} - 6 * \tl_item:nn {#1} {9} + 3 * \tl_item:nn {#1} {12})
        -
        (\tl_item:nn {#1} {3} - 3 * \tl_item:nn {#1} {6} + 3 * \tl_item:nn {#1} {9} - \tl_item:nn {#1} {12})
        *
        (3 * \tl_item:nn {#1} {5} - 6 * \tl_item:nn {#1} {8} + 3 * \tl_item:nn {#1} {11})
      }
      \fp_compare:nTF
      {
        \l_tmpb_fp != 0
      }
      {
        \fp_set:Nn \l_tmpa_fp {.5 * \l_tmpa_fp / \l_tmpb_fp}
        \fp_compare:nTF
        {
          0 < \l_tmpa_fp && \l_tmpa_fp < 1
        }
        {
          \spath_split_curve:NNVn \l_tmpa_tl \l_tmpb_tl \l_tmpa_fp {#1}
          \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
          \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
          \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
          \tl_set:Nx \l_tmpb_tl {\tl_tail:N \l_tmpb_tl}
          \tl_set:Nx \l_tmpb_tl {\tl_tail:N \l_tmpb_tl}
          \tl_set:Nx \l_tmpb_tl {\tl_tail:N \l_tmpb_tl}
          \tl_put_right:NV \l__knot_tmpa_tl \l_tmpa_tl
          \tl_put_right:NV \l__knot_tmpa_tl \l_tmpb_tl
        }
        {
          \tl_set:Nn \l_tmpa_tl {#1}
          \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
          \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
          \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
          \tl_put_right:NV \l__knot_tmpa_tl \l_tmpa_tl
        }
      }
      {
        \tl_set:Nn \l_tmpa_tl {#1}
        \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
        \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
        \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
        \tl_put_right:NV \l__knot_tmpa_tl \l_tmpa_tl
      }
    }
    \c_spath_lineto_tl
    {
      \tl_set:Nn \l_tmpa_tl {#1}
      \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
      \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
      \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
      \tl_put_right:NV \l__knot_tmpa_tl \l_tmpa_tl
    }
  }
  {
    \tl_put_right:Nn \l__knot_tmpa_tl {#1}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_intersections:nn}
% This computes the intersections of two pieces and steps through them.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_intersections:nn #1#2
{
  \group_begin:
  \tl_set_eq:NN \l__knot_tmpa_tl \l__knot_prefix_tl
  \tl_put_right:Nn \l__knot_tmpa_tl {#1}
  \tl_set_eq:NN \l__knot_tmpb_tl \l__knot_prefix_tl
  \tl_put_right:Nn \l__knot_tmpb_tl {#2}
  \tl_set_eq:Nc \l__knot_tmpc_tl {knot \tl_use:N \l__knot_tmpa_tl}
  \tl_set_eq:Nc \l__knot_tmpd_tl {knot \tl_use:N \l__knot_tmpb_tl}

  \bool_if:nTF {
    \l__knot_save_bool
    &&
    \tl_if_exist_p:c {knot~ intersections~ \tl_use:N \l__knot_name_tl - \tl_use:N \l__knot_tmpa_tl -  \tl_use:N \l__knot_tmpb_tl}
  }
  {
    \tl_use:c {knot~ intersections~ \tl_use:N \l__knot_name_tl - \tl_use:N \l__knot_tmpa_tl -  \tl_use:N \l__knot_tmpb_tl}
  }
  {
\pgfintersectionofpaths{\pgfsetpath\l__knot_tmpc_tl}{\pgfsetpath\l__knot_tmpd_tl}

  }

  \int_compare:nT {\pgfintersectionsolutions > 0}
  {
    \int_step_function:nnnN {1} {1} {\pgfintersectionsolutions} \knot_do_intersection:n
  }

  \knot_save_intersections:VV \l__knot_tmpa_tl \l__knot_tmpb_tl
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_save_intersections:nn}
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_save_intersections:nn #1#2
{
  \bool_if:NT \l__knot_save_bool
  {
    \tl_clear:N \l__knot_aux_tl
    \tl_put_right:Nn \l__knot_aux_tl
    {
      \def\pgfintersectionsolutions
    }
    \tl_put_right:Nx \l__knot_aux_tl
    {
      {\int_eval:n {\pgfintersectionsolutions}}
    }
    \int_compare:nT {\pgfintersectionsolutions > 0}
    {
      \int_step_inline:nnnn {1} {1} {\pgfintersectionsolutions}
      {
        \pgfpointintersectionsolution{##1}
        \dim_set:Nn \l__knot_tmpa_dim {\pgf@x}
        \dim_set:Nn \l__knot_tmpb_dim {\pgf@y}
        \tl_put_right:Nn \l__knot_aux_tl
        {
          \expandafter\def\csname pgfpoint@intersect@solution@##1\endcsname
        }
        \tl_put_right:Nx \l__knot_aux_tl
        {
          {\exp_not:N \pgf@x=\dim_use:N \l__knot_tmpa_dim\exp_not:N\relax\exp_not:N \pgf@y =\dim_use:N \l__knot_tmpb_dim\relax}
        }
      }
      \tl_set:Nn \l__knot_auxa_tl {\expandafter \gdef \csname knot~ intersections~}
      \tl_put_right:Nx \l__knot_auxa_tl {\tl_use:N \l__knot_name_tl - #1 - #2}
      \tl_put_right:Nn \l__knot_auxa_tl {\endcsname}
      \tl_put_right:Nx \l__knot_auxa_tl {{\tl_to_str:N \l__knot_aux_tl}}
      \protected@write\@auxout{}{\tl_to_str:N \l__knot_auxa_tl}
    }
  }
}
\cs_generate_variant:Nn \knot_save_intersections:nn {VV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_do_intersection:n}
% This handles a specific intersection.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_do_intersection:n #1
{
%    \end{macrocode}
% Get the intersection coordinates.
%    \begin{macrocode}
  \pgfpointintersectionsolution{#1}
  \dim_set:Nn \l__knot_tmpa_dim {\pgf@x}
  \dim_set:Nn \l__knot_tmpb_dim {\pgf@y}
%    \end{macrocode}
% If we're dealing with filaments, we can get false positives from the end points.
%    \begin{macrocode}
  \bool_set_false:N \l__knot_skip_bool
  \bool_if:NT \l__knot_self_intersections_bool
  {
%    \end{macrocode}
% If one filament preceded the other, test for the intersection being at the relevant end point.
%    \begin{macrocode}
    \tl_set:Nn \l_tmpa_tl {knot previous}
    \tl_put_right:NV \l_tmpa_tl \l__knot_tmpa_tl
    \tl_set:Nv \l_tmpa_tl \l_tmpa_tl
    \tl_if_eq:NNT \l_tmpa_tl \l__knot_tmpb_tl
    {
      \knot_test_endpoint:VnT \l__knot_tmpb_tl {final point}
      {
        \bool_set_true:N \l__knot_skip_bool
      }
    }

    \tl_set:Nn \l_tmpa_tl {knot previous}
    \tl_put_right:NV \l_tmpa_tl \l__knot_tmpb_tl
    \tl_set:Nv \l_tmpa_tl \l_tmpa_tl
    \tl_if_eq:NNT \l_tmpa_tl \l__knot_tmpa_tl
    {
      \knot_test_endpoint:VnT \l__knot_tmpa_tl {final point}
      {
        \bool_set_true:N \l__knot_skip_bool
      }
    }
  }
%    \end{macrocode}
% The user can also say that end points of filaments (or strands) should simply be ignored anyway.
%    \begin{macrocode}
  \bool_if:NT \l__knot_ignore_ends_bool
  {
    \knot_test_endpoint:VnT \l__knot_tmpa_tl {initial point}
    {
      \bool_set_true:N \l__knot_skip_bool
    }
    \knot_test_endpoint:VnT \l__knot_tmpa_tl {final point}
    {
      \bool_set_true:N \l__knot_skip_bool
    }
    \knot_test_endpoint:VnT \l__knot_tmpb_tl {initial point}
    {
      \bool_set_true:N \l__knot_skip_bool
    }
    \knot_test_endpoint:VnT \l__knot_tmpb_tl {final point}
    {
      \bool_set_true:N \l__knot_skip_bool
    }
  }
%    \end{macrocode}
% Assuming that we passed all the above tests, we render the crossing.
%    \begin{macrocode}
  \bool_if:NF \l__knot_skip_bool
  {

    \int_gincr:N \l__knot_intersections_int
%    \end{macrocode}
% This is the intersection test.
% If the intersection finder finds too many, it might be useful to ignore some.
%    \begin{macrocode}
    \bool_if:nF
    {
      \tl_if_exist_p:c {l__knot_ignore_crossing_ \int_use:N
        \l__knot_intersections_int}
      &&
      ! \tl_if_empty_p:c {l__knot_ignore_crossing_ \int_use:N
        \l__knot_intersections_int}
    }
    {
%    \end{macrocode}
% This is the flip test.
% We only render one of the paths.
% The ``flip'' swaps which one we render.
%    \begin{macrocode}
      \bool_if:nTF
      {
        \tl_if_exist_p:c {l__knot_crossing_ \int_use:N
          \l__knot_intersections_int}
        &&
        ! \tl_if_empty_p:c {l__knot_crossing_ \int_use:N
          \l__knot_intersections_int}
      }
      {
        \tl_set_eq:NN \l__knot_tmpg_tl \l__knot_tmpb_tl
      }
      {
        \tl_set_eq:NN \l__knot_tmpg_tl \l__knot_tmpa_tl
      }
%    \end{macrocode}
% Now we know which one we're rendering, we test to see if we should also render its predecessor or successor to ensure that we render a path through the entire crossing region.
%    \begin{macrocode} 
      \bool_if:NT \l__knot_self_intersections_bool
      {
        \knot_test_endpoint:VnT \l__knot_tmpg_tl {initial point}
        {
          \bool_set_true:N \l__knot_prepend_prev_bool
        }
        {
          \bool_set_false:N \l__knot_prepend_prev_bool
        }
        \knot_test_endpoint:VnT \l__knot_tmpg_tl {final point}
        {
          \bool_set_true:N \l__knot_append_next_bool
        }
        {
          \bool_set_false:N \l__knot_append_next_bool
        }
%    \end{macrocode}
% If either of those tests succeeded, do the appending or prepending.
%    \begin{macrocode}
        \bool_if:nT
        {
          \l__knot_prepend_prev_bool || \l__knot_append_next_bool
        }
        {
          \tl_set_eq:cc {knot \tl_use:N \l__knot_prefix_tl -1} {knot \tl_use:N \l__knot_tmpg_tl}


          \tl_set_eq:cc {l__knot_options_ \tl_use:N \l__knot_prefix_tl -1} {l__knot_options_ \tl_use:N \l__knot_tmpg_tl}

          \bool_if:nT
          {
            \l__knot_prepend_prev_bool
            &&
            \tl_if_exist_p:c {knot previous \tl_use:N \l__knot_tmpg_tl}
            &&
            !\tl_if_empty_p:c {knot previous \tl_use:N \l__knot_tmpg_tl}
          }
          {
            \spath_prepend_no_move:cv {knot \tl_use:N \l__knot_prefix_tl -1} {knot \tl_use:c {knot previous \tl_use:N \l__knot_tmpg_tl}}
%    \end{macrocode}
% If we split potentially self intersecting curves, we test to see if we should prepend yet another segment.
%    \begin{macrocode}
            \bool_if:nT
            {
              \l__knot_splits_bool
              &&
              \tl_if_exist_p:c {knot previous \tl_use:N \l__knot_tmpg_tl}
              &&
              !\tl_if_empty_p:c {knot previous \tl_use:N \l__knot_tmpg_tl}
            }
            {
              \knot_test_endpoint:vnT {knot previous \tl_use:N \l__knot_tmpg_tl} {initial point}
              {
                
%                \spath_get:nnN {knot \tl_use:N \l__knot_prefix_tl -1} {path} \l_tmpa_tl
                \spath_prepend_no_move:cv {knot \tl_use:N \l__knot_prefix_tl -1} {knot \tl_use:c {knot previous \tl_use:c {knot previous \tl_use:N \l__knot_tmpg_tl}}}
                \tl_set_eq:Nc \l_tmpa_tl {knot \tl_use:N \l__knot_prefix_tl -1}
              }
            }
          }
%    \end{macrocode}
% Now the same for appending.
%    \begin{macrocode}
          \bool_if:nT
          {
            \l__knot_append_next_bool
            &&
            \tl_if_exist_p:c {knot next \tl_use:N \l__knot_tmpg_tl}
            &&
            !\tl_if_empty_p:c {knot previous \tl_use:N \l__knot_tmpg_tl}
          }
          {
            \spath_append_no_move:cv {knot \tl_use:N \l__knot_prefix_tl -1} {knot \tl_use:c {knot next \tl_use:N \l__knot_tmpg_tl}}
            \bool_if:nT
            {
              \l__knot_splits_bool
              &&
              \tl_if_exist_p:c {knot previous \tl_use:N
                \l__knot_tmpg_tl}
              &&
              !\tl_if_empty_p:c {knot previous \tl_use:N \l__knot_tmpg_tl}
            }
            {
              \knot_test_endpoint:vnT {knot previous \tl_use:N \l__knot_tmpg_tl} {final point}
              {
                \spath_append_no_move:cv {knot \tl_use:N \l__knot_prefix_tl -1} {knot \tl_use:c {knot next \tl_use:c {knot next \tl_use:N \l__knot_tmpg_tl}}}
                
              }
            }
          }

          \tl_set:Nn \l__knot_tmpg_tl {\tl_use:N \l__knot_prefix_tl -1}
        }
      }
%    \end{macrocode}
% Now we render the crossing.
%    \begin{macrocode}
      \pgfscope
      \group_begin:
      \tikzset{knot~ diagram/every~ intersection/.try, every~ intersection/.try, knot~ diagram/intersection~ \int_use:N \l__knot_intersections_int/.try}
      \knot_draw_crossing:VVV \l__knot_tmpg_tl \l__knot_tmpa_dim \l__knot_tmpb_dim
      \coordinate (\l__knot_name_tl \c_space_tl \int_use:N \l__knot_intersections_int) at (\dim_use:N \l__knot_tmpa_dim, \dim_use:N \l__knot_tmpb_dim);
      \group_end:
      \endpgfscope
%    \end{macrocode}
% This ends the boolean as to whether to consider the intersection at all      
%    \begin{macrocode}
    }
%    \end{macrocode}
% And possibly stick a coordinate with a label at the crossing.
%    \begin{macrocode}
    \tl_if_empty:NF \l__knot_node_tl
    {
      \seq_gpush:Nx \g__knot_nodes_seq { \l__knot_node_tl at (\dim_use:N \l__knot_tmpa_dim, \dim_use:N \l__knot_tmpb_dim) {};}
    }
  }
}

\cs_generate_variant:Nn \knot_intersections:nn {VV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_test_endpoint:N}
% Test whether the point is near the intersection point.
%    \begin{macrocode}
\prg_new_conditional:Npnn \knot_test_endpoint:N #1 {p,T,F,TF}
{
  \dim_compare:nTF
  {
    \dim_abs:n { \l__knot_tmpa_dim - \tl_item:Nn #1 {1}}
    +
    \dim_abs:n { \l__knot_tmpb_dim - \tl_item:Nn #1 {2}}
    <
    \l__knot_tolerance_dim
  }
  {
    \prg_return_true:
  }
  {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_test_endpoint:nn}
% Wrapper around the above.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \knot_test_endpoint:nn #1#2 {T,F,TF}
{
  \use:c {spath_#2:Nv} \l__knot_tmpd_tl {knot #1}
  \knot_test_endpoint:NTF \l__knot_tmpd_tl
  {
    \prg_return_true:
  }
  {
    \prg_return_false:
  }
}

\cs_generate_variant:Nn \knot_test_endpoint:nnT {VnT,vnT}
\cs_generate_variant:Nn \knot_test_endpoint:nnF {VnF,vnF}
\cs_generate_variant:Nn \knot_test_endpoint:nnTF {VnTF,vnTF}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_draw_crossing:nnn}
% This is the code that actually renders a crossing.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_draw_crossing:nnn #1#2#3
{
  \group_begin:
  \pgfscope
  \path[knot~ diagram/background~ clip] (#2, #3) circle[radius=\l__knot_clip_bg_radius_dim];

  \tl_set:Nn \l_tmpa_tl {knot~ diagram/every~ strand/.try,}
  \tl_if_exist:cT {l__knot_options_ #1}
  {
  \tl_put_right:Nv \l_tmpa_tl {l__knot_options_ #1}
  }
  \tl_put_right:Nn \l_tmpa_tl {,knotbg,line~ width= \tl_use:N \l__knot_clip_width_tl * \pgflinewidth}
  \spath_tikz_path:Vv \l_tmpa_tl {knot #1}

  \endpgfscope

  \pgfscope
  \path[knot~ diagram/clip] (#2, #3) circle[radius=\l__knot_clip_draw_radius_dim];

  \tl_set:Nn \l_tmpa_tl {knot~ diagram/every~ strand/.try,}
  \tl_if_exist:cT {l__knot_options_ #1}
  {
  \tl_put_right:Nv \l_tmpa_tl {l__knot_options_ #1}
  }
  \tl_put_right:Nn \l_tmpa_tl {,knot~ diagram/only~ when~ rendering/.try,only~ when~ rendering/.try}
  \spath_tikz_path:Vv \l_tmpa_tl {knot #1}

  \endpgfscope
  \group_end:
}

\cs_generate_variant:Nn \knot_draw_crossing:nnn {nVV, VVV}

\cs_new_protected_nopar:Npn \knot_draw_crossing:nn #1#2
{
  \tikz@scan@one@point\pgfutil@firstofone #2 \relax
  \knot_draw_crossing:nVV {#1} \pgf@x \pgf@y
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_split_strands:}
% This, and the following macros, are for splitting strands into filaments.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_split_strands:
{
  \int_gzero:N \l__knot_filaments_int
  \int_step_function:nnnN {1} {1} {\l__knot_strands_int} \knot_split_strand:n
  \int_step_function:nnnN {1} {1} {\l__knot_filaments_int} \knot_compute_nexts:n
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_compute_nexts:n}
% Each filament needs to know its predecessor and successor.
% We work out the predecessors as we go along, this fills in the successors.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_compute_nexts:n #1
{
  \tl_clear_new:c {knot next \tl_use:c {knot previous filament #1}}
  \tl_set:cn {knot next \tl_use:c {knot previous filament #1}} {filament #1}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_split_strand:n}
% Sets up the split for a single strand.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_split_strand:n #1
{
  \int_set_eq:NN \l__knot_component_start_int \l__knot_filaments_int
  \int_incr:N \l__knot_component_start_int
  \tl_set_eq:Nc \l__knot_tmpa_tl {l__knot_options_strand #1}
  \spath_segments_to_seq:Nv \l_@@_segments_seq {knot strand #1}
  \seq_map_function:NN \l_@@_segments_seq \knot_save_filament:N
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\knot_save_filament:N}
% Saves a filament as a new \Verb+spath+ object.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \knot_save_filament:N #1
{
  \tl_set:Nx \l_@@_tmpb_tl {\tl_item:nn {#1} {4}}
  \tl_case:NnF \l_@@_tmpb_tl
  {
    \c_spath_moveto_tl
    {
      \int_compare:nT {\l__knot_component_start_int < \l__knot_filaments_int}
      {
        \int_set_eq:NN \l__knot_component_start_int \l__knot_filaments_int
      }
    }
    \c_spath_lineto_tl
    {
      \int_gincr:N \l__knot_filaments_int
      \tl_set:cn {knot filament \int_use:N \l__knot_filaments_int} {#1}
      \tl_set_eq:cN {l__knot_options_filament \int_use:N \l__knot_filaments_int} \l__knot_tmpa_tl

      \tl_clear_new:c {knot previous filament \int_use:N \l__knot_filaments_int}
      \int_compare:nF {\l__knot_component_start_int == \l__knot_filaments_int}
      {
        \tl_set:cx {knot previous filament \int_use:N \l__knot_filaments_int} {filament \int_eval:n {\l__knot_filaments_int - 1}}
      }
    }
    \c_spath_curvetoa_tl
    {
      \int_gincr:N \l__knot_filaments_int
      \tl_clear_new:c {knot filament \int_use:N \l__knot_filaments_int}
      \tl_set:cn {knot filament \int_use:N \l__knot_filaments_int} {#1}
      \tl_set_eq:cN {l__knot_options_filament \int_use:N \l__knot_filaments_int} \l__knot_tmpa_tl

      \tl_clear_new:c {knot previous filament \int_use:N \l__knot_filaments_int}
      \int_compare:nF {\l__knot_component_start_int == \l__knot_filaments_int}
      {
        \tl_set:cx {knot previous filament \int_use:N \l__knot_filaments_int} {filament \int_eval:n {\l__knot_filaments_int - 1}}
      }
    }
    \c_spath_closepath_tl
    {
      \int_gincr:N \l__knot_filaments_int
      \tl_clear_new:c {knot filament \int_use:N \l__knot_filaments_int}
      \tl_clear:N \l_tmpa_tl
      \tl_put_right:Nx {\tl_item:nn {#1} {1}\tl_item:nn {#1} {2}\tl_item:nn {#1} {3}}
      \tl_put_right:NV \l_tmpa_tl \c_spath_lineto_tl
      \tl_put_right:Nx {\tl_item:nn {#1} {5}\tl_item:nn {#1} {6}}

      \tl_set:cV {knot filament \int_use:N \l__knot_filaments_int} \l_tmpa_tl
      \tl_set_eq:cN {l__knot_options_filament \int_use:N \l__knot_filaments_int} \l__knot_tmpa_tl
      \tl_clear_new:c {knot previous filament \int_use:N \l__knot_filaments_int}
      \int_compare:nF {\l__knot_component_start_int == \l__knot_filaments_int}
      {
        \tl_set:cx {knot previous filament \int_use:N \l__knot_filaments_int} {filament \int_eval:n {\l__knot_filaments_int - 1}}
      }
      \tl_set:cx {knot previous filament \int_use:N \l__knot_component_start_int} {filament \int_use:N \l__knot_filaments_int}
    }
  }
  {
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{\redraw}
% The user can redraw segments of the strands at specific locations.
%    \begin{macrocode}
\NewDocumentCommand \redraw { m m }
{
%  \tikz@scan@one@point\pgfutil@firstofone #2 \relax
  \tl_put_right:Nn \l__knot_redraws_tl {\knot_draw_crossing:nn}
  \tl_put_right:Nx \l__knot_redraws_tl {
    {strand #1} {#2}% {\dim_use:N \pgf@x} {\dim_use:N \pgf@y}
  }
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
%<@@=>
%
% \begin{macro}[internal]{\pgf@sh@@knotanchor}
% Add the extra anchors for the knot crossing nodes.
%    \begin{macrocode}
\def\pgf@sh@@knotanchor#1#2{%
  \anchor{#2 north west}{%
    \csname pgf@anchor@knot #1@north west\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 north east}{%
    \csname pgf@anchor@knot #1@north east\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 south west}{%
    \csname pgf@anchor@knot #1@south west\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 south east}{%
    \csname pgf@anchor@knot #1@south east\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 north}{%
    \csname pgf@anchor@knot #1@north\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 east}{%
    \csname pgf@anchor@knot #1@east\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 west}{%
    \csname pgf@anchor@knot #1@west\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
  \anchor{#2 south}{%
    \csname pgf@anchor@knot #1@south\endcsname%
    \pgf@x=#2\pgf@x%
    \pgf@y=#2\pgf@y%
  }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{knot crossing}
%    \begin{macrocode}
\pgfdeclareshape{knot crossing}
{
  \inheritsavedanchors[from=circle] % this is nearly a circle
  \inheritanchorborder[from=circle]
  \inheritanchor[from=circle]{north}
  \inheritanchor[from=circle]{north west}
  \inheritanchor[from=circle]{north east}
  \inheritanchor[from=circle]{center}
  \inheritanchor[from=circle]{west}
  \inheritanchor[from=circle]{east}
  \inheritanchor[from=circle]{mid}
  \inheritanchor[from=circle]{mid west}
  \inheritanchor[from=circle]{mid east}
  \inheritanchor[from=circle]{base}
  \inheritanchor[from=circle]{base west}
  \inheritanchor[from=circle]{base east}
  \inheritanchor[from=circle]{south}
  \inheritanchor[from=circle]{south west}
  \inheritanchor[from=circle]{south east}
  \inheritanchorborder[from=circle]
  \pgf@sh@@knotanchor{crossing}{2}
  \pgf@sh@@knotanchor{crossing}{3}
  \pgf@sh@@knotanchor{crossing}{4}
  \pgf@sh@@knotanchor{crossing}{8}
  \pgf@sh@@knotanchor{crossing}{16}
  \pgf@sh@@knotanchor{crossing}{32}
  \backgroundpath{
    \pgfutil@tempdima=\radius%
    \pgfmathsetlength{\pgf@xb}{\pgfkeysvalueof{/pgf/outer xsep}}%  
    \pgfmathsetlength{\pgf@yb}{\pgfkeysvalueof{/pgf/outer ysep}}%  
    \ifdim\pgf@xb<\pgf@yb%
      \advance\pgfutil@tempdima by-\pgf@yb%
    \else%
      \advance\pgfutil@tempdima by-\pgf@xb%
    \fi%
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{knot over cross}
%    \begin{macrocode}
\pgfdeclareshape{knot over cross}
{
  \inheritsavedanchors[from=rectangle] % this is nearly a circle
  \inheritanchorborder[from=rectangle]
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{mid}
  \inheritanchor[from=rectangle]{mid west}
  \inheritanchor[from=rectangle]{mid east}
  \inheritanchor[from=rectangle]{base}
  \inheritanchor[from=rectangle]{base west}
  \inheritanchor[from=rectangle]{base east}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchorborder[from=rectangle]
  \backgroundpath{
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@yb}}
  }
  \foregroundpath{
% store lower right in xa/ya and upper right in xb/yb
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@ya}}
 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{knot under cross}
%    \begin{macrocode}
\pgfdeclareshape{knot under cross}
{
  \inheritsavedanchors[from=rectangle] % this is nearly a circle
  \inheritanchorborder[from=rectangle]
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{mid}
  \inheritanchor[from=rectangle]{mid west}
  \inheritanchor[from=rectangle]{mid east}
  \inheritanchor[from=rectangle]{base}
  \inheritanchor[from=rectangle]{base west}
  \inheritanchor[from=rectangle]{base east}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchorborder[from=rectangle]
  \backgroundpath{
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@ya}}
  }
  \foregroundpath{
% store lower right in xa/ya and upper right in xb/yb
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@yb}}
 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{knot vert}
%    \begin{macrocode}
\pgfdeclareshape{knot vert}
{
  \inheritsavedanchors[from=rectangle] % this is nearly a circle
  \inheritanchorborder[from=rectangle]
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{mid}
  \inheritanchor[from=rectangle]{mid west}
  \inheritanchor[from=rectangle]{mid east}
  \inheritanchor[from=rectangle]{base}
  \inheritanchor[from=rectangle]{base west}
  \inheritanchor[from=rectangle]{base east}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchorborder[from=rectangle]
  \backgroundpath{
% store lower right in xa/ya and upper right in xb/yb
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfqpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathmoveto{\pgfqpoint{\pgf@xb}{\pgf@yb}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@ya}}
 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[internal]{knot horiz}
%    \begin{macrocode}
\pgfdeclareshape{knot horiz}
{
  \inheritsavedanchors[from=rectangle] % this is nearly a circle
  \inheritanchorborder[from=rectangle]
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{mid}
  \inheritanchor[from=rectangle]{mid west}
  \inheritanchor[from=rectangle]{mid east}
  \inheritanchor[from=rectangle]{base}
  \inheritanchor[from=rectangle]{base west}
  \inheritanchor[from=rectangle]{base east}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchorborder[from=rectangle]
  \foregroundpath{
% store lower right in xa/ya and upper right in xb/yb
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@ya}}
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@yb}}
 }
}
%    \end{macrocode}
% \end{macro}
%
% \iffalse
%</knots>
% \fi
%\Finale
\endinput
